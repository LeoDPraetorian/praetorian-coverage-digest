## []{#ch15.xhtml_page_143 .pagebreak}**15  LPC1114 Bootloader Glitch** {#ch15.xhtml_ch15 .h2a}

In addition to the software vulnerabilities discussed in [Chapter
4](#ch04.xhtml_ch04), the LPC1114 and LPC1343 are vulnerable to voltage
glitching attacks documented in Gerlinsky (2017), Nedospasov (2017), and
Dewar (2018). This is a beginner's glitching attack, a good first target
to learn fault injection.

Before we get started, look at [Figure 4.5](#ch04.xhtml_ch4fig5) and
review the explanation of the lock features in [Chapter
4](#ch04.xhtml_ch04). When the lock level is CRP1, we can use the memory
corruption exploit in that chapter to dump the chip's memory, but in
CRP2 and CRP3 the bootloader commands are so restricted that we can't
trigger the vulnerability. That's where voltage glitching comes in.

You should also see in [Figure 4.5](#ch04.xhtml_ch4fig5) that a single
word of flash memory controls the protection mode.
[0x12345678]{.literal} places us in CRP1, where the remote code
execution exploit works. [0x4321-8765]{.literal} places us in CRP3,
where both JTAG and the ISP programming mode are entirely disabled.
[0x87654321]{.literal} is just as bad, allowing ISP but *only* the Mass
Erase command.

The very last line of that table is the important one, and the reason
why these chips are such an easy target for glitching. If the 32-bit
word has *any other value* than the ones in that table, it defaults to
being totally open to both JTAG debugging and ISP programming. While
[0x43218765]{.literal} or [0x87654321]{.literal} will lock us out, a
single bit error might change those to [0x43208765]{.literal} or
[0x87654331]{.literal}, either of which would provide us with full
access. The purpose of our fault injection will be to corrupt that word,
providing just such a change.

::: image
[]{#ch15.xhtml_page_144
.pagebreak}![Image](images/f0144-01.jpg){#ch15fig1}

> **Description:** Die photo of a flash-based microcontroller showing large memory array dominating the right half of the chip. The left side contains logic circuits, control blocks, and peripheral interfaces. The bottom portion shows additional memory blocks organized in a modular fashion. Bond pads line all four edges of the die for external connections. The regular, repeating structures indicate flash memory cells arranged in rows and columns for code storage.

:::

Figure 15.1: LPC111x

::: image
[]{#ch15.xhtml_page_145
.pagebreak}![Image](images/f0145-01.jpg){#ch15fig2}

> **Description:** Detailed schematic of an LPC-P1114 development board showing debug interface, power supply, buttons, and UEXT connector sections. The debug interface uses a 20-pin ARM connector with SWD, JTAG, and MOSI/MISO signals. The power supply section includes LM1117MPX ADJ regulator, BAT54C diodes, and supporting capacitors. The main LPC1114FBD48/301 microcontroller is shown with extensive GPIO connections. The UEXT section provides standardized expansion with SPI, I2C, UART interfaces. USB connections and programming interfaces are clearly labeled.

:::

Figure 15.2: Olimex LPC-P1114 Schematic

### []{#ch15.xhtml_page_146 .pagebreak}**Hardware Modifications** {#ch15.xhtml_ch00lev1sec47 .h3}

Gerlinsky, Nedospasov, and Dewar each made slightly different
modifications to the Olimex development kit in [Figure
15.2](#ch15.xhtml_ch15fig2), but the general principle is the same.

First, we want to remove the 100nF decoupling capacitor, which is C4 in
the schematic. The purpose of this capacitor is to prevent momentary
drops in voltage from causing faults in the chip, and we're removing it
because our intention is to cause this momentary failure. Leaving it in
would make glitching much more difficult.

The decoupling capacitor for this chip is designed to sit between the
VSS and 3.3V VDD lines, but on many other chips you'll find multiple
decoupling capacitors or you'll find that the cap is on a dedicated pin
at a lower voltage, the CPU core voltage.

The board also has two traces that might be cut, and we need to cut both
of them. [3.3V_IO_E]{.literal} connects C1 and the VDDIO pin to the 3.3V
power rail, while [3.3V_CORE]{.literal} connects the VDD pin to the 3.3V
rail. We'll cut both, then reconnect the two sides of the cut
[3.3V_CORE]{.literal} trace with a 12 Ω resistor. This lets us measure
the power consumption of the chip, as the current consumption will cause
a very small voltage drop across the resistor. Such a measurement is not
necessary to perform the glitch after timing is known but can be very
handy for discovering the timing.

Shorting [P0_3]{.literal} to ground will enable the bootloader mode. We
will also add an SMA connector to expose ground and the 3.3V power rail
to our voltage glitcher. The glitching hardware itself is just briefly
shorting those two pins together, and while Dewar (2018) uses a
ChipWhisperer and Gerlinsky (2017) uses a microcontroller board, you can
short them with a transistor and nearly anything that sends a short
pulse to that transistor with predictable timing after reset.

### []{#ch15.xhtml_page_147 .pagebreak}**How Hard to Glitch?** {#ch15.xhtml_ch00lev1sec48 .h3}

We now have an SMA connector through which we can glitch the chip,
briefly shorting the voltage rail to ground without a decoupling
capacitor to save it. Before we can get to the question of timing, we
need to know at least roughly how much of a glitch to apply. Too much of
a glitch will crash or reboot the target, while too little of a glitch
will have no effect at all, as the voltage drop will be attenuated by
the natural capacitance and line length until nothing happens.

If we imagine the idle state of this pin as a flat 3.3V voltage that
we'll drop low, there are two basic parameters to our glitch: the
*depth* and the *duration*.

The depth of a glitch is the voltage to which we will drop the pin. It's
usually measured from the side of the glitcher, with the understanding
that the target won't fall immediately to that voltage and might not
fall all the way to it. A "crowbar" glitcher, such as the ChipWhisperer,
simply shorts the two rails together with a MOSFET, so its depth is
effectively ground.

You'll generally find crowbar glitchers on more recent devices, because
the clock rate allows them to run fast enough that the glitch won't
crash the target. They are also quite simple to place on the circuit
board, with nothing more than a MOSFET transistor controlled by a GPIO
pin of the attacking microcontroller. Common choices of MOSFET include
the IRLML6246 and IRF8736.

Back in the days of TV piracy, it was more common to use a 74HC4053
multiplexer to jump between full voltage and the deep voltage. During
development, both could be supplied by a bench power supply, and the
glitches would be a little wider but not quite so deep.

Having either one dimension (duration) or two (duration and
[]{#ch15.xhtml_page_148 .pagebreak}depth) to calibrate, we'd much rather
find the right values before involving the extra dimension of time. This
is most conveniently done by running a program from flash or from RAM
that is intentionally designed to be an easy target.

When the settings are roughly correct, this code will start printing to
the serial port. It's important the three variables are all volatile so
that the C compiler will not optimize away their differences.

::: imagel
![Image](images/f0148-01.jpg)

> **Description:** C code implementing a glitch detection loop using volatile integers i, j, k. The code enters an infinite while loop and increments three separate integers (i, j, k) from 0 to 254 in a for loop. After each iteration, it checks if the values match - if i!=j or j!=k, it transmits "?." via txbyte() to signal a glitch was detected. This demonstrates a simple but effective glitch detection mechanism that can identify clock or voltage glitches causing computational errors.

:::

Of course, we can only train our parameters on this code because the
chip we are attacking is also available as an unlocked part for
commercial use. When glitching a smart card, or anything else in which
an unlocked sample is not available, the procedure is usually to glitch
some other behavior, like the readout of the device serial number.

### **When to Glitch?** {#ch15.xhtml_ch00lev1sec49 .h3}

Now that we know how wide (in duration) and how deep (in voltage) to
glitch to cause a fault, we still need to know when to trigger the
glitch. We'll first choose a trigger as the beginning of time, then
choose a measure of time to count after that trigger, and finally search
for a range of times that might be running a vulnerable instruction
worth glitching.

This is usually measured as some number of microseconds or clock cycles
after a particular event, such as the reset line rising
[]{#ch15.xhtml_page_149 .pagebreak}high. It's important to distinguish
between the target's clock signal, which will be rather tightly coupled
to the internal CPU clock, and the attacker's clock signal, which is
rather loosely coupled and really just another way to measure wall clock
time.

The target's clock input pin used to be a very good way to accurately
target specific instructions, but these days many chips like the LPC11
default to an internal oscillator as the bootloader's system clock, only
jumping over to an external crystal in the main application. Other chips
use an internal phase-locked loop (PLL) to multiply an external clock's
frequency, providing some relation but at a weak resolution. In this
chapter, we'll ignore the external oscillator and use wall time instead.

Now that we have chosen a measure of time, and we have chosen the rise
of the reset pin as zero time, we need to know when to apply a glitch to
unlock the bootloader. On other targets, we might do this through power
analysis, running our SMA connector to a T-junction that reaches both
the glitcher and an oscilloscope. On this target we have something
better: a dump of the boot ROM, which we made for writing our shellcode
in [Chapter 4](#ch04.xhtml_ch04).

Recall from that chapter that the bootloader checks its lock state many
times, but that it is always checking a copy in SRAM that is made early
in the boot sequence. That's why the shell-code for the software exploit
simply rewrites the SRAM copy of the CRP level and jumps right back into
the main loop of the bootloader, reusing its code with a privilege
escalation.

::: imagel
![Image](images/f0149-01.jpg)

> **Description:** Assembly code listing showing glitch targets on LPC1x firmware. Line 1 comments describe reading protection from address 0x000.002fc in Flash. Line 4 shows "1fff1276 00 68 ldr r0,[r0,#0x0]=>CRP_FLASH" reading the flash protection value. Lines 5-6 demonstrate writing protection to 0x1000.0184 in SRAM with "1fff1278 88 60 str r0,[r1,#0x8]=>CRP_SRAM". These instructions are critical attack points for bypassing code read protection.

:::

[]{#ch15.xhtml_page_150 .pagebreak}In this glitching attack we don't
have a write primitive, of course, but we know that there is an
instruction or two doing the copy. Maybe we flip a bit as it's read from
flash memory, or maybe we flip a bit as it's written to SRAM, or maybe
we flip an opcode bit to make it a different instruction.

On 8-bit CISC chips, we might come up with this by simply counting
instructions and their cycle costs. As the LPC11 is a pipelined RISC
chip, that becomes a little labor intensive, as any glitch will be
impacting multiple instructions at once. Another option for some ARM
chips is to use the Embedded Trace Macrocell (ETM), which allows an
external debugger to trace every instruction as it's executed. We might
also run a modified version of the boot ROM from RAM, patched to reveal
its timing through a GPIO pin.

Without resorting to those fancy tricks, we still have some timing
clues. We know that the ROM can't begin execution before the reset line
goes high, and we know that it must be past the target instruction when
it accepts our first command. If we're patient, we can sweep across this
entire range until the chip unlocks, then repeat the effect in far less
time knowing the offset.

It's not uncommon for chips to be exploited this way, with a glitcher
sitting on a rack or in a closet for days or weeks before the right
timing emerges.

Dewar (2018) suggests that attacking from a 100MHz clock, unlocks were
seen with roughly ten glitches between 5,100 and 5,300 cycles. One board
worked best with ten pulses at 5,211 ticks, while another worked best
with eleven pulses at 5,181 ticks. The variance likely comes from the
internal R/C oscillator of the target chip, or the room temperature, and
it's not at all strange for different targets to successfully unlock at
different times.

::: imagel
[]{#ch15.xhtml_page_151 .pagebreak}![Image](images/f0151-01.jpg)

> **Description:** Python script header for breaking LPC1114 bootloader and dumping flash to files. The script is designed for use without the CW GUI and is sourced from wiki.newae.com. It imports necessary modules including sys, binascii, time, logging, os, collections, numpy, and chipwhisperer. The code disables printing when glitch parameters change by setting Parameter.printParameterPath = False. Comments indicate this is part 1 of a multi-part bootloader bypass exploit.

:::

::: imagel
[]{#ch15.xhtml_page_152 .pagebreak}![Image](images/f0152-01.jpg)

> **Description:** Python code continuation showing glitcher configuration and initialization. The code sets target baud rate to 38400 with empty key_cmd, go_cmd, and output_cmd strings. It creates an LPC_glitch object, initializes the scope and target, then defines freq_multiplier=2 for running at 2x speed (200 MHz instead of 100 MHz) to achieve better glitch resolution. Initial setup configures ADC with 10000 samples, offset 0, clock source "clkgen_x1", and trigger on "tio4". Glitch parameters include width=40 and IO assignments for serial RX/TX.

:::

::: imagel
[]{#ch15.xhtml_page_153 .pagebreak}![Image](images/f0153-01.jpg)

> **Description:** Python code function dump_flash for reading flash memory in configurable byte increments. The function accepts start_addr (default 0), length (default 0x8000), and rd_len (default 24) parameters, with notes that rd_len should be under 45 bytes due to line buffering limits and must be divisible by 4 (whole number) since the decoder doesn't handle padding bytes. The function validates 4-byte alignment for both address and length, prints error messages if misaligned, then proceeds to eat data return and checksum values before sending "OK".

:::

::: imagel
[]{#ch15.xhtml_page_154 .pagebreak}![Image](images/f0154-01.jpg)

> **Description:** Python code continuation of flash dump function showing the main read loop. After sleeping 0.1 seconds, the code opens three output files: uu_flash.txt, ascii_flash.txt, and bin_flash.bin. The loop iterates through memory addresses sending read commands "R {:d} {:d}" formatted with address and length. For each response, it checks for address errors ("13" in err), extracts data_len by subtracting 32 from the first byte, validates against rd_len, and handles mismatches by printing error details and actual flash response.

:::

::: imagel
[]{#ch15.xhtml_page_155
.pagebreak}![Image](images/f0155-01.jpg)

> **Description:** Python code final section of flash dump showing data parsing and file writing. The bootloader replaces apostrophes with spaces in the flash data output. After reading the checksum, the code writes data to three file formats: uu_file in uuencoded format (0x{:08x}: + data), binary_data converted from ASCII via binascii.a2b_uu() written to bin_file, and ascii_file in hexlified format. Exception handling catches binascii.Error for invalid data. The function closes all files and returns 0 on completion.
[]{#ch15.xhtml_page_156
.pagebreak}
:::

[]{#ch16.xhtml}

