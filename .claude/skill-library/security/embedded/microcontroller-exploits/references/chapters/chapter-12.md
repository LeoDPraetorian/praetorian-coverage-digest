## []{#ch12.xhtml_page_119 .pagebreak}**12  PIC18F452 ICSP and HID** {#ch12.xhtml_ch12 .h2a}

Back in 2010, there was a lot of interest in exploiting RFID tags that
hold symmetric keys. The cards themselves were reasonably well protected
from memory extraction, and keys might be unique to each customer's
installation, so researchers would instead attack the readers. These
readers often used commodity microcontrollers and trusted their readout
protection to keep the symmetric keys safe.

In this chapter, we'll cover two such exploits that were used to extract
keys from HID iClass readers. Both of them exploit nuances in ICSP,
Microchip's in circuit serial programming standard. The first, published
at 27C3 as Meriac (2010), involves erasing a protected page of flash
memory over ICSP and replacing it with shellcode that dumps the rest.
The second, Huffstutter (2011), involves using the same ICSP protocol to
dump RAM, rather than flash memory, because the chip has no protection
bits set for RAM.

The target reader in this case is the HID RW400, which was chosen by
Meriac because it was the oldest programmer to support the iClass cards.
This is shown in [Figure 12.1](#ch12.xhtml_ch12fig1), where an opaque
epoxy potting covers the circuits that we can see in X-ray in [Figure
12.2](#ch12.xhtml_ch12fig2).

There are many minor variants of the ICSP protocol, each explained in a
"FLASH Microcontroller Programming Specification" document that covers
ten or twenty part numbers.

Older chips require a high voltage for erasure to be externally applied,
while modern chips also support a low-voltage mode in which the
programming voltage is internally generated. If no other vulnerabilities
are handy, it would certainly be worth experimenting with bad voltages
and timing here. [Chapter H.1](#app08.xhtml_app08_1) describes just such
an attack from the Nineties.

::: image
[]{#ch12.xhtml_page_120
.pagebreak}![Image](images/f0120-01.jpg){#ch12fig1}

> **Description:** Photograph showing internal components of a card reader or smart card device. The image is divided into two sections showing a removed IC chip in the upper left (with visible bond wires), and a complete card assembly below featuring two 7-segment or keypad arrays on the left, a circular element (possibly a battery or sensor), and a small chip on the right. The components are mounted on what appears to be a flexible substrate or thin PCB.

:::

Figure 12.1: HID RW400 Card Reader

::: image
[]{#ch12.xhtml_page_121
.pagebreak}![Image](images/f0121-01.jpg){#ch12fig2}

> **Description:** X-ray image of a smart card or RFID device showing internal construction. The card contains a rectangular circuit board in the center with an IC chip mounted centrally. A white wire antenna is visible running from the chip to a connector at the top. The card has four mounting holes at the corners. The X-ray reveals the internal metal traces, the chip die, and bond wires connecting the chip to the antenna structure.

:::

Figure 12.2: HID RW400 in X-ray

[]{#ch12.xhtml_page_122 .pagebreak}PIC18 is a bit less threadbare than
the earlier PIC architectures, but it is still designed around a
philosophy of reusing as many components as possible in order to keep
the transistor count as small as possible.

The ICSP protocol looks much like SPI, except that there is a single
data pin whose direction changes as appropriate. See [Figure
12.3](#ch12.xhtml_ch12fig3) for the pinout of the six pins to the left
of the piezoelectric buzzer in [Figure 12.1](#ch12.xhtml_ch12fig1). All
transactions are exactly twenty bits, consisting of a 4-bit opcode
command and a 16-bit parameter.

In ICSP, command [0000]{.literal} executes the parameter as a raw PIC18
instruction. [0010]{.literal} reads out the [TABLAT]{.literal} (Table
Latch) register, while [1000]{.literal} to [1011]{.literal} are Table
Read commands and [1100]{.literal} to [1111]{.literal} are Table Write
commands. This is a rather roundabout way to read code memory, but it is
roughly in line with the table pointer operations in PIC18 assembly
language. The programming specification contains example pairs of
commands and instructions for erasing memory and writing code into it.

Flash (code), RAM, and EEPROM are in separate address spaces, and a
series of Configuration Words describe the protection settings, along
with settings for the oscillators, timers, brownout protection, and
other configurable features. These 16-bit words begin at
[0x300000]{.literal} in flash memory. To the developer, these settings
are defined as [#pragma]{.literal} lines, such as those in [Figure
12.4](#ch12.xhtml_ch12fig4).

Code memory is divided into pages of somewhat awkward sizes. The first
is a bootloader page of 512 bytes at [0x0000]{.literal}, followed by
7,680 bytes of Page 0 from [0x0200]{.literal} to [0x1fff]{.literal}. The
remaining pages are each 8kB. See [Figure 12.6](#ch12.xhtml_ch12fig6)
for a diagram of the layout.

::: image
[]{#ch12.xhtml_page_123
.pagebreak}![Image](images/f0123-01.jpg){#ch12fig3}

> **Description:** Pinout comparison table showing RW400 Signal pins mapped to Standard Pin numbers. The mapping includes: Pin 1 (Vss) to Pin 3, Pin 2 (Vdd) to Pin 2, Pin 3 (Vpp/MCLR) to Pin 1, Pin 4 (PGD) to Pin 4, Pin 5 (PGC) to Pin 5, and Pin 6 (PGM) to Pin 6. This table facilitates connecting the RW400 programmer to devices using standard ICSP (In-Circuit Serial Programming) pinouts.

:::

Figure 12.3: Custom ICSP Pinout on the HID RW400

::: image
![Image](images/f0123-02.jpg){#ch12fig4}

> **Description:** C code showing ICSP (In-Circuit Serial Programming) configuration pragmas for code and write protection. CONFIG5 section enables read protection for multiple 2KB-4KB code blocks (CP0-CP3 at addresses 000200-007FFFh) and boot block (CPB at 000000-0001FFh), plus data EEPROM protection (CPD). CONFIG6 section enables write protection for similar code regions (WRT0-WRT3) and config registers (WRTC), but explicitly disables data EEPROM write protection (WRTD = OFF). CONFIG7 disables read protection from other code blocks (EBTR0-EBTR3, EBTRB = OFF).

:::

Figure 12.4: Configuration Words of the HID RW400 Reader

[]{#ch12.xhtml_page_124 .pagebreak}Each page has a [CP]{.literal} bit.
This bit is cleared to enable Code Protection, a [WRT]{.literal} bit to
enable Write Protection, and an [EBT]{.literal} bit to enable Table Read
Protection so that code running from another page may not read this page
as data through the table interface. These bits are set by erasing the
page in question.

### **Meriac's Boot Block Exploit** {#ch12.xhtml_ch00lev1sec43 .h3}

When Milosch Meriac wanted to dump this chip from an HID RW400 reader in
Meriac (2010), he found that the [CP]{.literal} and [WRT]{.literal} bits
had been cleared so that instructions executing from the ICSP context
were not permitted to read or write any blocks of flash memory. He chose
these readers because they were the oldest to support the iClass cards,
and you can find the configuration bits of a reader in [Figure
12.4](#ch12.xhtml_ch12fig4).

Fortunately, the [EBT]{.literal} bits had not been cleared. If they had
been, code running from one page of flash memory would not be allowed to
perform table reads on any other page. Because these bits are still set,
the entire chip's memory can be dumped from code running in any page.

Meriac observed that by erasing a page, he could set the [CP]{.literal},
[WRT]{.literal}, and [EBT]{.literal} bits of that
page.^[1](#footnotes.xhtml_ch12fn1){#ch12.xhtml_ch12fn_1}^ This then
allowed him to write a bit of shellcode into the page, which would dump
the rest of memory out the serial port.

He packaged this as a C[++]{.literal} application for Windows, that
bit-bangs ICSP into the debug interface through an FTDI chip's GPIO pins
and then reads back the firmware through that same chip's UART. His
shellcode is shown in [Figure 12.5](#ch12.xhtml_ch12fig5); it simply
dumps the firmware to the UART.

::: image
[]{#ch12.xhtml_page_125
.pagebreak}![Image](images/f0125-01.jpg){#ch12fig5}

> **Description:** C code for XC8 v2.31 compiler that dumps memory via UART. After defining LED pins (LED_GREEN on RB1, LED_RED on RB2), the main function configures TRISB, disables interrupts, and initializes USART at 115200 baud with high-speed TX enabled. A red LED indicates the dump process is active while a do-while loop transmits each byte of memory pointed to by CODEPTR (starting from 0) until reaching address 0x8000. After completion, the red LED turns off and green LED turns on, then the code enters an idle infinite loop.

:::

Figure 12.5: Meriac's PIC18 Dumper Source

::: image
[]{#ch12.xhtml_page_126
.pagebreak}![Image](images/f0126-01.jpg){#ch12fig6}

> **Description:** Memory map diagram showing flash memory organization in 4 blocks. Block 0 (Boot Block) occupies addresses 0x00200-0x02000, Block 1 spans 0x02000-0x04000, Block 2 covers 0x04000-0x06000, and Block 3 extends from 0x06000-0x08000. A note indicates "Meriac erased this, replacing it with shellcode to dump other blocks," showing that the boot block was modified to extract contents from the protected upper blocks.

:::

Figure 12.6: PIC18F452 Flash Map

::: image
![Image](images/f0126-02.jpg){#ch12fig7}

> **Description:** Terminal output showing hexadecimal memory dump data. Nine lines display colon-prefixed hex strings representing raw memory contents. The data includes address markers (020000040000FA, 06000000F0D3EF00F058) and various byte sequences. The final line ":00000001FF" indicates the end of the Intel HEX format dump. This data format is commonly used for transferring binary firmware images via serial interfaces.

:::

Figure 12.7: Meriac's PIC18 Dumper Shellcode

::: image
[]{#ch12.xhtml_page_127
.pagebreak}![Image](images/f0127-01.jpg){#ch12fig8}

> **Description:** Die photo of a microcontroller showing four large vertical memory blocks occupying most of the die area. Each block contains dense regular arrays, likely flash memory or ROM. The upper portion displays logic circuitry with control blocks, peripheral interfaces, and I/O circuits. Bond pads line the perimeter for external connections. The organized, symmetrical layout with four identical memory segments indicates a modular memory architecture design typical of modern embedded microcontrollers.

:::

Figure 12.8: Microchip PIC18F452

::: image
[]{#ch12.xhtml_page_128
.pagebreak}![Image](images/f0128-01.jpg){#ch12fig9}

> **Description:** Assembly code table showing memory zeroing operation followed by a read loop. The table has four columns: Command (Cmd), hex data, assembly instruction (Asm), and comments. Instructions at address 0x0000 zero the start address using movlw,0 and movfw,fsr0h/fsr0l. At address 0x0010, a "read" operation begins, loading 1,536 words via loop instructions movf,postinco and movfw,tablat. This demonstrates systematic memory traversal for data extraction.

:::

Figure 12.9: Huffstutter's ICSP RAM Extraction

For his target, it was sufficient to erase and rewrite the 512-byte
bootloader page with the shellcode binary, as this page conveniently had
no contents worth missing. Other targets might have something important
in the boot block, and on those targets, a second victim device is
required. This second device has every page *except* for the first page
erased. These pages are then overwritten with a sled of repeated NOP
instructions, leading to the shellcode at the very end of memory. The
idea is that the boot block will eventually branch somewhere in the
other blocks, and that almost every legal address will then slide to the
shellcode to dump the very first block.

### []{#ch12.xhtml_page_129 .pagebreak}**Huffstutter's ICSP SRAM Exploit** {#ch12.xhtml_ch00lev1sec44 .h3}

Carl Huffstutter describes a different exploit for the same firmware
image on the same chip in Huffstutter (2011). He saw that while every
bank of flash memory and EEPROM has its own protection fuse bits, there
are no such bits for protecting RAM. Sure enough, the ICSP transactions
in [Figure 12.9](#ch12.xhtml_ch12fig9) cleanly and non-destructively
extract all RAM from a locked microcontroller.

In RAM, he found the 64-bit HID Master authentication key, two 64-bit
Triple DES keys for encrypting comms between the reader and the card,
the 128-byte key table for use with High Security cards, and all the
details of the last card read. This information wasn't erased after use,
but had it been, the machine might still be interrupted mid-read to
reveal the contents in use.

Many other devices expose SRAM while protecting flash memory, so it's
worth considering this attack whenever you need data from a chip and
don't necessarily need a copy of the code. On the defensive side, it
might help to declare any important keys and tables as [const]{.literal}
so that they are located only in flash memory and never copied into
RAM.[]{#ch12.xhtml_page_130 .pagebreak}

[]{#ch13.xhtml}

