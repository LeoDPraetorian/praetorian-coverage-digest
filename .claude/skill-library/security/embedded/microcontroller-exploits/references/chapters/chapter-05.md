## []{#ch05.xhtml_page_53 .pagebreak}**5â€‚Ledger Nano S, 0xF00DBABE** {#ch05.xhtml_ch05 .h2}

The Ledger Nano S is an electronic wallet for cryptocurrencies, powered
by an STM32F042 microcontroller and an ST31H320 secure element. Holding
one of the buttons at startup triggers a bootloader implemented in the
STM32F0's flash memory, speaking the APDU protocol over USB. Most of the
STM32 firmware is open source, while the ST31 runs applets inside of a
closed source supervisor.

In this chapter we'll discuss a vulnerability, first published in Roth
(2018), in which the dual mapping of flash memory allows a sanity check
to be bypassed in writing firmware, so that the bootloader will
mistakenly believe the code signature has already been validated.

We will also briefly cover a technique from Rashid (2018), in which the
device's cryptographic firmware attestation can be tricked. By replacing
compiler intrinsic functions with branches back to their bootloader
equivalents, we can hollow out some space for a patch. This allows the
STM32 to lie to the ST31 about its code, sneaking small patches past the
validation.

The Ledger Nano S divides its code between an STM32F042 and an ST31H320.
Instead of using sticker seals to protect against tampering, the device
features a case that is easy to open and software attestation. The ST31
smartcard verifies the firmware of the STM32 by reading it with strict
timing requirements.

From an attacker's perspective, a successful attack requires both
flashing new code into the STM32 chip and faking the attestation so that
the host GUI software believes the firmware to be genuine. We'll cover
tricks for both, but first let's take a brief tour of the platform so
that we know what we're working with.

::: image
[]{#ch05.xhtml_page_54
.pagebreak}![Image](images/f0054-01.jpg){#ch5fig1}

> **Description:** Photograph of a disassembled USB security key showing the internal PCB with microcontroller, flash memory chip, USB connector, and plastic housing separated. The exposed circuit board reveals the hardware components including a small button battery, passive components, and the main controller IC. The keyring attachment hole is visible on the housing, designed for physical security applications.

:::

Figure 5.1: Disassembled Ledger Nano S

::: image
[]{#ch05.xhtml_page_55
.pagebreak}![Image](images/f0055-01.jpg){#ch5fig2}

> **Description:** Memory map showing Peripheral region (0x4000 0000), SRAM (0x2000 17ff - 0x2000 0000), Flash (0x0800 7fff - 0x0800 0000), and Mirror of Flash (0x0000 7fff - 0x0000 0000). The mirrored flash region at address 0x0000 enables bootloader execution while maintaining the same code at 0x0800 base address, creating potential attack vectors through address aliasing.

:::

Figure 5.2: STM32F042 Memory Map

While the ST31 firmware is held secret, the STM32 firmware is open
source, with documentation and a development kit. To prevent malicious
patching, the host software validates the ST31's attestation of the
STM32 firmware, and to prevent malicious applications, a pin number is
required to approve applications and signing keys that might be flashed
into the unit.

Third party applications are written in C, and they run in a protected
mode of the ST31. Most examples are cryptocurrency wallet applications,
but a few games exist, such as a port of *Snake* by Parker
Hoyes.^[1](#footnotes.xhtml_ch5fn1){#ch05.xhtml_ch5fn_1}^ Applet
firmware is verified by the ST31 at installation time, and the GUI must
be invoked to run applets signed by an untrusted authority. The STM32
firmware is now verified, but it was not in early versions of the
device.

[]{#ch05.xhtml_page_56 .pagebreak}Communication with the Nano S is
performed by USB-wrapped APDU commands, and client examples are freely
provided in Python as part of the [ledgerblue]{.literal} package. An
example from that package is shown in [Figure 5.3](#ch05.xhtml_ch5fig3).

Having a full development kit, accurate source code for most of the
firmware, and legal support for third-party applications allows many
degrees of freedom to the attacker. In Saleem Rashid's example, knowing
the expected bytes of the official application allows it to be
compressed, patched, and replayed to fake out the secure element's
attestation. As we'll see in Thomas Roth's example, bugs can be found in
the bootloader after dumping it from an application in development mode.

### **Rashid's Attestation Exploit** {#ch05.xhtml_ch00lev1sec16 .h3}

In early versions of the Ledger Nano S, the STM32 firmware and its
bootloader were both open source. The host software would ask the ST31
to authenticate the STM32 firmware by quickly transferring the STM32
code over an internal UART bus.

Rashid first created a malicious firmware patch by changing the
onboarding screen so that [memset]{.literal} will be called instead of
the [cs_rng]{.literal} function when the wallet is creating a recovery
key. So the customer will always get the same key, and that key can be
externally known.

This was far from a sneaky backdoor, so he next faked out the
attestation by hiding his code inside of the application copies of
functions that also exist in the bootloader. For example,
[memset]{.literal} existed both at application address
[0x08006310]{.literal} and at boot-loader address
[0x08002a9c]{.literal}. He could free up 124 bytes by redirecting
function calls from one to the other.

::: image
[]{#ch05.xhtml_page_57
.pagebreak}![Image](images/f0057-01.jpg){#ch5fig3}

> **Description:** Python script for Ledger cryptocurrency wallet exploitation using APDU (Application Protocol Data Unit) messaging. The code creates a GET_APP_CONFIGURATION message (CLA 0xE0, INS 0x01, P1 0x00) and exchanges it with the device using ledgerblue library. The script prints storage settings, major/minor/patch versions, demonstrating information disclosure through the device's communication protocol. This reveals the application configuration interface vulnerable to unauthorized queries.

:::

Figure 5.3: Example Client Script in Python

[]{#ch05.xhtml_page_58 .pagebreak}He can then fill these bytes with a
patched wrapper for the function that sends chunks of memory to the ST31
for validation, taking care to send fake bytes to hide his hooking and
patching.

### **Roth's Bootloader Exploit** {#ch05.xhtml_ch00lev1sec17 .h3}

After Rashid's publication, Ledger closed their STM32 boot-loader's
source code and patched it to validate the application region
immediately, before booting. They left the STM32 JTAG open, however, so
Roth opened the case, wired a unit up, and dumped a copy of flash
memory. He then reverse engineered it with the aim of finding a bug that
would allow him to flash and execute unauthenticated code.

Ledger's bootloader for the Nano S operates over the APDU protocol.
Commands are described in [Figure 5.4](#ch05.xhtml_ch5fig4), where you
first use Select Segment to choose a base address, then use Load to
accept data into the working segment, and finally Flush each block back
into flash memory. When the full update is installed, you can either
call Boot or power cycle the device to execute the image.

All of that is fairly standard for a bootloader. The tricky part is that
this bootloader verifies an application image's signature, rather than
implementing a lockout. So you can call all of these commands on a
locked production device, but you shouldn't be able to execute the Boot
command or launch your image if the image hasn't been signed with the
manufacturer's production key.

By reading a dump of the bootloader, Roth learned that it places
[0xf00dbabe]{.literal} in little endian ([be ba 0d f0]{.literal}) at
[0x0800-3000]{.literal} after the signature has been validated. It
doesn't bother to repeat a validation if this tag is found. So writing
that value to that location would be enough to inject foreign,
unauthenticated code through the bootloader.

::: image
[]{#ch05.xhtml_page_59
.pagebreak}![Image](images/f0059-01.jpg){#ch5fig4}

> **Description:** Flash programming command table showing: Command 5 (Select Segment - accepts base address for flashing), Command 6 (Load - accepts two-byte offset followed by data), Command 7 (Flush - commits writes to flash), Command 8 (CRC), and Command 9 (Boot - boots the flashed code). This command sequence defines the complete flash programming workflow exposing the attack surface for firmware modification.

:::

Figure 5.4: APDU Bootloader Commands

::: image
![Image](images/f0059-02.jpg){#ch5fig5}

> **Description:** C code implementing flash write protection checks for Ledger device. The code validates destination_address against protected regions, checking for boot magic (0xF00DBABE) at 0x0800_3000 which if set will clear the magic after SECUREIS_LOAD. It prevents bootloader self-overwrite by blocking writes from 0x0800_0000 to 0x0800_3000, checks for magic address 0xF00DBABE writes, and finally calls nvm_write to non-volatile memory buffer. This reveals the protection mechanisms that must be bypassed for unauthorized firmware modification.

:::

Figure 5.5: APDU Load Handler Pseudocode from Roth (2018)

::: image
[]{#ch05.xhtml_page_60
.pagebreak}![Image](images/f0060-01.jpg){#ch5fig6}

> **Description:** Exploit command sequence showing segment selection (e000000005050000003000) followed by flashing F00DBABE magic value with entrypoint and shellcode (e0000000d3060000beba0df0c1300008f0def0e718c94fef71152094...). The final flush command (e000000001107) commits the malicious payload. This demonstrates a complete firmware implant attack using the documented flash programming interface to inject executable code with the proper boot magic.

:::

Figure 5.6: APDU Bootloader Exploit PoC

From his pseudocode of the decompiled handler in [Figure
5.5](#ch05.xhtml_ch5fig5), it might look as if you could begin a segment
just before the magic word and overwrite it, but flash writes on an
STM32 have strict page alignment rules that thwart such an attack.
Similarly, they check for writes to the forbidden page and clear four
bytes of the buffer just to frustrate us.

What makes this exploitable is that in many STM32 microcontrollers,
including this one, flash memory is mapped not just to its default
location of [0x08000000]{.literal}. There is also a second location
mirrored or ghosted at [0x00000000]{.literal}, which happens to be flash
because it defaults to the boot memory. Roth observed that while there's
an explicit check to prevent a write to [0x0800C000]{.literal}, there is
nothing preventing a write to [0x0000C000]{.literal}. Because of the
mirroring, these two addresses are the same place!

### []{#ch05.xhtml_page_61 .pagebreak}**Roth's Payload** {#ch05.xhtml_ch00lev1sec18 .h3}

A proof-of-concept exploit is shown in [Figure
5.6](#ch05.xhtml_ch5fig6). This proves the bug, but let's disassemble
his payload and see exactly what it does.

The write occurs to [0x3000]{.literal}, but we know that's a mirror for
[0x08003000]{.literal}, so let's work around that target location for
consistency. In Radare2, we would open it like this.

::: imagel
![Image](images/f0061-01.jpg)

> **Description:** GDB command showing ARM cross-compilation and examination of payload.bin starting at address 0x08003000. The command "% r2 -a arm.gnu -b 16 -m 0x08003000 -s 0x08003000 payload.bin" configures radare2 for 16-bit ARM Thumb mode disassembly, revealing the analysis setup for reverse engineering the injected firmware payload.

:::

The file begins with two 32-bit words. [0xf00dbabe]{.literal} is the
boot-loader password, and [0x080030c1]{.literal} is the reset vector at
which code is executed.

::: imagel
![Image](images/f0061-02.jpg)

> **Description:** GDB output showing memory inspection at address 0x08003000 with three words: 0xf00dbabe (boot magic), 0x080030c1 (likely stack pointer or entrypoint). The "pxw 8" command displays hexadecimal word values revealing the firmware header structure that enables bootloader execution of the payload.

:::

Remembering to drop the least significant bit, we can disassemble that
target word to find the infinite
loop.^[2](#footnotes.xhtml_ch5fn2){#ch05.xhtml_ch5fn_2}^

::: imagel
![Image](images/f0061-03.jpg)

> **Description:** GDB disassembly output at 0x080030c0 showing ARM instruction "fee7" which disassembles to "b 0x080030c0" - an infinite loop branch instruction. This represents a minimal proof-of-concept payload that demonstrates code execution capability, confirming successful firmware injection and execution control.

:::

But what's all the rest of the code? Why not just have ten bytes
([0xf00dbabe]{.literal}, [0x08003009]{.literal}, and [b
0x08003009]{.literal}) to loop forever on the first instruction? Well,
Roth seems to have included a nearly functional exploit as an Easter
egg, neutered into an infinite loop at the last minute by changing the
entry point.

[]{#ch06.xhtml}

