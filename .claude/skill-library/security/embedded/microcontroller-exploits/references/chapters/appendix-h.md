## []{#app08.xhtml_page_393 .pagebreak}**H  Unsorted Attacks** {#app08.xhtml_app08 .h2}

### **H.1 PIC16C84 PicBuster** {#app08.xhtml_app08_1 .h3}

The third chapter of McCormac (1996) describes a few firmware extraction
exploits from the early days of TV piracy. Of particular interest is a
trick against the PIC16C84, the very first PIC to include electrically
erasable EEPROM memory rather than OTP ROM or UV erasable EPROM. Like
the PICs we saw in [Chapter 19](#ch19.xhtml_ch19), a protection fuse is
implemented with the same floating gate transistor as the EEPROM bits.

The trick involves the difference between the supply voltage VDD and the
programming voltage on the !MCLR pin. In normal operation, VDD should be
less than 7.5V and !MCLR should be less than 14V, relative to ground on
VSS. This technique does not work against earlier chips, which lacked an
electrical erase feature.

To exploit the PIC16C84, the chip is electrically mass erased at the
wrong voltage. The VDD pin is held at 13.5V, just 0.5V less than VPP.
VDD is then dropped to the standard 5V and switched off for ten to
twenty seconds before being powered back on, allowing data to be read.

### []{#app08.xhtml_page_394 .pagebreak}**H.2 PIC Checksums** {#app08.xhtml_app08_2 .h3}

PIC microcontrollers implement a checksum that leaks information from
locked chips, and in some cases you can clear---but not set---bits by
performing a second programming. Kaljević (1997) documents the checksum
algorithm and a technique for zeroing coefficients of that checksum to
reveal specific bits of the source program.

On 14-bit models like the PIC16, Kaljević begins by the checksum
algorithm, ![image](images/f0394-01.jpg){.inline} where *a* is the
higher seven bits and *b* the lower seven bits of a 14-bit instruction
word. ![image](images/f0394-02.jpg){.inline} is the XNOR operator, ∽ is
inversion, and ⊕ is the XOR operator. *s* is freely readable from the
chip over the normal ICSP protocol, and the game is to reveal the
unknown bits in *a* and *b*.

Knowing *s*, he points out that overwriting the word with
[0b11-111110000000]{.literal} to zero *b* will give us
![image](images/f0394-03.jpg){.inline}, or just the inverse of *a*. It
follows that *s* = *ã* ⊕ b = *s*~1~ ⊕ *b*.

Then we can declare that *b* = (*s* ⊕ *s*~1~) & [0x7f]{.literal} and
also that ![image](images/f0394-03a.jpg){.inline} & [0x7f]{.literal}.
The fully reconstructed word from *s* and *s*~1~ is easily computed for
14-bit PICs such as the PIC16C61, 62, 64, 65, 71, 73, 74, and 84.

![image](images/f0394-03b.jpg){.inline}

For 12-bit parallel programmed chips in the PIC12 series, the checksum
algorithm is different. Here, *s* = *a* ⊕ *b* ⊕ *c* where *a* is the
upper nybble, *b* the middle nybble, and *c* the lower nybble of the
instruction word.

Instead of one write, as in the 14-bit chips, two writes are performed.
After the first write of [0x0ff0]{.literal} zeroes *c*, we see *s*~1~ =
*a* ⊕ *b*. We can then make a second write of [0x0f00]{.literal} to zero
*b*, leaving *s*~2~ = *a*. Tying it all together, for twelve bit chips
with observations of *s*, *s*~1~ and *s*~2~, our original instruction
word is revealed []{#app08.xhtml_page_395 .pagebreak}with *a* = *s*~2~,
*b* = *s*~2~ ⊕ *s*~1~, and *c* = *s*~1~ ⊕ *s*.

*w* = (*s*~2~ & [0xf00]{.literal}) + ((*s*~2~ ⊕ *s*~1~) &
[0xf0]{.literal}) + ((*s*~1~ ⊕ *s*) & [0xf]{.literal})

As for performing the writes, the paper becomes a little hard to follow.
On the PIC16C71 and 61 models, the first 64 words of memory can simply
be overwritten. *b* is zeroed and the algorithm for recovery gives those
words with no ambiguity, but the rest of memory cannot be written so
easily.

To program an already-locked chip in order to clear bits, he recommends
over-volting the chip, then if that fails, overheating it, and if even
that is not enough, also giving it a limited exposure to ultraviolet
light. The voltage trick---perhaps related to the one in [Chapter
H.1](#app08.xhtml_app08_1)---is to power the chip at between six and
nine volts while strictly limiting current to 100mA. Failing that, he
suggests holding the temperature at 110 ^°^C, being careful never to go
above 140 ^°^C.

If that is insufficient, he proposes exposing the die and calibrating
the UV light power such that it takes ten minutes to erase a PIC. Then,
at 110 ^°^C, running thirty second exposures until the protection bit
becomes set, allowing writes. [0x3f80]{.literal} is then written to
every word of memory, and the chip slowly cooled down to −20 ^°^C. At
this point, the protection bit will fall back to zero. Writes will no
longer be allowed, but the cleared bits from the writes will also be
zero. *s*~1~ can then be read out of the locked chip.

One further trick is described only in x86 assembly code to write
[0b11111111000000]{.literal}, which sets *b* to either [0x40]{.literal}
or [0x00]{.literal}. This leaves a puzzle in decoding, and some helpful
notes are given as to which of two possible instruction words would be
the right guess.

### []{#app08.xhtml_page_396 .pagebreak}**H.3 ESP32 TOCTOU for XIP** {#app08.xhtml_app08_3 .h3}

The ESP32 series from Espressif supports an execute-in-place (XiP) mode,
in which instructions are fetched directly from SPI flash without first
being copied into internal SRAM. This allows more RAM to be used by the
application, at the cost of a slower execution speed.

Code is validated and a signature checked before execution, but Magesh
(2023) describes a time-of-check to time-of-use (TOCTOU) attack against
the signature validation by swapping between two SPI flash chips at
runtime. This allows the signed code to be successfully measured before
the unsigned code is executed.

Magesh notes that this trick does not work when flash encryption (AES
XTS) is enabled, but he expects that an attacker might still exploit an
encrypted image by randomizing a single page until a needed behavior is
found, keeping all other pages intact.

### **H.4 DS5002 Chosen Ciphertext** {#app08.xhtml_app08_4 .h3}

The DS5002 from Dallas Semiconductor is an early and creative attempt at
code readout protection. Code is held encrypted in external memory, with
the key held internally in battery backed SRAM. This creates an awkward
situation for arcade game repairs, as the batteries in existing devices
will eventually die. Without an exploit, the code needed to run the game
will die with it.

This chip's instruction set is 8051. Encryption occurs one byte at a
time, independent of all other bytes but unique to that address. The
transformation is the same for both opcodes and parameters.

[]{#app08.xhtml_page_397 .pagebreak}In addition to encryption, the
DS5002 also performs dummy reads during cycles when the memory bus might
otherwise be idle. The values fetched from these addresses are not used
for anything; they only exist to confuse us.

The DS5002 is also available as a module in sealed epoxy with a battery
back-up. [Figures H.1](#app08.xhtml_chHfig1) and
[H.2](#app08.xhtml_chHfig2) show this module in surface microscopy and
X-ray.

Kuhn (1996) and Kuhn (1998) presented a cryptographic attack against the
chip, by first backing up a copy of the external SRAM and then feeding
guesses into the CPU, watching the address change in response.

For example, you might make a guess that a particular instruction is a
branch. Because the addresses are scrambled, you can't know that your
guess is right just from the next address fetched. But if you change a
parameter byte, almost every value will branch the addresses into a
different direction.

The point of the attack is to take that little piece of information,
then use it to wedge apart many bytes of chosen ciphertext with known
content, allowing us to execute arbitrary code.

You should also understand that bytes are encrypted individually and
that they don't impact later bytes. We don't quite know how a byte will
be scrambled, but for any specific address we can build up a table of
bytes. The table is a unique mapping of a cipher byte to a clear byte,
and the table does not change when the preceding byte in memory changes.
As you'll soon see, we don't much care about the address that holds each
byte. Instead, we care about forcing those bytes to known values and
building lookup tables that let us choose the right ciphertext for
specific plaintext.

Wilhelmsen and Kirkegaard (2017) presents a more modern implementation
of the same attack, and being written in a less academic style, it's
easier to follow. They describe a number of complications, with far less
math.

::: image
[]{#app08.xhtml_page_398
.pagebreak}![Image](images/f0398-01.jpg){#chHfig1}

> **Description:** Die photograph of small-scale microcontroller with clean layout. Upper left shows medium memory block, center-right displays larger memory array with regular cell structure. Lower section contains logic circuitry and control blocks. Bond pads arranged in regular pattern around die perimeter with six mounting holes visible as black circles at corners and center edges. Light colored metal routing layers overlay darker transistor regions. Compact design with clear functional separation makes this device easier to analyze for vulnerability assessment compared to complex multi-core processors.

:::

Figure H.1: Dallas DS5002

::: image
[]{#app08.xhtml_page_399
.pagebreak}![Image](images/f0399-01.jpg){#chHfig2}

> **Description:** X-ray or backside image showing two chip packages. Top: rectangular package with visible die outline and wire bonds radiating from center die to package pins. Bright white region on left side of die indicates shielding or thick metal layer. Bottom: DIP package with straight parallel leads extending from both sides. Clear wire bond pattern connects die to leadframe. Both images reveal internal structure useful for identifying die position for backside attacks, laser fault injection targeting, or electromagnetic probe placement without package removal.

:::

Figure H.2: Dallas DS5002 Module in X-ray

[]{#app08.xhtml_page_400 .pagebreak}Many 8051 instructions take a few
clock cycles to execute after being fetched. The DS5002 fetches
unrelated instructions during this time to confuse an outside observer,
making my earlier description a bit oversimplified.

Also, the interrupt table is held in internal SRAM so the attacker can't
know when interrupts have been fired. This matters a lot at reset time.

It's necessary to know when the first real instruction is fetched,
because the first observed access might be a dummy read. They do this by
attempting all 256 values at that address, and if none of those values
change the subsequent memory accesses, they then know that the byte is a
dummy and might freely be ignored. This is repeated until they've
identified the first real instruction.

Having identified the location of the first instruction byte, they next
need to produce some bytes of their own to fit there. Because the DS5002
sets Port 3 to [FF]{.literal} at reset, they can brute-force 05 b0 ([inc
p3]{.literal}) as the first two instruction bytes to flip Port 3 back to
[00]{.literal}. And I mean that they brute-force it; there are only
65,536 combinations.

At this point, they have one ciphertext/plaintext mapping of the first
two bytes but don't yet have other mappings, so they can't arbitrarily
change them. To get a mapping for the third byte, they brute-force the
first byte until they get [75]{.literal}, the opcode for [mov iram addr,
#data]{.literal}, at which point they can run [75 b0 xx]{.literal} to
write all 256 values of cleartext into Port 3. Now the third byte is
completely cracked, even though only two values are mapped for the first
byte and just one value for the second byte.

They then adjust the first byte until it becomes anything like a
[nop]{.literal} and adjust the second byte until it becomes
[75]{.literal}. Then they can scan every value of the fourth byte just
as they did the third! []{#app08.xhtml_page_401 .pagebreak}Repeating
this gives them a few bytes of shellcode that they can force into the
chip, preceded by two [nop]{.literal} bytes that don't much matter.

Finally, they insert little bits of shellcode. This one gives them the
boundary between code and data memories:

::: imagel
![Image](images/f0401-01.jpg)

> **Description:** Assembly instruction pair showing 8051 MOV operations. Line 1: "E5 C6 ; MOV A, MCON" loads MCON register value into accumulator A. Line 2: "F5 B0 ; MOV P3, A" transfers accumulator contents to Port 3. This sequence reads memory controller configuration and outputs it to I/O port, potentially exposing security state or enabling test mode through port manipulation.

:::

This one dumps the code:

::: imagel
![Image](images/f0401-02.jpg)

> **Description:** Four-line assembly sequence manipulating data pointer register. Line 1: "90 13 37 ; MOV DPTR, 0x1337" loads data pointer with address 0x1337. Line 2: "74 00 ; MOV A, 0x00" clears accumulator. Line 3: "93 ; MOVC A, @(A+DPTR)" performs code memory read from address (A+DPTR), fetching byte from 0x1337. Line 4: "F5 B0 ; MOV P3, A" outputs result to Port 3. This pattern reads specific code memory location and exposes contents via I/O port, useful for ROM extraction or verification during security analysis.

:::

And this one dumps the data:

::: imagel
![Image](images/f0401-03.jpg)

> **Description:** Three-line assembly sequence using indexed data pointer access. Line 1: "90 73 31 ; MOV DPTR, 0x7331" sets data pointer to address 0x7331. Line 2: "E0 ; MOVX A, @DPTR" performs external data memory read from 0x7331 into accumulator. Line 3: "F5 B0 ; MOV P3, A" outputs value to Port 3. This pattern reads external RAM/peripheral and exposes data via port, potentially bypassing access controls or reading protected memory regions.

:::

There are a lot of resets involved in this attack, but they report just
two minutes to brute-force the first range of instructions and just four
minutes to dump 32 kilobytes of firmware.

### **H.5 SAMA5 CMAC, SPA, Keys** {#app08.xhtml_app08_5 .h3}

Janushkevich (2020) describes three vulnerabilities in the Microchip
(née Atmel) SAMA5 series of secure microcontrollers.

This series contains a boot monitor called SAM Boot Assistance (SAM-BA)
that allows authenticated and encrypted applets to be uploaded and then
executed. These applets are often used as drivers, implementing support
for new memory devices in RAM-loadable modules to keep the bootloader
small, while relying upon cipher-based message authentication code
(CMAC) authentication to keep things secure.

[]{#app08.xhtml_page_402 .pagebreak}Note well: CMAC authentication is
often thought of as a fast alternative to public-key signatures. When
things go well, CMAC offers authentication in far less time than
public-key signatures. Unlike signatures, things can go quite poorly
because CMAC depends upon a shared secret key that either party can
leak. Think of it like a letter: if we were writing to one another with
public-key cryptography, my signature would guarantee that the letter
came from someone with a key that only I should have access to and that
only I might leak to a third-party. But if we use CMAC to authenticate
our letters, you *and* I have access to the authentication key. *Either*
of us might leak that key to a third-party.

Some chips include SAM-BA in ROM. Others have no ROM and instead link
the boot assistance monitor to flash memory. A GPIO pin configures the
bootloader entry, and SAM-BA supports both UART and USB communications
to the host computer. The standard procedure is that when the
configuration pin is low at reset or the application's reset vector is
[0xffffffff]{.literal}, the boot-loader will first attempt enumeration
over USB and then fall back to a UART console.

SAM-BA has a fancy GUI client and TCL scripting library, but for the
first bug, we'll stick to the text protocol of the UART variant.
Microchip documents loading a secure applet with the following
transactions, where [applet.cip]{.literal} is an encrypted and signed
applet binary that is 9,870 bytes in size.

::: imagel
![Image](images/f0402-01.jpg)

> **Description:** Protocol trace showing PC-to-device communication for Java Card applet loading. Four message exchanges: PC sends SAPT command (0,9870,0,01#), device acknowledges with CACK (00000000,00009870#). PC transmits applet.cip file, device confirms with CACK (00000000,00000000#). This protocol demonstrates secure element communication where timing between SAPT and file transfer could be vulnerable to man-in-the-middle attacks or where CACK responses might be spoofed to bypass authentication.

:::

During this procedure, the [SAPT]{.literal} command handler loads the
applet to [0x220000]{.literal} in SRAM, checks the CMAC authentication,
and decrypts the applet in place. The result of the authentication
[]{#app08.xhtml_page_403 .pagebreak}check is placed in a global
variable. If the CMAC were wrong, the latter [CACK]{.literal} message
would include an error code and the global variable would indicate a bad
authentication.

After the applet is loaded, the [SMBX]{.literal} command is used to load
the mailbox. [mailbox.bin]{.literal} is neither encrypted nor signed,
and it loads to the mailbox area within the application image at
[0x22-0004]{.literal}. A matching command, [RMBX]{.literal}, will
retrieve the mailbox after execution, to allow for bidirectional
communication.

::: imagel
![Image](images/f0403-01.jpg)

> **Description:** Protocol trace showing mailbox transfer operation. PC initiates with SMBX command (0,80,0,01#), device acknowledges with CACK (00000000,00000080#). PC sends mailbox.bin file containing data or commands, device confirms receipt with CACK (00000000,00000000#). This lower-level protocol suggests shared memory communication mechanism where mailbox buffer at address 0x80 could be targeted for buffer overflow attacks or malicious payload injection if bounds checking is insufficient.

:::

Now that the applet is loaded, the [EAPP]{.literal} command can be used
to execute the applet against the mailbox message. In addition to the
mailbox, [SFIL]{.literal} and [RFIL]{.literal} commands exit to send or
receive a file from the device.

::: imagel
![Image](images/f0403-02.jpg)

> **Description:** Protocol trace showing EAPP (External Application) communication. PC sends EAPP command with all zero parameters (0,0,0,00#), device responds with ASTA status message (00000000,00000000#). This minimal exchange suggests application state query or reset operation. The zero response could indicate idle state, successful completion, or error condition requiring additional context to interpret. Protocol simplicity suggests potential for command injection or state confusion attacks through unexpected EAPP parameter combinations.

:::

Now that we've covered the basics of the tutorial, let's peek at the
first exploitable bug. Janushkevich first notes that the
[RMBX]{.literal} command allows the mailbox to be retrieved even when it
has not been loaded. Because the mailbox and the applet overlap, this
allows him to read back part of the applet from memory.

He then tried first a signed, encrypted applet and an unsigned,
unencrypted applet. [RMBX]{.literal} returned pieces of the first applet
in cleartext, showing that it was decrypted to memory before being
executed. The unsigned applet also had pieces returned from the mailbox
without corruption, implying that when CMAC validation fails, the
unvalidated message remains in memory without being scrambled by
decryption.

[]{#app08.xhtml_page_404 .pagebreak}Finally, he tried executing the
applet with [EAPP]{.literal}, [SFIL]{.literal}, and [RFIL]{.literal}.
All three---I shit you not---executed the unencrypted, unsigned applet
without complaint. It seems that the [SAPT]{.literal} command records
that the authentication failed, but the commands that execute the applet
do not bother to check that variable. This is tracked as CVE-2020-12787.

As a second attack, he attached a ChipWhisperer to a modified
SAMA5D2-XULT dev kit to take a look at the power consumption when that
chip performs CMAC authentication. By identifying a point in time when
power traces wildly diverge based upon a carry-in subtraction of a
provided CMAC word from the computed word, he is able to leak bits of
the correct CMAC of the message, starting from the most significant bit
and working his way down to the least. In 1,300 power measurements or
twenty minutes, this lets him forge a CMAC authentication for
bootstrapping an image, loading a SAM-BA applet, or installing a key.
This is tracked as CVE-2020-12788.

His third attack against this series is simple but brutal: the CMAC keys
used by this bootloader are hardcoded and can be dumped by an applet
using the vulnerabilities we've already discussed. These keys were
verified by decrypting published applets, allowing for their reverse
engineering and, perhaps someday, their exploitation. CVE-2020-12789.

[]{#app09.xhtml}

