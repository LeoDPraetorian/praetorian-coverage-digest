## []{#ch17.xhtml_page_161 .pagebreak}**17  STM32 FPB Glitch** {#ch17.xhtml_ch17 .h2a}

There are many brilliant attacks to be found in Obermaier, Schink, and
Moczek (2020), but my favorite is an escape from RDP Level 1 of the
STM32F103 and also one of its clones, the APM32F103 from Geehy. This one
involves a lot of moving parts, so gather 'round and pay attention!

First, recall from [Chapter 2](#ch02.xhtml_ch02) that RDP Level 1
disables flash memory when a JTAG debugger is attached, but that the
connection is allowed and all SRAM is available to the debugger.
Resetting the chip will disconnect the debugger and reconnect flash
memory, but it does not erase SRAM.

Second, the STM32 chips can boot from SRAM, ROM, or flash memory
depending upon the values sampled on the BOOT0 and BOOT1 pins at
startup. Flash has full access to memory, and ROM contains a bootloader
with its own software implementation of the access restrictions, but
when booting from SRAM, the code has the same restrictions as when JTAG
is attached. Namely, flash memory is inaccessible. This restriction
applies when booting from SRAM, but not when executing SRAM after
booting from ROM or flash memory.

As it's sometimes desirable to make small patches to flash memory
without rewriting the memory, the STM32's Cortex M3 core supports a
flash patch and breakpoint unit (FPB). This unit is also handy when
making changes to mask ROM, which can be patched even though it, of
course, cannot be rewritten in place. [Figure
17.2](#ch17.xhtml_ch17fig2) shows the registers of this unit, and note
that the pointers begin with [E]{.literal}, so this peripheral comes
from the Cortex M3 core and is not unique to the STM32.

::: image
[]{#ch17.xhtml_page_162
.pagebreak}![Image](images/f0162-01.jpg){#ch17fig1}

> **Description:** Memory map diagram showing address space organization from 0x0800 0000 to 0xE010 0000. The regions include Flash (0x0800 0000 to 0x080f ffff), ROM + OTP (0x1fff 0000 to 0x1fff 7a0f), Option Bytes (0x1fff c000 to 0x1fff ffff), SRAM (0x2000 0000 to 0x2001 ffff), Peripherals (0x4000 0000 to 0x5fff ffff), and Private Peripherals (0xE000 0000 to 0xE010 0000). Each region is separated by ellipses indicating address gaps.

:::

Figure 17.1: Simplified STM32F103 Memory Map

::: image
[]{#ch17.xhtml_page_163
.pagebreak}![Image](images/f0163-01.jpg){#ch17fig2}

> **Description:** Register address table listing FlashPatch and identification registers. FlashPatch registers occupy addresses 0xE0002000-0xE0002024, including FP_CTRL (Control), FP_REMAP (Remap), and eight comparator registers FP_COMP0 through FP_COMP7. Peripheral Identification registers (PID4-PID7, PID0-PID3) span 0xE0002FD0-0xE0002FEC. Component Identification registers (CID0-CID3) occupy 0xE0002FF0-0xE0002FFC. These registers enable hardware breakpoints, memory remapping, and device identification for ARM Cortex-M debug capabilities.

:::

Figure 17.2: Cortex M3 Flash Patch and Breakpoint (FPB) Unit

[]{#ch17.xhtml_page_164 .pagebreak}So Obermaier wrote a bit of two-stage
shellcode that is loaded as a bootable image into SRAM. The first stage
can't read flash memory because of the access restrictions, but it can
reconfigure the FPB device to patch the Reset vector at
[0x00000004]{.literal} to point to the second stage. The boot pins are
then changed to select flash memory as the boot source, and a supply
voltage glitch is timed with a reset as a trigger.

The reset restores access to flash memory, and if the glitch succeeds at
the right moment, the FPB's patch of the Reset vector is not cleared by
the reset sequence. This causes execution to return immediately to the
second stage of the shellcode in SRAM. This stage can then freely export
all the contents of memory.

In terms of portability, I've already pointed out that the FPB unit
comes from ARM and not from ST Micro. This same unit is used in other
exploits in this book, found in [Chapters C.4](#app03.xhtml_app03_4) and
[C.5](#app03.xhtml_app03_5).

::: image
[]{#ch17.xhtml_page_165
.pagebreak}![Image](images/f0165-01.jpg){#ch17fig3}

> **Description:** Die photo of a large flash memory chip with massive memory array dominating most of the die area. The upper portion shows dense control logic and address decoding circuitry. A vertical stripe structure runs down the center, likely representing sense amplifiers or column decoders. The left side contains peripheral circuits and interfaces. Bond pads line all edges of the die. The regular, repeating cell structure indicates high-density flash memory organized in banks or sectors.

:::

Figure 17.3: Geehy APM32F103, an STM32 Clone[]{#ch17.xhtml_page_166
.pagebreak}

[]{#ch18.xhtml}

