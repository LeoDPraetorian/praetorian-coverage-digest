## []{#ch13.xhtml_page_131 .pagebreak}**13  Basics of Glitching** {#ch13.xhtml_ch13 .h2a}

Dear reader, please indulge me in a little mythology. After that, we'll
move on to modern clock and voltage glitching attacks.

Way back in the good old days, so the story says, a satellite TV smart
card was vulnerable to memory corruption. The people did rejoice, as a
memory corruption exploit was sufficient to unlock all of the channels
and extract all of the card's memory. Then from the heavens came a
message---an EEPROM update, rather than a prophecy---and the cards were
patched to spin in an infinite loop rather than decode Captain Picard's
latest fight with the Borg. The exact patch and the exact card are lost
to time, but in C we might say the code looked something like the
following.

::: imagel
![Image](images/f0131-01.jpg)

> **Description:** C code showing an entry point function that checks a lockbyte stored in EEPROM. The function declares an int variable "looped" initialized with EEPROM[lockbyte]. A while loop continues as long as looped is non-zero. Once the lockbyte is cleared (set to 0), execution proceeds to main(). This implements a simple boot lock mechanism where firmware execution is blocked until the lockbyte is cleared.

:::

Because the card spins in an infinite loop rather than doing its job,
pirates called it "looped." From this they invented "unlooping," the
technique of messing with the card's voltage or clock to jump out of the
infinite loop. Today we call these techniques "fault injection" or
"glitching," and they are still brutally effective at removing
protections from chips.

The trick is to very briefly drop the voltage supply to the chip, or to
introduce a very brief additional cycle to the clock supply line. Like
running the chip too fast or on too little power, this causes
instructions to be mis-executed. But because the violation
[]{#ch13.xhtml_page_132 .pagebreak}is so brief, as little as one
instruction will be corrupted while everything else remains fine.

In our example, the smart card will spin forever executing the
[while]{.literal} loop on line 3. Optimizations and assembly languages
will express it differently, but imagine it becomes the following
pseudo-assembly.

::: imagel
![Image](images/f0132-01.jpg)

> **Description:** Assembly code implementing lockbyte check loop. The code compares the address of looped variable with 0 to check if the lockbyte is zero. If not equal (jmpeq loop), it loops back. When the lockbyte becomes zero, execution continues to allgood label which calls the main function. This provides a simple software-based security mechanism that can be bypassed by overwriting the lockbyte in EEPROM.

:::

When the device is looped, the microcontroller will execute lines 2 and
3 in sequence forever. If we shorten the clock so that the jump-if-equal
instruction on line 3 does not write over the program counter, execution
will continue on line 5, calling the main method as if this chip weren't
locked. Because the loop runs continuously, the chip is helpfully giving
us many tries before each reboot.

Another good target is a copy loop. At startup, a smart card often
presents its Answer To Reset (ATR) string. If the [for]{.literal} loop
that sends the string is like this, we might leak extra bytes of memory
out of the card by glitching as [i]{.literal} is compared to
[16]{.literal} after the last byte. When the comparison is exact (*i* ≠
16) instead of a range (*i \<* 16), this might dump a lot of extra
memory!

::: imagel
![Image](images/f0132-02.jpg)

> **Description:** C code showing a minimal main function with a for loop that iterates 16 times (i=0 to i!=16, i++). Inside the loop, it calls txbyte() function with ATR[i] as argument. This code transmits 16 bytes of ATR (Answer To Reset) data, which is a standard smart card communication protocol sequence used to identify the card type and capabilities to the reader.

:::

In the early 2000s, unlooper hardware was commercially sold to hobbyists
and schematics for home designs were passed around on forums. Most
consisted of an Atmel AT90 microcontroller with 7400 series chips to
insert glitches on the clock and data lines against the DirecTV HU
Card.^[1](#footnotes.xhtml_ch13fn1){#ch13.xhtml_ch13fn_1}^ See [Figure
13.1](#ch13.xhtml_ch13fig1) for an example, and search eBay for "Mikobu"
if you'd prefer to purchase one already made.

::: image
[]{#ch13.xhtml_page_133
.pagebreak}![Image](images/f0133-01.jpg){#ch13fig1}

> **Description:** Complex electronic circuit schematic centered around an AT90S2313P microcontroller (IC1). The circuit includes a T009HP transformer for power supply, voltage regulators (IC3A providing ±12V), RS-232 level shifters (IC2C, IC2B using 1N4148 diodes), and a card socket interface. The design incorporates multiple IC gates (IC4A-IC4D, IC2A-IC2E), supporting components (resistors, capacitors), and connections for FLOPPY-4 interface, VCC power rails, and ground. A 13.56 MHz crystal oscillator circuit is visible in the upper right corner.

:::

Figure 13.1: Smart Card Unlooper from PLC77 (2001)

[]{#ch13.xhtml_page_134 .pagebreak}As far as software goes, most of
these unlooper designs require firmware to be loaded into the AT90
through the MAX232 chip over a serial port. While many glitching
programs were shared as source code or black box binaries, there was
also a tradition of sharing them as commented VBScript for a program
called WinExplorer.

### **Clock Glitching** {#ch13.xhtml_ch00lev1sec45 .h3}

When a microcontroller is designed, there's a matter of timing closure.
For any given chip, there is some maximum clock rate, beneath which the
design behaves as specified. Beneath this speed, all of the
combinational logic gets the right result in time to be latched by the
sequential logic.

Above this rate, things fail, but not all at once. Maybe multiplication
is the bottleneck of the clock rate, and exceeding that rate by a little
bit causes some multiplications to fail while everything else works
fine. If you never need multiplication, you might exceed this clock rate
to get more performance in other functions.

When a chip takes its raw clock input from an external pin, and it
doesn't smooth that clock out with a phase-locked loop, we have the
opportunity to perform some clock glitching. We do this by inserting a
short clock pulse, one single edge or cycle that is far above the
maximum rate of the chip.

[]{#ch13.xhtml_page_135 .pagebreak}In a multi-cycle design, this can be
thought of as one piece of one instruction being given time to finish.
Maybe the wrong opcode is latched in the first cycle of the instruction,
or maybe a jump never writes back to the program counter at the end of
the instruction.

I usually begin with a range of time in which the firmware makes an
important decision, then attempt to fault random points in that range
until I get the chip to misbehave. Because we control the clock itself,
this timing can be extremely accurate and reliable.

### **Voltage Glitching** {#ch13.xhtml_ch00lev1sec46 .h3}

When the raw clock input isn't available, voltage glitching might still
be an option. The idea is to abruptly shift the voltage, raising or
lowering it for such a brief moment that the chip does not crash but it
also doesn't execute its instruction properly.

Dropping the voltage has many effects. One is that the transistors flip
more slowly, so that a device might be well within its timing closure is
suddenly unable to calculate its results in time, somewhat like clock
glitching. An Atmega328P, for example, safely runs at 20MHz at 4.5V only
10MHz at 2.7V. Other effects include failures in memories and mistaken
instruction decoding.

Calibration of a voltage glitch can be tricky. The first axis will be
the time offset from an observable trigger, like a pin rising high. The
duration of change and the target voltage will be two more axes, and
clock drift will make things less reliable the longer we wait after the
trigger for the glitch to occur.

To keep things simple, many modern glitching attacks simply short
circuit the core voltage to ground and rely on very short
[]{#ch13.xhtml_page_136 .pagebreak}timing to prevent a
crash.^[2](#footnotes.xhtml_ch13fn2){#ch13.xhtml_ch13fn_2}^

However you arrange things, it's important to calibrate your glitching
on one axis at a time. I do this on a development board with the same
chip as my target, first running a tight [while]{.literal} loop that
adds up a bunch of numbers and prints a warning when they disagree. I
can then search for a duration and voltage that make the warnings
appear, without yet worrying about when to apply the glitch. I remove
most of the decoupling capacitors, then add them back individually if
things become too unstable.

Only after successfully injecting faults in this easy target do I bother
switching over to my real target. It's there that my trigger and offset
matter, and it's best that the other parameters already be dialed in.

[]{#ch14.xhtml}

