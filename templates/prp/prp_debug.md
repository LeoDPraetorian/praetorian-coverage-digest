name: "Debug PRP Template v1"
description: |

---

## Bug Description

**Jira Ticket**: [link to Jira ticket]

**Bug Description**: [1-2 sentence summary of the bug]

## User Persona (if applicable)

**Target User**: [Specific user type - developer, end user, admin, etc.]

**Use Case**: [Primary feature that this bug disrupts]

**User Journey**: [Step-by-step flow of how user fails to use the feature because of this bug]

**Pain Points Addressed**: [Specific user frustrations this bug creates]

## Why

- [Business value and user impact]
- [Integration with existing features]
- [Problems this causes and for whom]

## What

[Extended description of the bug]

[Extended description of your plan to diagnose the bug]

### Diagnostics

- [ ] [Specific steps to investigate the bug]
- [ ] [e.g., Use playwright-explorer agent to perform X, Y, and then Z.]
- [ ] [e.g., Use praetorian-cli-expert to retrieve the .x field of the 'abc' asset]
- [ ] [e.g., Use codebase-explorer to identify relevant code snippets]

## All Needed Context

### Context Completeness Check

_Before writing this PRP, validate: "If someone knew nothing about this codebase, would they have everything needed to debug this successfully?"_

### Documentation & References

```yaml
# MUST READ - Include these in your context window
- url: [Complete URL with section anchor]
  why: [Specific methods/concepts needed to understand the bug or the flawed implementation]
  critical: [Key insights that prevent common implementation errors]

- file: [exact/path/to/pattern/file.py]
  why: [Relevant code snippet; handles the foobar processing]
  pattern: [Brief description of what pattern causes the bug]
  gotcha: [Known pitfall or limitation related to the bug]

- docfile: [PRPs/ai_docs/domain_specific.md]
  why: [Custom documentation for complex library/integration patterns]
  section: [Specific section if document is large]
```

### Relevant Codebase tree (run `tree` in the root of the project) to get an overview of the codebase. List the relevant files here

```bash

```

### Diagnostic Tasks (ordered by dependencies)

Example:
```yaml
Task 1: REPLICATE BUG WITH PLAYWRIGHT
  - DIRECT: playwright-explorer agent to perform the steps reported in the Jira ticket
  - RETRIEVE: backend request(s) generated by the steps, including the POST body
  - ANALYZE: whether the request(s) make sense given the intention of the user
  - SHARE: share these findings with other subagents

Task 2: FETCH ASSOCIATED DATA WITH PRAETORIAN CLI
  - DIRECT: praetorian-cli-expert agent to fetch a specific asset from the backend
  - ANALYZE: whether the backend data includes fields missing from the frontend
  - CONCLUDE: if the data is missing because the frontend loses it or the backend never returns it

Task 3: ANALYZE CODE BASE
  - DIRECT: codebase-explorer agent to search for code snippets relevant to your bug
  - ANALYZE: attempt to identify flaws in the code that would cause the bug.

TASK 4: SYNTHESIZE
  - DEPENDENCIES: output from tasks 1, 2, and 3
  - SYNTHENSIZE: data collected from subagents to comprehensively state whether or not there is a bug, and if so, what is causing it
```

### Implementation Patterns & Key Details

1. Keep your instructions to subagents high-level. Subagents will have the technical expertise needed to solve your specific problem.

2. Rely on subagents to solve specific problems. You should perform very few direct tool invocations yourself.
