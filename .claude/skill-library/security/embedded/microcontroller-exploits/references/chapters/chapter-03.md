## []{#ch03.xhtml_page_25 .pagebreak}**3 MD380 Null Pointer, DFU** {#ch03.xhtml_ch03 .h2}

While it's brutally effective to exploit a chip vendor's bootloader in
ROM, many device vendors add a second bootloader in flash memory. This
is the story, first told in Goodspeed (2016b), of how I dumped a two-way
radio's firmware through a null pointer read vulnerability. It is also
the story of how the firmware update cryptography was broken, from
Rütten and Goodspeed (2016).

The Tytera MD380 is a handheld radio transceiver that uses either analog
FM or Digital Mobile Radio (DMR). DMR provides some of the features of
GSM, such as text messaging and timesharing of the repeater tower,
without the hassles of SIM cards. Many people purchased the MD380 for
use in amateur radio; it was just too tempting to rip out its firmware
and patch in new features for the ham radio community.

The CPU of this radio is an STM32F405 in the LQFP100 package, with a
megabyte of flash and 192kB of
RAM.^[1](#footnotes.xhtml_ch3fn1){#ch03.xhtml_ch3fn_1}^ The STM32 has
both JTAG and a ROM bootloader, but these are protected by the readout
device protection (RDP) feature in its most secured setting, where JTAG
connections are entirely disallowed.

### **Reading a Null Pointer** {#ch03.xhtml_ch00lev1sec8 .h3}

Instead of jumping in with the STM32 vulnerability presented in [Chapter
2](#ch02.xhtml_ch02), I began by writing some of my own USB drivers for
the radio. As we'll soon see, this was not a waste of time.

::: image
[]{#ch03.xhtml_page_26
.pagebreak}![Image](images/f0026-01.jpg){#ch3fig1}

> **Description:** Illustration of a handheld radio transceiver with external antenna and programming cable attachment. The device features a display screen, numeric keypad (0-9), function buttons, speaker grille, and control knobs. The programming cable connects to the side port, representing a common attack vector for accessing firmware and configuration data on embedded communication devices.

:::

Figure 3.1: Tytera MD380 Radio

::: image
[]{#ch03.xhtml_page_27
.pagebreak}![Image](images/f0027-01.jpg){#ch3fig2}

> **Description:** Die photograph of a microcontroller with enhanced visibility showing the complete silicon layout. Large memory arrays with regular striped patterns dominate the right two-thirds of the die, while logic blocks, control circuitry, and peripheral interfaces occupy the lower left region. Bond pads line all four edges for external connections. The organized memory structures contrast with the irregular logic regions, revealing the physical architecture vulnerable to side-channel attacks and fault injection.

:::

Figure 3.2: STM32F405

[]{#ch03.xhtml_page_28 .pagebreak}The MD380 has *three* separate
implementations of the USB device firmware update (DFU) protocol: one in
ROM, a second at the beginning of flash that is used for firmware
updates and recovery, and a third in the main radio application. The
second and third speak largely the same protocol, and we can exploit
either of them in roughly the same way.

I reverse engineered the protocol by running the vendor's Windows
application under VMWare, then patching the [.vmx]{.literal} file with
the lines in [Figure 3.4](#ch03.xhtml_ch3fig4) to write USB traffic to a
log file. These days, I'd probably use [usbmon]{.literal} on a Linux
host while running Windows in a Qemu VM.

The logs showed that the MD380's variant of DFU included non-standard
commands. In particular, the LCD screen would say "PC Program USB Mode"
for the official client applications, but not for any third-party
application. Before I could do a proper read, I had to find the commands
that would enter this programming mode.

DFU implementations often hide extra commands in the [UPLOAD]{.literal}
and [DNLOAD]{.literal} commands, when the block address is less than
two. To erase a block, a DFU host downloads [0x41]{.literal} followed by
a little endian address to block zero. To mass erase all of memory, the
host sends just [0x41]{.literal} with no extra bytes to block zero. To
set the address pointer, the host sends [0x21]{.literal} followed by a
little endian address. See [Figure 2.4](#ch02.xhtml_ch2fig4) for a list
of the STM32's standard extensions that are called in this manner.

In addition to those documented commands, the MD380 also uses a number
of two-byte (rather than five-byte) [DNLOAD]{.literal} transactions,
none of which exist in the standard DFU protocol. I observed the
commands in [Figure 3.5](#ch03.xhtml_ch3fig5), many of which I still
only partly understand.

It wasn't hard to patch the open source DFU client from Michael
Ossmann's Ubertooth project to read and write the radio's configuration.
This configuration, called a "codeplug" by radio users, is held in SPI
flash and does not include any firmware. Instead, it holds radio channel
settings and frequencies.

::: image
[]{#ch03.xhtml_page_29
.pagebreak}![Image](images/f0029-01.jpg){#ch3fig3}

> **Description:** Memory map diagram identical to f0017-01.jpg, showing microcontroller address space: Peripherals (0x5fff ffff - 0x4000 0000), SRAM (0x2001 ffff - 0x2000 0000), Option Bytes (0x1fff c000), ROM + OTP (0x1fff 7a0f - 0x1fff 0000), Flash (0x080f ffff - 0x0800 0000), and Boot Memory Alias (0x000f ffff - 0x0000 0000). Critical boundaries between executable and writable regions provide attack surfaces.

:::

Figure 3.3: Simplified STM32F405 Memory Map

::: image
![Image](images/f0029-02.jpg){#ch3fig4}

> **Description:** Configuration file snippet showing GoodFET settings: monitor="debug", usb.analyzer.enable=TRUE, usb.analyzer.maxLine=8192, and mouse.vusb.enable=FALSE. This configuration enables USB protocol analysis with 8192-byte line buffer for capturing and debugging USB traffic during hardware exploitation, particularly useful for reverse engineering USB device communication.

:::

Figure 3.4: USB Sniffing with VMWare

::: image
[]{#ch03.xhtml_page_30
.pagebreak}![Image](images/f0029-02a.jpg){#ch3fig5}

> **Description:** Command protocol table for radio programming interface showing hex commands: 91 01 (Enables programming mode on LCD), a2 01 (Returns model number), a2 02/31/03/04/07 (Config read/firmware update operations), 91 31 (Firmware update only), and 91 05 (Reboots, exiting programming mode). These commands expose the control protocol for firmware manipulation and device configuration attacks.

:::

Figure 3.5: DNLOAD Extensions for the MD380

::: image
![Image](images/f0030-01.jpg){#ch3fig6}

> **Description:** Terminal output from dfu-util showing DFU firmware upload to device 0483:df11. The session displays DFU interface claiming, alternate setting selection, device state determination (dfuUPLOAD-IDLE), transfer abortion, and successful upload of 2097152 bytes with 1024 bytes per hash. The hexdump reveals firmware binary content starting at 0x08000000, showing the actual flash memory contents being extracted, useful for reverse engineering and firmware analysis.

:::

Figure 3.6: Dumping Flash Memory

::: image
[]{#ch03.xhtml_page_31
.pagebreak}![Image](images/f0031-01.jpg){#ch3fig7}

> **Description:** ARM Cortex vector table showing critical memory addresses: 0x20001a30 (Top of Call Stack), 0x08005615 (Reset Handler), 0x08005429 (Non-Maskable Interrupt), 0x0800542b (Hard Fault), 0x0800542d (MMU Fault), 0x0800542f (Bus Fault), and 0x08005431 (Usage Fault). These interrupt vectors represent key attack targets for exploitation, particularly the fault handlers which can be hijacked to gain control during error conditions.

:::

Figure 3.7: Interrupt Table from the MD380

If none of the extended commands from [Figure 3.5](#ch03.xhtml_ch3fig5)
are sent before a read, a very interesting pattern would be read out,
shown in [Figure 3.7](#ch03.xhtml_ch3fig7). You can think of this as
simply not selecting a memory source.

Interpreted as little-endian, this begins with the words
[0x2000-1a30]{.literal}, [0x08005615]{.literal}, [0x08005429]{.literal},
and a bunch of other odd pointers to addresses in the STM32's flash
memory. This is the interrupt table at the beginning of flash memory,
and I was seeing the first kilobyte of the flash bootloader at
[0x08000000]{.literal}!

What was happening internally? Well, each DFU transaction would attempt
to read a block from memory, but because the custom commands hadn't been
sent to choose a source, the non-existent buffer was never populated.
And what does a nonexistent buffer at an uninitialized location happen
to contain on an STM32F4? Well, [0x00000000]{.literal} helpfully mirrors
whichever memory the chip was booted from, so reading a kilobyte from
[]{#ch03.xhtml_page_32 .pagebreak}there instead gives a kilobyte from
[0x08000000]{.literal}, and that's why we get the first kilobyte of the
bootloader.

Reading past the first block, we find that every block has the same
kilobyte. This is because DFU is addressed in terms of block numbers,
but the buffer remains uninitialized, so that all block addresses get
rerouted to the very beginning of flash. Though it's useless to change
the block index, we can grab more than a kilobyte by increasing the
block size with the [\--transfer-size]{.literal} option of
[dfu-util]{.literal}. The maximum transfer size varies by operating
system and USB controller, but my iMac was able to pull out
[0xC000]{.literal} bytes, the full length of the recovery bootloader!

### **Patching Out Protections** {#ch03.xhtml_ch00lev1sec9 .h3}

So now we have the recovery bootloader, but we don't have the
application that follows it in memory at [0x0800C000]{.literal}. We'll
get that code by patching the recovery bootloader to disable the readout
protection, and then use the STM32's ROM bootloader to dump all memory
over USB.

To load the image into a reverse engineering tool, such as IDA Pro or
Ghidra, simply set an instruction set of ARM/Cortex and a base address
of [0x08000000]{.literal}. It sometimes helps the decompiler to mark the
image as having no write permissions, so that it knows that the code
will not be self-modifying. It's also important to mark the I/O region
at [0x40000000]{.literal} as volatile, to prevent the decompiler from
optimizing away the majority of your interrupt handler code.

Searching for the IO address [OPTCR_BYTE1_ADDRESS]{.literal}
([0x4002-3C15]{.literal}), we quickly find that
[FLASH_OB_RDPConfig()]{.literal} from the STM32 examples is included at
[0x08001fb0]{.literal}. It is called from [main()]{.literal} with a
parameter of [0x55]{.literal} in the instruction at
[0x0800-44A8]{.literal}.

::: image
[]{#ch03.xhtml_page_33
.pagebreak}![Image](images/f0033-01.jpg){#ch3fig8}

> **Description:** C code for setting flash read protection levels showing FLASH_OB_RDPConfig function. The code documents three protection levels: AA (No protection), 55 (Read protect memory), CC (Full chip protection). A critical warning states that enabling OB_RDP level 2 makes it impossible to return to level 1 or 0, creating a permanent lockdown condition. The function writes protection settings to OPTCR_BYTE1_ADDRESS. Below is a decompiled rdp_lock function showing the same operation checking for '\b' character before writing the protection parameter.

:::

Figure 3.8: This function sets the RDP protection level.

::: image
[]{#ch03.xhtml_page_34
.pagebreak}![Image](images/f0034-01.jpg){#ch3fig9}

> **Description:** Photograph of a mobile device PCB showing multiple integrated circuits, including a large central processor with extensive pin connections, surrounding support chips, passive components, and a white connector interface. The board layout reveals typical smartphone architecture with power management, memory, and peripheral controller ICs. Access points for hardware debugging and potential attack vectors are visible through exposed test pads and component connections.

:::

Figure 3.9: Tapping the BOOT0 Pin

[]{#ch03.xhtml_page_35 .pagebreak}We can then patch a single byte so
that instead of writing [0x55]{.literal} for RDP Level 1 with Read
Protection, the bootloader will write [0xAA]{.literal} for RDP Level 0
with No Protection.

::: imagel
![Image](images/f0035-01.jpg)

> **Description:** ARM assembly disassembly showing bootloader jailbreak instructions. The code at 0x080044a8 loads r0 with 0x55 instead of the original value, enabling bypass of read protection by calling rdp_lock, rdp_applylock, and bootloader_pin_test functions. The comment "Change this immediate from 0x55 to 0xAA to jailbreak the bootloader" indicates a single-byte modification attack vector for defeating security protections.

:::

So now we have a bootloader that will not lock the chip, but it is still
necessary to install it. We do this by holding the CPU's
[BOOT0]{.literal} pin high during a reboot, with the hardware modified
as shown in [Figure 3.9](#ch03.xhtml_ch3fig9), to start the ROM
bootloader. At this point we are still in RDP Level 1 (Read Protection),
but we can drop to Level 0 by sending the Mass Erase command, wiping
everything in flash memory and leaving the radio without firmware.

We then write our patched bootloader into flash memory, and reboot the
radio while holding the top and bottom buttons on the right side of the
radio to start it. The LED will begin blinking red and green. At this
stage, the device is ready to accept an update, but as yet has no
application image, so we use the vendor's Windows application to install
an encrypted firmware update. This gives us a working radio!

We reboot again into the ROM bootloader from [Chapter
2](#ch02.xhtml_ch02) by holding the [BOOT0]{.literal} pin high on a
reset. This time, we are in RDP Level 0 (No Protection), and we can
freely dump all flash memory, where the radio firmware begins at
[0x0800C000]{.literal}. Because the device remains unlocked, we can also
patch the application image and write that back into the radio.

::: image
[]{#ch03.xhtml_page_36
.pagebreak}![Image](images/f0036-01.jpg){#ch3fig10}

> **Description:** C code implementing decrypt_and_writeblock function at address 0x08004fa5. The function performs XOR decryption on a kilobyte buffer using a firmware key, fills unspecified bytes with 0xFF padding, then writes words to Flash memory using flash_writeword. This reveals the encryption mechanism protecting firmware updates and the attack surface for injecting malicious code through buffer manipulation or key recovery.

:::

Figure 3.10: Decompiled Decryption Function

### []{#ch03.xhtml_page_37 .pagebreak}**Cracking the Update Cryptography** {#ch03.xhtml_ch00lev1sec10 .h3}

By this point, we have cleartext dumps of both the recovery bootloader
and the application, as well as an encrypted firmware update of the
application. All that's left to do is to break the encryption, and
that's exactly the trick that my good friend Christiane Rütten
contributed in Rütten and Goodspeed (2016).

Different forms of cryptography require different techniques, of course.
If the vendor had been signing updates with public-key crypto, we might
be out of luck. If a standard symmetric crypto algorithm such as AES
were used, we might have luck searching for constant tables, then
tracing references back until we found the code that decrypted the
firmware.

Instead, Rütten noticed that there were repeating sequences within the
encrypted firmware update, something that oughtn't happen if the
encryption were done right. She then took the encrypted firmware update
and XORed it with the cleartext application that I had dumped from
memory.

Lo and behold, XORing the cleartext with the update file produced a
repeating pattern of 1,024 bytes! See [page 38](#ch03.xhtml_page_38) for
Python code that uses these bytes to wrap a firmware blob into an
encrypted update, compatible with the manufacturer's own tools.

The firmware function that performs this XOR is shown in [Figure
3.10](#ch03.xhtml_ch3fig10). Note that 1,024 bytes are XORed with bytes
of [firmwarekey]{.literal} regardless of the block size being written,
but that the amount being copied is taken as a parameter.

These exploits made possible the MD380Tools project, an open source
collection of patches against the MD380 firmware that added promiscuous
mode, a phone book of all registered amateur DMR operators, and raw
packet capture.^[2](#footnotes.xhtml_ch3fn2){#ch03.xhtml_ch3fn_2}^ It
also made possible Goodspeed (2016a), in which I re-linked the firmware
into an ARM/Linux executable for freely encoding and decoding DMR's
AMBE+2 audio codec on a desktop or server.

::: imagel
[]{#ch03.xhtml_page_38 .pagebreak}![Image](images/f0038-01.jpg)

> **Description:** Python code showing MD380 OEM firmware update structure with extensive hexadecimal key data spanning multiple lines. The class MD380FW initializes with base_address=0x800c000, magic identifier "OutSecurityBin", jst="JST51", and complex foo/bar byte sequences. The structure reveals firmware packaging format including header/footer formats and encryption keys used in the update process, exposing the cryptographic implementation for potential attacks.

:::

::: imagel
[]{#ch03.xhtml_page_39
.pagebreak}![Image](images/f0039-01.jpg)

> **Description:** Continuation of Python firmware wrapping code showing the wrap method implementation using struct packing. The code assembles header from header_fmt template, footer from footer_fmt, encrypts the application data, and packs components with magic, jst identifier, foo/bar sequences, and application length. The bin construction with padding ('\xff' * 240) reveals the complete firmware package structure vulnerable to format manipulation attacks.
[]{#ch03.xhtml_page_40
.pagebreak}
:::

[]{#ch04.xhtml}

