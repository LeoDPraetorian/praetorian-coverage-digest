## []{#ch06.xhtml_page_63 .pagebreak}**6â€‚NipPEr Is a buTt liCkeR** {#ch06.xhtml_ch06 .h2}

In this chapter, we'll discuss a buffer overflow vulnerability in a Dish
Network smart-card, which was the subject of the famous lawsuit between
EchoStar and NDS. The first public explanation of this bug was a short
forum post, NipperClauz (2000), but thanks to the trial, we have far
more detailed documentation in the form of a secret NDS internal tech
report, Mordinson (1998).

First, let's set the stage. This smart-card was used in North America
for Dish Network's satellite TV service, where it would calculate a
short-lived decryption key for the receiver. The chip inside is an
ST16CF54 chip from ST Microelectronics, then known as SGS Thomson. The
instruction set is mostly compatible with Motorola 6805, except for the
additional instructions TSA ([0x9E]{.literal}) and MUL
([0x42]{.literal}). The chip contains 16kB of user ROM, 8kB of system
ROM, 4kB of EEPROM/OTP, and 480 bytes of SRAM. The user ROM was
developed by Nagra while the system ROM was developed by SGS Thomson.

[Figure 6.1](#ch06.xhtml_ch6fig1) shows the memory layout of the chip,
and [Figure 6.2](#ch06.xhtml_ch6fig2) the EEPROM layout. Note that the
EEPROM is mirrored to three additional address ranges, such that each
EEPROM byte can be read from four unique addresses. A similar mirroring
effect, sometimes called ghosting, will become very important later in
this chapter, just as it was in [Chapter 5](#ch05.xhtml_ch05).

EEPROM patches consist of a single byte for the patch number, and a byte
pair for the handler address of that patch. They are called before
sensitive functions in a switch table, but there is no mechanism for
patching ROM bugs that are not preceded by calls to the patch handler.

::: image
[]{#ch06.xhtml_page_64
.pagebreak}![Image](images/f0064-01.jpg){#ch6fig1}

> **Description:** Memory map showing address layout: Vectors (FFFF-FFF0), EEPROM Ghost (F000), EEPROM (E000), multiple EEPROM Ghost regions (D000, C000), 16kB User ROM (7FFF-4000), 8kB System ROM (33FF-2000), SRAM Ghosts (1FFF-0200), SRAM (01FF-0020), and Registers (001F-0000). The extensive EEPROM ghosting across multiple 4KB regions creates address aliasing vulnerabilities where writes to ghost addresses affect the actual EEPROM, potentially bypassing protection checks.

:::

Figure 6.1: ST16CF54 Memory Map

::: image
![Image](images/f0064-02.jpg){#ch6fig2}

> **Description:** SRAM layout detail showing three regions: Heap (EFFF to unspecified upper bound marked as <E030>), Patch Code (<E030>-1 to E072), and General Data (E071-E000). The patch code region indicates runtime modification capabilities, while the flexible heap boundary suggests dynamic memory allocation vulnerable to overflow attacks into the patch code space.

:::

Figure 6.2: Nagra1/Rom3 EEPROM Map

::: image
[]{#ch06.xhtml_page_65
.pagebreak}![Image](images/f0065-01.jpg){#ch6fig3}

> **Description:** Die photograph of an 8-bit microcontroller showing distinct functional blocks. Multiple large regular memory arrays occupy the upper and middle sections with characteristic striped patterns. Logic blocks and control circuitry fill the bottom third with irregular structures. A central vertical bus connects the major blocks. Bond pads line all edges. The clear separation between ROM, RAM, and logic regions reveals the classic 8-bit architecture vulnerable to targeted physical attacks on specific functional areas.

:::

Figure 6.3: Delayered ST16CF54A

[]{#ch06.xhtml_page_66 .pagebreak}A treasure trove of documentation for
this card can be found in Guy (2000b), and an annotated disassembly of
the complete ROM is available in Guy (2000a). The only public
documentation used to be a three-page marketing brief, but a copy of the
real datasheet was exposed in court records in STMicro (1996). It is
complete except for a missing companion document that describes the
system ROM.

### **The Bug** {#ch06.xhtml_ch00lev1sec19 .h3}

The bug itself is an overflow in a statically allocated byte buffer that
first holds the incoming APDU packet, and is later reused for the
outgoing reply. That much is a textbook buffer overflow, but there are a
few complications to work around.

First, the buffer sits at [0x019C]{.literal}, where it is the very last
thing in SRAM. Smart-card packets can be up to 255 bytes long, but there
are only 100 bytes before SRAM ends at [0x01FF]{.literal}. After that,
the official memory map shows a large gap before the system ROM.

The trick here, which makes the bug exploitable, is that SRAM is ghosted
in memory. Past the end of SRAM and 132 bytes into our 100-byte buffer,
a write to [0x0220]{.literal} is the same as a write to
[0x0020]{.literal} or a write to [0x0420]{.literal}. So even though the
buffer that we are overflowing comes *after* global variables and the
call stack, we can use the ghosting effect to loop back to the beginning
of memory and corrupt useful things.

There is no ghosting effect for the registers that sit from
[0x00]{.literal} to [0x1F]{.literal}, so we won't need to carefully
choose those values in the same way that we'll try to preserve SRAM.

One other effect worth watching is that a global variable early in SRAM
holds the index into the receive buffer. The packet is received one byte
at a time; when that variable is overwritten, the target location will
jump for the rest of the byte copies. This is useful for shaving some
bytes off of the packet, but if you ignore it, your exploit will go off
the rails and land in the wrong location.

::: image
[]{#ch06.xhtml_page_67
.pagebreak}![Image](images/f0067-01.jpg){#ch6fig4}

> **Description:** Text-based exploit instructions written in creative mixed-case style. The message warns about learning proper networking, describes getting access to a specific ROM chip using packet 288-02, explains RX/TX protocol for reading 4+4096 bytes of EEPROM, and provides extensive hexadecimal payload data for the exploit. The final command "nIpPeR cLaUz OO'" suggests this is from the Nipper Klaus exploit toolkit demonstrating EEPROM extraction via network protocol exploitation.

:::

Figure 6.4: Forum Posting of NipperClauz (2000)

### []{#ch06.xhtml_page_68 .pagebreak}**NipperClauz Exploit** {#ch06.xhtml_ch00lev1sec20 .h3}

Now that we've covered the theory, let's dig into the first public
example, NipperClauz (2000). The forum posting is reproduced in [Figure
6.4](#ch06.xhtml_ch6fig4), and in this section we'll disassemble it to
understand how it works.

These first three bytes are the transaction header, where
[0xC4]{.literal} is the length.

::: imagel
![Image](images/f0068-01.jpg)

> **Description:** Continuation of hexadecimal exploit payload showing byte sequence 0x21,0x00,0xC4 at line 14. This represents the tail end of the EEPROM read exploit payload, demonstrating the complete attack vector for extracting protected firmware data through buffer manipulation.

:::

After that, we have many lines of counting bytes that look like garbage,
sometimes interrupted by a more meaningful byte. Many of these bytes
don't matter, but the latter ones do overwrite global variables, and
having the wrong value there might break the exploit by crashing the
application or adjusting UART timing.

Shellcode begins halfway through line 35, and it calls back into the
ROM's function for transmitting a byte at [0x42d7]{.literal} to remain
quite short.

::: imagel
![Image](images/f0068-02.jpg)

> **Description:** Additional hexadecimal payload bytes showing sequence starting with 0x9B,0x9C,0x9D continuing through multiple lines. This represents another segment of the exploit code containing the byte patterns necessary to trigger the EEPROM read vulnerability.

:::

::: imagel
[]{#ch06.xhtml_page_69 .pagebreak}![Image](images/f0069-01.jpg)

> **Description:** 6502 assembly code showing exploit payload disassembly. The code begins with SEI, RSP, NOP instructions, then implements a transmission loop using LDA, JSR SUB_42d7 for TX, INC, BNE for iteration through DAT_e000 to DAT_0066, followed by exit jump to LAB_7381 in ROM. This represents the actual machine code that reads and transmits EEPROM contents byte-by-byte over the network interface, demonstrating the low-level firmware extraction mechanism.

:::

The exploit ends with some filler and a checksum byte.

::: imagel
![Image](images/f0069-02.jpg)

> **Description:** Final bytes of hexadecimal payload showing 0xE8, followed by four null bytes (0x00,0x00,0x00,0x60), and terminating with 0x55. These bytes likely represent padding and a termination marker for the exploit payload, with 0x55 possibly serving as a signature or validation byte.

:::

::: imagel
![Image](images/f0069-03.jpg)

> **Description:** Whimsical illustration showing a vintage phonograph with large horn speaker next to Nipper the dog listening attentively with head tilted. This references the famous "His Master's Voice" RCA/Victor trademark, cleverly connecting to the "Nipper Klaus" exploit name, suggesting the attack makes the device obediently "listen" and respond to attacker commands.

:::

### []{#ch06.xhtml_page_70 .pagebreak}**NDS Headend Exploit** {#ch06.xhtml_ch00lev1sec21 .h3}

Appendix F of Mordinson (1998) describes a different exploit for the
same bug. The following is the original exploit from that report in the
[nasm]{.literal} assembler format, with minor changes to comments.

Note how clean the comments are, explaining nearly every instruction and
providing the exact address at which it is loaded into memory. Rather
than call back into the ROM's function for transmitting a byte, it
instead implements its own function for this at [0x01c8]{.literal}.

::: imagel
![Image](images/f0070-01.jpg)

> **Description:** Nintendo DS exploit assembly code and documentation from Headend Project Report NDS089461. The listing shows NAD (Node Address) 0x21, PCP byte 0x00, and LEN of 0xA8 bytes. The code implements an EEPROM download routine starting at E000, using JSR (Jump to Subroutine), LDA (Load Accumulator), STA (Store Accumulator), and various NOP padding instructions. Comments indicate byte-writing routine for ETU=32/f with IO timing delays. This represents a complete firmware extraction exploit targeting Nintendo DS EEPROM through the documented command protocol.

:::

::: imagel
[]{#ch06.xhtml_page_71 .pagebreak}![Image](images/f0071-01.jpg)

> **Description:** Continuation of Nintendo DS exploit assembly showing detailed byte manipulation with BSET0, INC, BRA (Branch), BCLR0, NEG, DEC operations for IO timing control. The code includes ASR (Arithmetic Shift Right) for parity bit computation, ROL (Rotate Left) for bit positioning, extensive MUL instructions with NOP padding for timing delays, and uses flags (0x01-0x05, 0x21, 0x30, 0x34) to control message flow. Comments explain byte reception (0x3D), storage location computation (0x7C/0x7E return pointers), and CRC validation (0x7F). The exploit crafts responses to avoid matching actual CRC (0x93) to trigger error conditions for code upload.

:::

### []{#ch06.xhtml_page_72 .pagebreak}**A Modern Exploit in Go** {#ch06.xhtml_ch00lev1sec22 .h3}

Both of those exploits will successfully dump the card's EEPROM. This
book is about writing exploits, not running them, so I ordered a dozen
satellite receivers and assorted card collections until I found some
that were vulnerable. In this section, we'll cover Goodspeed (2022), my
exploit for the cards, which runs on modern computers with USB
smart-card adapters, dumping not just the EEPROM but also the user ROM
and what SRAM it doesn't corrupt.

To get your own card, simply collect a bunch of them and then read the
Answer To Reset (ATR) of the cards. You're looking for one whose ROM
reads as [DNASP003]{.literal} (meaning ROM3) and whose EEPROM version
reads as [Rev272]{.literal} or earlier. A few of my cards falsely
present a later EEPROM revision to pretend that they have been patched,
so don't always believe the version number when it tells you the card is
not vulnerable.

These cards have already been hacked for TV piracy, of course. Hacked
cards can also be recognized when the electronic serial number disagrees
with the printed serial number.

The first complication is that the Headend and NipperClauze exploits
dump back all EEPROM in a single transaction. Smart-card transactions
have a one byte length field and a checksum, so the response is a lot
more data than the length field ought to allow and the checksum is
always wrong. That wasn't a problem when these were written in the
Nineties, but modern smart-card adapters use USB instead of a serial
port. USB's smart-card standard (CCID) abstracts away packets, requiring
that all lengths and checksums be correct.

To solve this, I reduced my transactions to 64 bytes and wrote shellcode
that accepts a base address for the dump. Like the other exploits, mine
does not support clean continuation. I found it convenient to avoid
continuation hassles by simply resetting the card for every transaction.

::: image
[]{#ch06.xhtml_page_73
.pagebreak}![Image](images/f0073-01.jpg){#ch6fig5}

> **Description:** Hexadecimal dump showing captured data with ASCII interpretation on the right. The dump reveals structured packet data including control bytes, addresses, and payload content. Visible patterns include sequential increments and repeated values suggesting protocol framing. The ASCII column shows fragments like "cL..%", "Rx5269.U", "NipPEr", and "Cn.u.GY" indicating mixed binary and text data typical of firmware or protocol exploitation capture.

:::

Figure 6.5: Revision 369 EEPROM Dump

You will note that my shellcode does not include the three byte header
or one byte footer of the other examples. This is because the PCSC
daemon automatically applies the header and checksum to the transaction.
As the shellcode dumps just 64 bytes per execution, the start address
must be written into the [ld a, (target+1, x)]{.literal} instruction in
the loop, where [0xFFFF]{.literal} sits in the listing.

To transmit a reply back to the host, the shellcode jumps into a user
ROM function at [0x757f]{.literal}. This is the normal function that the
ROM uses for transmitting its messages, which is a little smaller than
reusing the function for transmitting a byte, as the NipperClauz
shellcode does. It's also smaller than implementing a completely custom
transmitting function, as in the Headend exploit.

::: imagel
[]{#ch06.xhtml_page_74 .pagebreak}![Image](images/f0074-01.jpg)

> **Description:** JavaScript rewrite of NipperClauz exploit code with extensive padding array before buffer overflow. The code includes comment explaining this implements buffer clobbering to send responses, unlike the original exploit which dumped data directly to serial. The shellcode begins at 0x9d (four NOPs) then loads data at 0x19C+2 using LDA/STA operations. The payload implements a memory copy loop (LD A, (target+1,X); ST A (0x01A1+1,X); DEC; JRPL loop) followed by response code transmission (LDA #$93, LDX #$17, JMP RESPONDAX). This represents an adapted version for USB readers requiring proper packet formatting rather than raw serial output.

:::

::: imagel
[]{#ch06.xhtml_page_75
.pagebreak}![Image](images/f0075-01.jpg)

> **Description:** Continuation of JavaScript exploit showing detailed shellcode implementation. Comments explain the loop loads bytes from source buffer, stores to data buffer via STA, uses DEC for decrement, and JRPL for jump-relative-plus to iterate until F6. The code sends response data with LDA #$93 (response code) and LDX #$17 (length in bytes), then JMP RESPONDAX. Additional comments note three clobbered bytes and entry point setup at 0x0060, demonstrating complete exploitation chain from buffer overflow to controlled response injection.
[]{#ch06.xhtml_page_76
.pagebreak}
:::

[]{#ch07.xhtml}

