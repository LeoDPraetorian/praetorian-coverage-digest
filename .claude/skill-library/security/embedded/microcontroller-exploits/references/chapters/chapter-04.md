## []{#ch04.xhtml_page_41 .pagebreak}**4â€‚LPC1343 Call Stack** {#ch04.xhtml_ch04 .h2}

The LPC800, LPC1100, LPC1200, LPC1300, LPC1500, LPC-1700, and LPC1800
series of ARM microcontrollers from NXP are vulnerable to bootloader
memory corruption. This was first described in Herrewegen et al. (2020)
for the LPC1343, a Cortex M3 with 32kB of flash and 8kB of RAM. In this
chapter, we'll explore the bootloader's protocol and the vulnerability,
then walk through the steps of writing our own exploit.

LPC microcontrollers have five Code Read Protection (CRP) levels, each
of which provides further restrictions on the ISP (bootloader) and SWD
(debugger) access. Level 0 (NOCRP) is unprotected, allowing memory to be
freely read and written through the bootloader or an SWD debugger. CRP 1
disables SWD debugging entirely, while ISP reads are prevented and ISP
writes are restricted, in order to allow in-the-field updates of some
memory while protecting the rest. In CRP 2, most commands are disabled.
CRP 3 is the most secure, disabling all functionality. A fifth mode,
NOISP, disables the ISP interface while leaving SWD enabled, so that
memory is still exposed.

The bootloader presents itself as both a UART serial port and a USB mass
storage disk, in which a single file of the disk represents the chip's
firmware. Herrewegen's attack is specific to the UART interface in CRP
Level 1, but the authors note that the mass storage interface is likely
a good target for further bug hunting. See [Chapter
15](#ch15.xhtml_ch15) for a glitching attack that works reliably against
these chips in higher protection modes.

::: image
[]{#ch04.xhtml_page_42
.pagebreak}![Image](images/f0042-01.jpg){#ch4fig1}

> **Description:** Die photograph of a mask ROM or memory array chip showing highly regular vertical stripe patterns representing memory cells. The uniform structure with consistent spacing indicates dense memory storage with vertical bitlines and horizontal wordlines. A small logic block appears in the upper right corner. Bond pads line the perimeter for external connections. The regular array structure makes this vulnerable to physical attacks like focused ion beam modification or optical fault injection.

:::

Figure 4.1: LPC1343

### []{#ch04.xhtml_page_43 .pagebreak}**Getting Started** {#ch04.xhtml_ch00lev1sec11 .h3}

The mask ROM bootloader is 16kB at [0x1fff0000]{.literal}. 32kB of flash
memory begin at address [0x00000000]{.literal}, and 8kB of SRAM are
mapped at [0x10000000]{.literal}.

The bootloader does not allow ROM to be read directly, so I first dumped
the ROM using an SWD debugger and OpenOCD. I also wanted a copy of SRAM,
in order to have global variable and stack values while debugging, so I
first zeroed SRAM with the debugger and then booted into the bootloader.
Reading a RAM dump through the bootloader gave me the state from within
the Read RAM function of the bootloader, with all uninitialized bytes
left as [0x00]{.literal}.

The protection level is configured by a 32-bit word written to
[0x02fc]{.literal} in flash memory. CRP 1 is [0x12345678]{.literal}, CRP
2 is [0x87654321]{.literal}, and CRP 3 is [0x43218765]{.literal}. All
other values leave the chip unprotected, which makes it a good target
for the glitching attack in [Chapter 15](#ch15.xhtml_ch15).

RAM begins at [0x10000000]{.literal} with a protected region for the
bootloader to use as working memory. The bootloader will deny writes to
this region. According to the documentation, the first 768 bytes up to
[0x10000300]{.literal} ought to be protected, but in practice, only the
first 512 bytes up to [0x10000200]{.literal} are protected. A few global
variables exist in the range that is not (but ought to be) protected,
but none of these globals are known to be exploitable. [Figure
4.3](#ch04.xhtml_ch4fig3) shows this layout.

The designers seem to have protected their [.data]{.literal} section,
while forgetting that the call stack is an even juicier target for
attackers. The bootloader's call stack grows downward from
[0x10001fdc]{.literal}, entirely outside of the write-protected region!
Herrewegen's exploit works by repeatedly altering this stack with the
Write RAM function to trigger a return into the otherwise unreachable
Read []{#ch04.xhtml_page_44 .pagebreak}Memory function, dumping some
bytes of flash before repeating the process all over again.

### **UART Protocol in Brief** {#ch04.xhtml_ch00lev1sec12 .h3}

The UART protocol is documented in [Chapter 21](#ch21.xhtml_ch21) of NXP
(2012). It's an ASCII protocol that automatically syncs to your baud
rate, and you can slowly type most of the protocol by hand in a terminal
emulator if that's your fancy.

The bootloader is enabled by pulling the [BLD_E]{.literal} pin high, and
the UART mode is selected on models with USB by pulling [P0_3]{.literal}
low. After starting the bootloader, you transmit a question mark at
57,600 baud. The chip sends you the word [Synchronized]{.literal}, and
you send it back to confirm that things are working.

Each command is sent as a line of text, which is echoed back. Parameters
that are numeric are *always* in base 10; there's no support for parsing
hexadecimal. Reads and writes are armored in lines of the
[uuencode]{.literal} format, with a checksum every twenty lines. (With
45 decoded bytes per line, that's every 900 bytes.)

As I couldn't find an open source bootloader client to patch, I wrote a
new bootloader client in Golang with the [go-serial]{.literal} library.

::: image
[]{#ch04.xhtml_page_45
.pagebreak}![Image](images/f0045-01.jpg){#ch4fig2}

> **Description:** Memory map for a smaller microcontroller showing APB Peripherals (0x4007 ffff - 0x4000 0000), 16kB Boot ROM (0x1fff 4000 - 0x1fff 0000), 8kB SRAM (0x1000 1fff - 0x1000 0000), and 32kB Flash (0x0000 8000 - 0x0000 0000). The annotation "We want this!" points to the entire lower address space, indicating the flash memory as the primary target for exploitation.

:::

Figure 4.2: LPC1343 Memory Map

::: image
![Image](images/f0045-02.jpg){#ch4fig3}

> **Description:** Detailed SRAM layout showing address regions within CRP1 protection: Call Stack (0x1000 2000), Transfer Buffers (0x1000 0300), and Bootloader Globals (0x1000 0000 - 0x1000 0200). All regions are marked as "Writable in CRP1", revealing that despite code read protection, RAM remains accessible for potential data exfiltration or buffer overflow attacks targeting the call stack.

:::

Figure 4.3: LPC1343 Bootloader SRAM

::: image
[]{#ch04.xhtml_page_46
.pagebreak}![Image](images/f0046-01.jpg){#ch4fig4}

> **Description:** Bootloader command reference table showing ISP protocol commands: U (Unlock), B (Set Baud Rate), A (Echo), W (Write to RAM), R (Read Memory), P (Prepare Sectors for Write), C (Copy RAM to Flash), G (Go), E (Erase Sectors), I (Blank Check Sectors), J (Read Part ID), K (Read Boot Code Version), M (Compare), N (Read UID), and T (Undocumented). These commands expose complete control interface for memory manipulation and code execution.

:::

Figure 4.4: LPC1343 Bootloader Commands

::: image
![Image](images/f0046-02.jpg){#ch4fig5}

> **Description:** CRP (Code Read Protection) level table showing magic values and their access permissions: NOISP (0x4E697370) enables JTAG only, CRP1 (0x12345678) allows ISP subset operations, CRP2 (0x87654321) permits mass erase only, CRP3 (0x43218765) disables all access, and INVALID (all others) enables both JTAG and ISP. This reveals the protection scheme hierarchy and the specific magic values that control debug access.

:::

Figure 4.5: Code Protection Literals

### []{#ch04.xhtml_page_47 .pagebreak}**Reverse Engineering the Bootloader** {#ch04.xhtml_ch00lev1sec13 .h3}

The next step is to reverse engineer the bootloader. I did this in
Ghidra, loading the ROM dump at [0x1fff0000]{.literal} and an SRAM dump
at [0x10000000]{.literal}.

On my first try, I loaded an SRAM dump from a chip that hadn't been
zeroed. SRAM loses its state when not powered, so this filled the mostly
unused memory with gobbledygook that frustrated reverse engineering.
Zeroing SRAM before running the bootloader, then dumping it through the
bootloader gave me an image with all global variables initialized and
with a live call stack to help me get my bearings.

These dumps were taken from an unlocked chip, of course. Except when
unlocked chips are unavailable, such as for smart cards that are only
available under an NDA, it's best to develop exploits first against
unlocked chips and only later to use them against a locked target.

After loading both the firmware and the SRAM dump, I spent an afternoon
looking for functions and naming them. Good clues to a function's
purpose can come from the I/O addresses that it accesses and whether it
reads or writes them.

The first nybble of an address tells me what type it is, just by
checking the memory map in [Figure 4.2](#ch04.xhtml_ch4fig2). Those that
begin with a [1]{.literal} are SRAM on this chip, while those that begin
with [0]{.literal} are flash memory and effectively constant. If it
begins with a [4]{.literal}, it's an I/O peripheral and I can look up
the peripheral's name in the chip's datasheet or header files.

Large [switch]{.literal} statements are also handy, such as the loop
that interprets the commands in [Figure 4.4](#ch04.xhtml_ch4fig4). Note
that two of those commands, [T]{.literal} and [U]{.literal}, are absent
from NXP's documentation.

I skipped over the mass storage implementation, as I already knew which
bug I would be exploiting from reading the details in
[]{#ch04.xhtml_page_48 .pagebreak}Herrewegen et al. (2020). When hunting
an original bug, rather than re-implementing prior art, it's a good idea
to explore all of the code that is reachable while the chip is locked.
Pay special attention to parser code, and consider fuzz testing the
firmware in emulation if you don't find an exploitable bug manually.

### **Controlling the Program Counter** {#ch04.xhtml_ch00lev1sec14 .h3}

After implementing the basic bootloader commands, we can read and write
the SRAM of a locked chip above [0x10000200]{.literal}, so controlling
the program counter is as simple as finding a return pointer on the
stack above that address. If we overwrite that address and then return,
the chip will branch to our new address rather than the legitimate
caller function.

In my Ghidra project, I looked at the interrupt table of the bootloader
at [0x1fff0000]{.literal}. The very first word, [0x10000ffc]{.literal},
is the initial top of the stack, and the return pointer that I want to
clobber should come somewhere below that in memory.

My second clue to a good injection location was that when I halted the
bootloader to zero it, the program counter was [0x10001f88]{.literal}.
Depth will vary by the function being called, but this shows that I'm in
the right region.

A third clue came again from Ghidra, where I could explore this region
for valid code pointers. The offset will vary a bit, because I'm viewing
the stack of the Read command and my exploit will be corrupting the
stack of the Write command, but the alignments are often similar.

Eventually I came up with [0x10001f94]{.literal} as a working return
pointer that is restored to the program counter after the Read command
sends its acknowledgment. It's here that I write the address of my
shellcode to trigger its execution.

::: imagel
[]{#ch04.xhtml_page_49 .pagebreak}![Image](images/f0049-01.jpg)

> **Description:** Exploit code showing exploit_setpc function that uses the W command to inject shellcode. The function defines shellcode as a byte array of ARM instructions, loads it to address 0x10000300 (above the protection line in writable RAM), then calls exploit_setpc to redirect program counter execution. This demonstrates a complete code injection attack bypassing CRP1 protection through the writable transfer buffer region.

:::

### **Shellcode for Privilege Escalation** {#ch04.xhtml_ch00lev1sec15 .h3}

Herrewegen's exploit rewrote more than just the return pointer. Instead,
he patched the stack to turn a Write into a Read, dumping text back to
his client. I'm lazy, so I took the more direct route of running C
shellcode from RAM rather than repurposing existing code from ROM.

Getting the shellcode as bytes that would run from SRAM required only a
minimal linker script, and for simplicity's sake I used the
[ENTRY(main)]{.literal} directive to make my [main()]{.literal} method
the entrypoint, and I placed [.text]{.literal} and [.data]{.literal}
next to each other in RAM. The first byte is the entry point, and any
global variables are loaded directly with the image rather than copied
from code memory.

From the Herrewegen paper, I knew that there is a global variable in
SRAM that caches the CRP lock word. The permanent location in flash is
at [0x000002fc]{.literal}, and a little bit of searching in Ghidra
revealed that the cached version is at [0x10000184]{.literal}. So the
first thing my shellcode must do is overwrite this with a higher
[]{#ch04.xhtml_page_50 .pagebreak}privilege value, such as zero.

I also needed to make sure that the stack had been restored, so that the
interpreter loop of the bootloader wouldn't crash. This could be done by
luck, or by crafting the right bytes on the stack, but because I wanted
my shellcode to work on the very first try, I took a simpler solution:
it simply calls the main loop of the command interpreter, which expects
to be called by the bootloader after privileges have been cached. It's
an infinite [while()]{.literal} loop that never returns, and there's
plenty of stack depth to spare. This gives a clean continuation without
any hard work.^[1](#footnotes.xhtml_ch4fn1){#ch04.xhtml_ch4fn_1}^

This is my symbol file. It defines only the global variable that
contains the protection level and the bootloader's command interpreter
loop.

::: imagel
![Image](images/f0050-01.jpg)

> **Description:** Variable definitions showing memory locations: crp_level_ram at 0x10000184 and cmd_mainloop at 0x1fff0fba. These addresses represent critical bootloader data structures in SRAM and ROM respectively, used for tracking protection state and the main command processing loop. Modifying crp_level_ram enables protection bypass attacks.

:::

This is my shellcode, written in C rather than assembly. It simply
disables the protections and jumps right back into the command loop.

::: imagel
![Image](images/f0050-02.jpg)

> **Description:** C code for disabling CRP protection showing main function that sets crp_level_ram to 0 (disabling protections) then calls cmd_mainloop to return to the bootloader. The comment notes that cmd_mainloop never returns but the return statement is harmless. This code provides complete bootloader unlock capability when injected and executed in the writable RAM region.

:::

[]{#ch04.xhtml_page_51 .pagebreak}Tying all of that together, this is
the Go method that unlocks the chip, before cleanly continuing into any
of the standard boot-loader commands without the pesky readout
protection getting in the way.

::: imagel
![Image](images/f0051-01.jpg)

> **Description:** Exploit unlock function containing ARM shellcode byte array with opcodes for the protection bypass payload. The function uploads shellcode to address 0x10000300 using W() command, then calls exploit_setpc(loadadr) to redirect execution. The shellcode implements the protection disable operation, demonstrating a complete exploitation chain from initial access to arbitrary code execution.
[]{#ch04.xhtml_page_52 .pagebreak}
:::

[]{#ch05.xhtml}

