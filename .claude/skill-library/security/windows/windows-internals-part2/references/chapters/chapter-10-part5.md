## EXPERIMENT: Tracing dynamic memory

In this experiment, you dynamically trace the dynamic memory applied to a VM. Using Hyper-V Manager, you need to create a generation 2 Virtual Machine and apply a minimum of 768 MB and an unlimited maximum amount of dynamic memory (more information on dynamic memory and Hyper-V is available in Chapter 9). The VM should have the May 2019 (19H1) or May 2020 (20H1) Update of Windows 10 or later installed as well as the DTrace package (which should be enabled as explained in the "Enabling DTrace and listing the installed providers" experiment from earlier in this chapter).

The dynamic_memory.d script, which can be found in this book's downloadable resources, needs to be copied in the DTrace directory and started by typing the following commands in an administrative command prompt window:

```bash
cd /c";Program Files\DTcache\
```

With only the preceding commands, DTrace will refuse to compile the script because of an

error similar to the following:

```bash
dtrace: failed to compile script dynamic_memory.d: line 62: probe description fbt:nt:MiRem
ovePhysicalMemory:entry does not match any probes
```

This is because, in standard configurations, the path of the symbols store is not set. The script attaches the FBT provider on two OS functions: MmAddPhysicalMemory, which is exported from the NT kernel binary, and MiRemovePhysicalMemory, which is not exported or published in the public WDK. For the latter, the FBT provider has no way to calculate its address in the system.

DTrace can obtain types and symbol information from different sources, as explained in the "DTrace type library" section later in this chapter. T o allow the FBT provider to correctly work with internal OS functions, you should set the Symbol Store's path to point to the Microsoft public symbol server, using the following command:

```bash
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
```

---

After the symbol store a path is set, if you restart DTrace targeting the dynamic_memory.d

script, it should be able to correctly compile it and show the following output:

The Dynamic Memory script has begun.

Now you should simulate a high-memory pressure scenario. You can do this in multiple ways—for example, by starting your favorite browser and opening a lot of tabs, by starting a 3D game, or by simply using the TestLimit tool with the -d command switch, which forces the system to contiguously allocate memory and write to it until all the resources are exhausted. The VM worker process in the root partition should detect the scenario and inject new memory in the child VM. This would be detected by DTrace:

```bash
Physical memory addition request intercepted. Start physical address 0x00112C00, Number of
cycles 1024, Data store location 0x00112C00.
Addition of 1024 memory pages starting at PFA 0x00112C00 succeeded!
```

In a similar way, if you close all the applications in the guest VM and you recreate a high memory pressure scenario in your host system, the script would be able to intercept dynamic

memory's removal requests:

```bash
Physical memory removal request intercepted. Start physical address 0x00132000, Number of
page entries read from disk.
Removal of 512 memory pages starting at PFN 0x00132000 succeeded!
```

After interrupting DTrace using Ctrl+C, the script prints out some statistics information:

```bash
Dynamic Memory script ended.
Numbers of Hot Additions: 217
Numbers of Hot Removals: 1602
Since starts the system has gained 0x00017A00 pages (378 MB).
```

If you open the dynamic_memory.dscript using Notepad, you will find that it installs a total of six probes (four FBT and two built-in and performs logging and counting actions. For example,

```bash
fmt:TMmAddPhysicalTMemory:return
// self->pStartingAddress = 0;
```

installs a probe on the exit points of the MmAddPhysicalMemory function only if the starting physical address obtained at function entry point is not 0. More information on the D programming language applied to DTrace is available in the The Illumina Dynamic Tracing Guide book, which is freely accessible at http://dtrace.org/guide/preface.html.

## The ETW provider

DTrace supports both an ETW provider, which allows probes to fire when certain ETW events are generated by particular providers, and the etw_trace action, which allows DTrace scripts to generate new customized TraceLogging ETW events. The etw_trace action is implemented in LibDTrace, which uses TraceLogging APIs to dynamically register a new ETW provider and generate events associated with it. More information on ETW has been presented in the "Event Tracing for Windows (ETW)" section previously in this chapter.

---

The ETW provider is implemented in the DTrace driver. When the Trace engine is initialized by the Pnp manager, it registers all providers with the DTrace engine. At registration time, the ETW provider configures an ETW session called DTraceLoggingSession, which is set to write events in a circular buffer. When DTrace is started from the command line, it sends an IOCTL to DTrace driver. The IOCTL handler calls the provide function of each provider; the DTeVtwpCreate internal function invokes the

NTTraceControl API with the EtvEnumTraceGuidList function code. This allows DTrace to enumerate all the ETW providers registered in the system and to create a probe for each of them. (dtrace -i is also able to display ETW probes.)

When a D script targeting the ETW provider is compiled and executed, the internal DtEtwEnable

routine gets called with the goal of enabling one or more ETW probes. The logging session configured

at registration time is started, if it's not already running. Through the trace extension context (which,

as previously discussed, contains private system interfaces), DTrace is able to register a kernel-mode

callback called every time a new event is logged in the DTrace logging session. The first time that the

session is started, there are no providers associated with it. Similar to the syscall and FBT provider, for

each probe DTrace creates a tracking data structure and inserts it in a global RB tree (DtEtwpProbeTree)

representing all the enabled ETW probes. The tracking data structure is important because it rep resents the link between the ETW provider and the probes associated with it. DTrace calculates the

correct enablement level and keyword bitmask for the provider (see the "Provider Enablement" section

previously in this chapter for more details) and enables the provider in the session by invoking the

NetTraceControl API.

When an event is generated, the ETW subsystem calls the callback routine, which searches into the global ETW probe tree the correct context data structure representing the probe. When found, DTrace can fire the probe (still using the internal dtrace_probe function) and execute all the actions associated with it.

## DTrace type library

DTrace works with types. System administrators are able to inspect internal operating system data structures and use them in D clauses to describe actions associated with probes. DTrace also supports supplemental data types compared to the ones supported by the standard D programming language. To be able to work with complex OS-dependent data types and allow the FBT and PID providers to set probes on internal OS and application functions, DTrace obtains information from different sources:

- ■ Function names, signatures, and data types are initially extracted from information embedded
in the executable binary (which adheres to the Portable Executable file format), like from the
export table and debug information.
■ For the original DTrace project, the Solaris operating system included support for Compact C
Type Format (CTF) in its executable binary files (which adhere to the Executable and Linkable
Format - ELF). This allowed the OS to store the debug information needed by DTrace to run di-
rectly into its modules (the debug information can also be stored using the deflate compression
format). The Windows version of DTrace still supports a partial CTF, which has been added as a
resource section of the LibDTrace library (Dtrace.dll). CTF in the LibDTrace library stores the type
---

information contained in the public WDK (Windows Driver Kit) and SDK (Software Development Kit) and allows DTrace to work with basic OS data types without requiring any symbol file.

- Most of the private types and internal OS function signatures are obtained from PDB symbols.
Public PDB symbols for the majority of the operating system's modules are downloadable
from the Microsoft Symbol Server. (These symbols are the same as those used by the Windows
Debugger). The symbols are deeply used by the FBT provider to correctly identify internal OS
functions and by DTrace to be able to retrieve the correct type of parameters for each syscall
and function.
### The DTrace symbol server

DTrace includes an autonomous symbol server that can download PDB symbols from the Microsoft public Symbol store and render them available to the DTrace subsystem. The symbol server is implemented mainly in LibDTrace and can be queried by the DTrace driver using the Inverted call model. As part of the providers' registration, the DTrace driver registers a SymServer pseudo-provider. The latter is not a real provider but just a shortcut for allowing the msymrv handler to the DTrace control device to be registered.

When DTrace is started from the command line, the LibDTrace library starts the symbols server by opening a handle to the \\dtrace\symsrv control device (using the standard CreateFile API). The request is processed by the DTrace driver through the Symbol server IRP handler, which registers the user-mode process, adding it in an internal list of symbols server processes. LibDTrace then starts a new thread, which sends a dummy IOCTL to the DTrace symbol server device and waits indefinitely for a reply from the driver. The driver marks the IRP as pending and completes it only when a provider (or the DTrace subsystem), requires new symbols to be parsed.

Every time the driver completes the pending IRP, the DTrace symbols server thread wakes up and uses services exposed by the Windows Image Helper library (Dbhelp.dll) to correctly download and parse the required symbol. The driver then waits for a new dummy IOCTL to be sent from the symbols thread. This time the new IOCTL will contain the results of the symbol parsing process. The user-mode thread wakes up again only when the DTrace driver requires it.

## Windows Error Reporting (WER)

Windows Error Reporting (WER) is a sophisticated mechanism that automates the submission of both user-mode process crashes as well as kernel-mode system crashes. Multiple system components have been designed for supporting reports generated when a user-mode process, protected process, trustlet, or the kernel crashes.

Windows 10, unlike from its predecessors, does not include a graphical dialog box in which the user can configure the details that Windows Error Reporting acquires and sends to Microsoft (or to an internal server configured by the system administrator) when an application crashes. As shown in Figure 10-38, in Windows 10, the Security and Maintenance applet of the Control Panel can show the user a history of the reports generated by Windows Error Reporting when an application (or the kernel) crashes. The applet can show also some basic information contained in the report.

CHAPTER 10    Management, diagnostics, and tracing     535


---

![Figure](figures/Winternals7thPt2_page_567_figure_000.png)

FIGURE 10-38 The Reliability monitor of the Security and Maintenance applet of the Control Panel.

Windows Error Reporting is implemented in multiple components of the OS, mainly because it

needs to deal with different kind of crashes:

- ■ The Windows Error Reporting Service (WerSvc.dll) is the main service that manages the creation
and sending of reports when a user-mode process, protected process, or trustlet crashes.
■ The Windows Fault Reporting and Secure Fault Reporting (WerFault.exe and WerFaultSecure.
exe) are mainly used to acquire a snapshot of the crashing application and start the genera-
tion and sending of a report to the Microsoft Online Crash Analysis site (or, if configured, to an
internal error reporting server).
■ The actual generation and transmission of the report is performed by the Windows Error
Reporting DLL (Wer.dll). The library includes all the functions used internally by the WER engine
and also some exported API that the applications can use to interact with Windows Error
Reporting (documented at https://docs.microsoft.com/en-us/windows/win32/api_wer/). Note
that some WER APIs are also implemented in KernelBase.dll and Faultrep.dll.
■ The Windows User Mode Crash Reporting DLL (Faultrep.dll) contains common WER stub code
that is used by system modules (Kernel32.dll, WER service, and so on) when a user-mode appli-
cation crashes or hangs. It includes services for creating a crash signature and reports a hang to
the WER service, managing the correct security context for the report creation and transmission
(which includes the creation of the WerFault executable under the correct security token).

CHAPTER 10 Management, diagnostics, and tracing


---

- ■ The Windows Error Reporting Dump Encoding Library (Werenc.dll) is used by the Secure Fault
Reporting to encrypt the dump files generated when a trusted crashes.

■ The Windows Error Reporting Kernel Driver (WerKernel.sys) is a kernel library that exports
functions to capture a live kernel memory dump and submit the report to the Microsoft Online
Crash Analysis site. Furthermore, the driver includes APIs for creating and submitting reports for
user-mode faults from a kernel-mode driver.
Describing the entire architecture of VER is outside the scope of this book. In this section, we mainly describe error reporting for user-mode applications and the NT kernel (or kernel-driver) crashes.

## User applications crashes

As discussed in Chapter 3 of Part 1, all the user-mode threads in Windows start with the RtlUserThreadStart function located in NtSdl. The function does nothing more than calling the real thread start routine under a structured exception handler. (Structured exception handling is described in Chapter 8.) The handler protecting the real start routine is internally called Unhanded Exception Handler because it is the last one that can manage an exception happening in a user-mode thread (when the thread does not already handle it). The handler, if executed, usually terminates the process with the NtTerminateProcess API. The entity that decides whether to execute the handler is the unhandled exception filter, RtlpThreadExceptionFilter. Noteworthy is that the unhandled exception filter and handler are executed only under abnormal conditions; normally, applications should manage their own exceptions with inner exception handlers.

When a Win32 process is starting, the Windows loader maps the needed imported libraries. The kernelbase initialization routine installs its own unhandled exception filter for the process, the UnhandledExceptionFilter routine. When a fatal unhandled exception happens in a process's thread, the filter is called to determine how to process the exception. The kernelbase unhandled exception filter builds context information (such as the current value of the machine's registers and stack, the faulting process ID, and thread ID) and processes the exception:

- ■ If a debugger is attached to the process, the filter lets the exception happen (by returning
CONTINUE_SEARCH). In this way, the debugger can break and see the exception.
■ If the process is a trustlet, the filter stops any processing and invokes the kernel to start the
Secure Fault Reporting (WerFaultSecure.exe).
■ The filter calls the CRT unhandled exception routine (if it exists) and, in case the latter does not
know how to handle the exception, it calls the internal WerpReportFault function, which con-
nects to the WER service.
Before opening the ALPC connection, WerpReportFault should wake up the WER service and prepare an inheritable shared memory section, where it stores all the context information previously acquired. The WER service is a direct triggered-start service, which is started by the SCM only in case the WER_SERVICE_START_WNF state is updated or in case an event is written in a dummy WER activation ETW provider (named Microsoft-Windows-Feedback-Service-TriggerProvider), WerpReportFault

CHAPTER 10  Management, diagnostics, and tracing     537


---

updates the relative WNF state and waits on the \KernelObjects\SystemErrorPortReady event, which is

signaled by the WER service to indicate that it is ready to accept new connections. After a connection

has been established, Ndtlld connects to the WER service's \WindowsErrorReportingServicePort ALPC

port, sends the WERSVC_REPORT_CRASH message, and waits indefinitely for its reply.

The message allows the WER service to begin to analyze the crashed program's state and performs the appropriate actions to create a crash report. In most cases, this means launching the WerFault.exe program. For user-mode crashes, the Windows Fault Reporting process is invoked two times using the faulting process's credentials. The first time is used to acquire a "snapshot" of the crashing process. This feature was introduced in Windows 8.1 with the goal of rendering the crash report generation of UWP applications (which, at that time, were all single-instance applications) faster. In that way, the user could have restarted a crashed UWP application without waiting for the report being generated. (UWP and the modern application stack are discussed in Chapter 8.)

## Snapshot creation

WerFault maps the shared memory section containing the crash data and opens the faulting process

and thread. When invoked with the -pss command-line argument (used for requesting a process snap shot), it calls the PssNtCaptureSnapshot function exported by Ntdll. The latter uses native APIs to query

multiple information regarding the crashing process (like basic information, job information, process

times, secure mitigations, process file name, and shared user data section). Furthermore, the function

queries information regarding all the memory sections baked by a file and mapped in the entire user mode address space of the process. It then saves all the acquired data in a PSS_SNAPSHOT data struc ture representing a snapshot. It finally creates an identical copy of the entire VA space of the crashing

process into another dummy process (cloned process) using the NtCreateProcessEx API (providing a

special combination of flags). From now on, the original process can be terminated, and further opera tions needed for the report can be executed on the cloned process.

![Figure](figures/Winternals7thPt2_page_569_figure_004.png)

Note WER does not perform any snapshot creation for protected processes and trustlets.

In these cases, the report is generated by obtaining data from the original faulting process,

which is suspended and resumed only after the report is completed.

## Crash report generation

After the snapshot is created, execution control returns to the WER service, which initializes the environment for the crash report creation. This is done mainly in two ways:

- ■ If the crash happened to a normal, unprotected process, the WER service directly invokes the
WerpInitiateCrashReporting routine exported from the Windows User Mode Crash Reporting
DLL (Faultrep.dll).

■ Crashes belonging to protected processes need another broker process, which is spawned un-
der the SYSTEM account (and not the faulting process credentials). The broker performs some
verifications and calls the same routine used for crashes happening in normal processes.
---

The WepNavigateCrashReporting routine, when called from the WER service, prepares the environment for executing the correct Fault Reporting process. It uses APIs exported from the WER library to initialize the machine store (which, in its default configuration, is located in C:\ProgramData\Microsoft\ WindowsWER) and load all the WER settings from the Windows registry. WER indeed contains many customizable options that can be configured by the user through the Group Policy editor or by manually making changes to the registry. At this stage, WER impersonates the user that has started the faulting application and starts the correct Fault Reporting process using the -u main command-line switch, which indicates to the Wefault (or WefaultSecure) to process the user crash and create a new report.

![Figure](figures/Winternals7thPt2_page_570_figure_001.png)

Note If the crashing process is a Modern application running under a low-integrity level

or AppContainer token, WER uses the User Manager service to generate a new medium-IL

token representing the user that has launched the faulting application.

Table 10-19 lists the WER registry configuration options, their use, and possible values. These values are located under the HKLM\SOFTWARE\Microsoft\Windows\Errors Reporting subkey for computer configuration and in the equivalent path under HKEY_CURRENT_USER for per-user configuration (some values can also be present in the \Software\Policies\Microsoft\Windows\Windows Error Reporting key).

TABLE 10-19 WER registry settings

<table><tr><td>Settings</td><td>Meaning</td><td>Values</td></tr><tr><td>ConfigureArchive</td><td>Contents of archived data</td><td>1 for parameters, 2 for all data</td></tr><tr><td>ConsentDefaultConsent</td><td>What kind of data should require consent</td><td>1 for any data, 2 for parameters only, 3 for parameters and safe data, 4 for all data.</td></tr><tr><td>ConsentDefaultOverrideBehavior</td><td>Whether the DefaultConsent overrides WER plug-in consent values</td><td>1 to enable override</td></tr><tr><td>ConsentPluginName</td><td>Consent value for a specific WER plug-in</td><td>Same as DefaultConsent</td></tr><tr><td>CorporateWERDirectory</td><td>Directory for a corporate WER store</td><td>String containing the path</td></tr><tr><td>CorporateWERPortNumber</td><td>Port to use for a corporate WER store</td><td>Port number</td></tr><tr><td>CorporateWERServer</td><td>Name to use for a corporate WER store</td><td>String containing the name</td></tr><tr><td>CorporateWERUserAuthentication</td><td>Use Windows Integrated Authentication for corporate WER store</td><td>1 to enable built-in authentication</td></tr><tr><td>CorporateWERUserSSL</td><td>Use Secure Sockets Layer (SSL) for corporate WER store</td><td>1 to enable SSL</td></tr><tr><td>DebugApplications</td><td>List of applications that require the user to choose between Debug and Continue</td><td>1 to require the user to choose</td></tr><tr><td>DisableArchive</td><td>Whether the archive is enabled</td><td>1 to disable archive</td></tr><tr><td>Disabled</td><td>Whether WER is disabled</td><td>1 to disable WER</td></tr><tr><td>DisableQueue</td><td>Determines whether reports are to be queued</td><td>1 to disable queue</td></tr><tr><td>DontShowUI</td><td>Disables or enables the WER UI</td><td>1 to disable UI</td></tr></table>


CHAPTER 10    Management, diagnostics, and tracing     539


---

<table><tr><td>Settings</td><td>Meaning</td><td>Values</td></tr><tr><td>DontSendAdditionalData</td><td>Prevents additional crash data from being sent</td><td>1 not to send</td></tr><tr><td>ExcludedApplications\AppName</td><td>List of applications excluded from WER</td><td>String containing the application list</td></tr><tr><td>ForceQueue</td><td>Whether reports should be sent to the user queue</td><td>1 to send reports to the queue</td></tr><tr><td>LocalDumps\DumpFolder</td><td>Path at which to store the dump files</td><td>String containing the path</td></tr><tr><td>LocalDumps\DumpCount</td><td>Maximum number of dump files in the path</td><td>Count</td></tr><tr><td>LocalDumps\DumpType</td><td>Type of dump to generate during a crash</td><td>0 for a custom dump, 1 for a minidump, 2 for a full dump</td></tr><tr><td>LocalDumps\CustomDumpFlags</td><td>For custom dumps, specifies custom options</td><td>Values defined in MINIDUMP_TYPE (see Chapter 12 for more information)</td></tr><tr><td>LoggingDisabled</td><td>Enables or disables logging</td><td>1 to disable logging</td></tr><tr><td>MaxArchiveCount</td><td>Maximum size of the archive (in files)</td><td>Value between 1-5000</td></tr><tr><td>MaxQueueCount</td><td>Maximum size of the queue</td><td>Value between 1-500</td></tr><tr><td>QueuePesterInterval</td><td>Days between requests to have the user check for solutions</td><td>Number of days</td></tr></table>


The Windows Fault Reporting process started with the -u switch starts the report generation:

the process maps again the shared memory section containing the crash data, identifies the exception's

record and descriptor, and obtains the snapshot taken previously. In case the snapshot does not

exist, the WeraFault process operates directly on the faulting process, which is suspended. WeraFault

first determines the nature of the faulting process (service, native, standard, or shell process). If the

faulting process has asked the system not to report any hard errors (through the SetErrorMode API),

the entire process is aborted, and no report is created. Otherwise, WER checks whether a default

post-mortem debugger is enabled through settings stored in the AeDebug subkey (AeDebugProtected

for protected processes) under the HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion, root

registry key. Table 10-20 describes the possible values of both keys.

TABLE 10-20 Valid registry values used for the AeDebug and AeDebugProtected root keys

<table><tr><td>Value name</td><td>Meaning</td><td>Data</td></tr><tr><td>Debugger</td><td>Specify the debugger executable to be launched when an application crashes.</td><td>Full path of the debugger executable, with eventual command-line arguments. The -p switch is automatically added by WER, pointing it to the crashing process ID.</td></tr><tr><td>ProtectedDebugger</td><td>Same as Debugger but for protected processes only.</td><td>Full path of the debugger executable. Not valid for the AeDebug key.</td></tr><tr><td>Auto</td><td>Specify the Autostartup mode</td><td>1 to enable the launching of the debugger in any case, without any user consent, 0 otherwise.</td></tr><tr><td>LaunchNonProtected</td><td>Specify whether the debugger should be executed as unprotected. This setting applies only to the AeDebugProtected key.</td><td>1 to launch the debugger as a standard process.</td></tr></table>


---

If the debugger start type is set to Auto, WER starts it and waits for a debugger event to be signaled before continuing the report creation. The report generation is started through the internal GenerateCrashReport routine implemented in the User Mode Crash Reporting DLL (Faultrep.dll). The latter configures all the WER plug-ins and initializes the report using the WerReportCreate API, exported from the WER.dll. (Note that at this stage, the report is only located in memory.) The GenerateCrashReport routine calculates the report ID and a signature and adds further diagnostics data to the report, like the process times and startup parameters or application-defined data. It then checks the WER configuration to determine which kind of memory dump to create (by default, a minidump is acquired). It then calls the exported WerReportAddDump API with the goal to initialize the dump acquisition for the faulting process (it will be added to the final report). Note that if a snapshot has been previously acquired, it is used for acquiring the dump.

The WERReportSubmit API, exported from WER.dll, is the central routine that generates the dump of the faulting process, creates all the files included in the report, shows the UI (if configured to do so by the DontShowUI registry value), and sends the report to the Online Crash server. The report usually includes the following:

- ■ A minidump file of the crashing process (usually named memory.hdump)
■ A human-readable text report, which includes exception information, the calculated signature
of the crash, OS information, a list of all the files associated with the report, and a list of all the
modules loaded in the crashing process (this file is usually named report.wer)
■ A CSV (comma separated values) file containing a list of all the active processes at the time of
the crash and basic information (like the number of threads, the private working set size, hard
fault count, and so on)
■ A text file containing the global memory status information
■ A text file containing application compatibility information
The Fault Reporting process communicates through ALPC to the WER service and sends commands

to allow the service to generate most of the information present in the report. After all the files have

been generated, if configured appropriately, the Windows Fault Reporting process presents a dialog

box (as shown in Figure 10-39) to the user, notifying that a critical error has occurred in the target

process. (This feature is disabled by default in Windows 10.)

![Figure](figures/Winternals7thPt2_page_572_figure_004.png)

FIGURE 10-39 The Windows Error Reporting dialog box.

CHAPTER 10    Management, diagnostics, and tracing     541


---

In environments where systems are not connected to the Internet or where the administrator wants to control which error reports are submitted to Microsoft, the destination for the error report can be configured to be an internal file server. The System Center Desktop Error Monitoring (part of the Microsoft Desktop Optimization Pack) understands the directory structure created by Windows Error Reporting and provides the administrator with the option to take selective error reports and submit them to Microsoft.

As previously discussed, the WER service uses an ALPC port for communicating with crashed processes. This mechanism uses a systemwide error port that the WER service registers through NtSetInformationProcess (which uses DbgkRegisterErrorPort). As a result, all Windows processes have an error port that is actually an ALPC port object registered by the WER service. The kernel and the unhandled exception filter in NtDll use this port to send a message to the WER service, which then analyzes the crashing process. This means that even in severe cases of thread state damage, WER is still able to receive notifications and launch Wrefault.exe to log the detailed information of the critical error in a Windows Event log (or to display a user interface to the user) instead of having to do this work within the crashing thread itself. This solves all the problems of silent process death: Users are notified, debugging can occur, and service administrators can see the crash event.

## EXPERIMENT: Enabling the WER user interface

Starting with the initial release of Windows 10, the user interface displayed by WER when an application crashes has been disabled by default. This is primarily because of the introduction of the Restart Manager (part of the Application Recovery and Restart technology). The latter allows applications to register a restart or recovery callback invoked when an application crashes, hangs, or just needs to be restarted for servicing an update. As a result, classic applications that do not register any recovery callback when they encounter an unhandled exception just terminate without displaying any message to the user (but correctly logging the error in the system log). As discussed in this section, WER supports a user interface, which can be enabled by just adding a value in one of the WER keys used for storing settings. For this experiment, you will re-enable the WER UI using the global system key.

From the book's downloadable resources, copy the BuggedApp executable and run it. After pressing a key, the application generates a critical unhandled exception that WER intercepts and reports. In default configurations, no error message is displayed. The process is terminated, an error event is stored in the system log, and the report is generated and sent without any user intervention. Open the Registry Editor (by typing regedit in the Cortana search box) and navigate to the HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting registry key. If the DontShowUrl value does not exist, create it by right-clicking the root key and selecting New, DWORD (32 bit) Value and assign 0 to it.

If you restart the bugged application and press a key, WER displays a user interface similar

to the one shown in Figure 10-39 before terminating the crashing application. You can repeat

the experiment by adding a debugger to the AeDebug key. Running Windbg with the -I switch

performs the registration automatically, as discussed in the “Witnessing a COM-hosted task”

experiment earlier in this chapter.

---

## Kernel-mode (system) crashes

Before discussing how WER is involved when a kernel crashes, we need to introduce how the kernel records crash information. By default, all Windows systems are configured to attempt to record information about the state of the system before the Blue Screen of Death (BSOD) is displayed, and the system is restarted. You can see these settings by opening the System Properties tool in Control Panel (under System and Security, System, Advanced System Settings), clicking the Advanced tab, and then clicking the Settings button under Startup and Recovery. The default settings for a Windows system are shown in Figure 10-40.

![Figure](figures/Winternals7thPt2_page_574_figure_002.png)

FIGURE 10-40 Crash dump settings.

## Crash dump files

Different levels of information can be recorded on a system crash:

- ■ Active memory dump An active memory dump contains all physical memory accessible and
in use by Windows at the time of the crash. This type of dump is a subset of the complete mem-
ory dump; it just filters out pages that are not relevant for troubleshooting problems on the
host machine. This dump type includes memory allocated to user-mode applications and active
pages mapped into the kernel or user space, as well as selected Pagefile-backed Transition,
Standby, and Modified pages such as the memory allocated with VirtualAlloc or page-file
backed sections. Active dumps do not include pages on the free and zeroed lists, the file cache,
guest VM pages, and various other types of memory that are not useful during debugging.
CHAPTER 10    Management, diagnostics, and tracing     543


---

- ■ Complete memory dump A complete memory dump is the largest kernel-mode dump file
that contains all the physical pages accessible by Windows. This type of dump is not fully sup-
ported on all platforms (the active memory dump superseded it). Windows requires that a page
file be at least the size of physical memory plus 1 MB for the header. Device drivers can add up
to 256 MB for secondary crash dump data, so to be safe, it's recommended that you increase
the size of the page file by an additional 256 MB.

■ Kernel memory dump A kernel memory dump includes only the kernel-mode pages allo-
cated by the operating system, the HAL, and device drivers that are present in physical memory
at the time of the crash. This type of dump does not contain pages belonging to user processes.
Because only kernel-mode code can directly cause Windows to crash, however, it's unlikely that
user process pages are necessary to debug a crash. In addition, all data structures relevant for
crash dump analysis—including the list of running processes, the kernel-mode stack of the cur-
rent thread, and list of loaded drivers—are stored in nonpaged memory that saves in a kernel
memory dump. There is no way to predict the size of a kernel memory dump because its size
depends on the amount of kernel-mode memory allocated by the operating system and drivers
present on the machine.

■ Automatic memory dump This is the default setting for both Windows client and server
systems. An automatic memory dump is similar to a kernel memory dump, but it also saves
some metadata of the active user-mode process (at the time of the crash). Furthermore, this
dump type allows better management of the system paging file's size. Windows can set the size
of the paging file to less than the size of RAM but large enough to ensure that a kernel memory
dump can be captured most of the time.

■ Small memory dump A small memory dump, which is typically between 128 KB and 1 MB in
size and is also called a minidump or triage dump, contains the stop code and parameters, the
list of loaded device drivers, the data structures that describe the current process and thread
(called the EPROCESS and ETHREAD—described in Chapter 3 of Part 1), the kernel stack for the
thread that caused the crash, and additional memory considered potentially relevant by crash
dump heuristics, such as the pages referenced by processor registers that contain memory ad-
dresses and secondary dump data added by drivers.
![Figure](figures/Winternals7thPt2_page_575_figure_001.png)

Note Device drivers can register a secondary dump data callback routine by calling KeRegisterBugCheckReasonCallback. The kernel invokes these callbacks after a crash and a callback routine can add additional data to a crash dump file, such as device hardware memory or device information for easier debugging. Up to 256 MB can be added systemwide by all drivers, depending on the space required to store the dump and the size of the file into which the dump is written, and each callback can add at most one-eighth of the available additional space. Once the additional space is consumed, drivers subsequently called are not offered the chance to add data.

The debugger indicates that it has limited information available to it when it loads a minidump, and basic commands like !process, which lists active processes, don't have the data they need. A kernel

---

memory dump includes more information, but switching to a different process's address space mappings won't work because required data isn't in the dump file. While a complete memory dump is a superset of the other options, it has the drawback that its size tracks the amount of physical memory on a system and can therefore become unwieldy. Even though user-mode code and data usually are not used during the analysis of most crashes, the active memory dump overcame the limitation by storing in the dump only the memory that is actually used (excluding physical pages in the free and zeroed list). As a result, it is possible to switch address space in an active memory dump.

An advantage of a minidump is its small size, which makes it convenient for exchange via email, for example. In addition, each crash generates a file in the directory %SystemRoot%\Minidump with a unique file name consisting of the date, the number of milliseconds that have elapsed since the system was started, and a sequence number (for example, 040712-24835-01.dmp). If there's a conflict, the system attempts to create additional unique file names by calling the Windows GetTickCount function to return an updated system tick count, and it also increments the sequence number. By default, Windows saves the last 50 minidumps. The number of minidumps saved is configurable by modifying the MinidumpsCount value under the HKLM\SYSTEM\CurrentControlSet\Control\ CrashControl registry key.

A significant disadvantage is that the limited amount of data stored in the dump can hamper effective analysis. You can also get the advantages of minidumps even when you configure a system to generate kernel, complete, active, or automatic crash dumps by opening the larger Crash with WinDbg and using the .dump /m command to extract a minidump. Note that a minidump is automatically created even if the system is set for full or kernel dumps.

![Figure](figures/Winternals7thPt2_page_576_figure_003.png)

Note You can use the .dump command from within LiveKd to generate a memory image of a live system that you can analyze offline without stopping the system. This approach is useful when a system is exhibiting a problem but is still delivering services, and you want to troubleshoot the problem without interrupting service. To prevent creating crash images that aren't necessarily fully consistent because the contents of different regions of memory reflect different points in time, LiveKd supports the -m flag. The mirror dump option produces a consistent snapshot of kernel-mode memory by leveraging the memory manager's memory mirroring APIs, which give a point-in-time view of the system.

The kernel memory dump option offers a practical middle ground. Because it contains all kernelmode-owned physical memory, it has the same level of analysis-related data as a complete memory dump, but it omits the usually irrelevant user-mode data and code, and therefore can be significantly smaller. As an example, on a system running a 64-bit version of Windows with 4 GB of RAM, a kernel memory dump was 294 MB in size.

When you configure kernel memory dumps, the system checks whether the paging file is large enough, as described earlier. There isn't a reliable way to predict the size of a kernel memory dump. The reason you can't predict the size of a kernel memory dump is that its size depends on the amount of kernel-mode memory in use by the operating system and drivers present on the machine at the time of the crash. Therefore, it is possible that at the time of the crash, the paging file is too small to hold a

CHAPTER 10    Management, diagnostics, and tracing     545


---

kernel dump, in which case the system will switch to generating a minidump. If you want to see the size of a kernel dump on your system, force a manual crash either by configuring the registry option to allow you to initiate a manual system crash from the console (documented at https://docs.microsoft.com/ en-us/windows-hardware/drivers/debugger/forcing-a-system-crash-from-the-keyboard) or by using the Notmy fault tool (https://docs.microsoft.com/en-us/sysinternals/downloads/notmyfault).

The automatic memory dump overcomes this limitation, though. The system will be indeed able

to create a paging file large enough to ensure that a kernel memory dump can be captured most of

the time. If the computer crashes and the paging file is not large enough to capture a kernel memory

dump, Windows increases the size of the paging file to at least the size of the physical RAM installed.

To limit the amount of disk space that is taken up by crash dumps, Windows needs to determine whether it should maintain a copy of the last kernel or complete dump. After reporting the kernel fault (described later), Windows uses the following algorithm to decide whether it should keep the Memory.dmp file. If the system is a server, Windows always stores the dump file. On a Windows client system, only domain-joined machines will always store a crash dump by default. For a non-domainjoined machine, Windows maintains a copy of the crash dump only if there is more than 25 GB of free disk space on the destination volume (4 GB on ARM64, configurable via the HKLM\SYSTEM\ CurrentControlSet\ControlCrashControl\PersistDumpDiskSpaceLimit registry value—that is, the volume where the system is configured to write the Memory.dmp file. If the system, due to disk space constraints, is unable to keep a copy of the crash dump file, an event is written to the System event log indicating that the dump file was deleted, as shown in Figure 10-41. This behavior can be overridden by creating the DWORD registry value HKLM\SYSTEM\CurrentControlSet\ControlCrashControl\ AlwaysKeepMemoryDump and setting it to 1, in which case Windows always keeps a crash dump, regardless of the amount of free disk space.

![Figure](figures/Winternals7thPt2_page_577_figure_003.png)

FIGURE 10-41 Dump file deletion event log entry.

---

EXPERIMENT: Viewing dump file information

Each crash dump file contains a dump header that describes the stop code and its parameters, the type of system the crash occurred on (including version information), and a list of points to the type of kernel-mode structures required during analysis. The dump header also contains the type of crash dump that was written and any information specific to that type of dump. The .dumpdebug debugger command can be used to display the dump header of a crash dump file. For example, the following output is from a crash of a system that was configured for an automatic dump:

0: kb>.dumpDebug ----- 64 bit Kernel Bmp Dump Analysis - Kernel address space is available, User address space may not be available.

DUMP_HEADER64: MajorVersion 0000000f MinorVersion 000047ba DxSecondaryVersion 00000002 DirectoryTableBase 00000000 006d4000 PdmDataBase ffffe800 00000000 PsloadedModulesList ffffe800 5df01070 PsaActiveProcessHead fffffe800 5def0b0 MachineImageType 00008664 NumberProcessors 00000033 BugCheckCode 000000e2 BugCheckParameter1 00000000 00000000 BugCheckParameter2 00000000 00000000 BugCheckParameter3 00000000 00000000 BugCheckParameter4 00000000 00000000 BugDebtorDataBlock fffffe800 5dede5e0 SecondaryDataState 00000000 ProductType 00000001 BitmapSize 9ba00 SuiteMask 00000110 Attributes 00000000

BITProcessorBlock at ffff ff800 5e02da0 3 bitProcessorBlock entries: ffffffff800 5c2f800 ffff8701 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180 9ff3a180

---

```bash
{E83B40D2-B0A0-4842-ABEA71C9E3463D01} - 0x100 bytes
      46 41 43 50 14 01 00 00 06 98 56 52 54 55 41 4C FACP......VIRTUAL
      40 49 43 52 4F 53 46 54 54 01 00 00 00 00 40 53 46 54 MICROSOFT....MSFT
      53 52 41 54 A0 01 00 00 02 02 56 52 54 55 41 4C SRAT......VIRTUAL
      40 49 43 52 4F 53 46 54 54 01 00 00 00 00 00 40 53 46 54 MICROSOFT....MSFT
      57 49 43 54 28 00 00 00 01 02 56 52 54 55 41 4C WAITFOR.....VIRTUAL
      54 49 43 52 4F 53 46 54 54 01 00 00 00 40 53 46 54 MICROSOFT....MSFT
      41 50 49 43 60 00 00 00 04 F7 56 52 54 55 41 4C APIC......VIRTUAL
  ...
```

## Crash dump generation

Phase 1 of the system boot process allows the I/O manager to check the configured crash dump options by reading the HKLM\SYSTEM\CurrentControlSet\Control\CrashControl registry key. If a dump is configured, the I/O manager loads the crash dump driver (Crashdump.sys) and calls its entry point. The entry point transfers back to the I/O manager a table of control functions, which are used by the I/O manager for interacting with the crash dump driver. The I/O manager also initializes the secure encryption needed by the Secure Kernel to store the encrypted pages in the dump. One of the control functions in the table initializes the global crash dump system. It gets the physical sectors (file extent) where the page file is stored and the volume device object associated with it.

The global crash dump initialization function obtains the miniport driver that manages the physical disk in which the page file is stored. It then uses the MntLoadSystemImageEx routine to make a copy of the crash dump driver and the disk miniport driver, giving them their original names prefixed by the dump_ string. Note that this implies also creating a copy of all the drivers imported by the miniport driver, as shown in the Figure 10-42.

![Figure](figures/Winternals7thPt2_page_579_figure_004.png)

FIGURE 10-42 Kernel modules copied for use to generate and write a crash dump file.

548      CHAPTER 10   Management, diagnostics, and tracing


---

The system also queries the DumpFilters value for any filter drivers that are required for writing to the volume, an example being DumpFive.sys, the BitLocker Drive Encryption Crashdump Filter driver. It also collects information related to the components involved with writing a crash dump—including the name of the disk miniport driver, the /O manager structures that are necessary to write the dump, and the map of where the paging file is on disk—and saves two copies of the data in dump-context structures. The system is ready to generate and write a dump using a safe, noncorrupted path.

Indeed, when the system crashes, the crash dump driver (%SystemRoot%\System32\Drivers\ Crashdump.sys) verifies the integrity of the two dump-context structures obtained at boot by performing a memory comparison. If there's not a match, it does not write a crash dump because doing so would likely fail or corrupt the disk. Upon a successful verification match, Crashdump.sys with support from the copied disk miniport driver and any required filter drivers, writes the dump information directly to the sectors on disk occupied by the paging file, bypassing the file system driver and storage driver stack (which might be corrupted or even have caused the crash).

![Figure](figures/Winternals7thPt2_page_580_figure_002.png)

Note Because the page file is opened early during system startup for crash dump use, most crashes that are caused by bugs in system-start driver initialization result in a dump file. Crashes in early Windows boot components such as the HAL or the initialization of boot drivers occur too early for the system to have a page file, so using another computer to debug the startup process is the only way to perform crash analysis in those cases.

During the boot process, the Session Manager (Sms.exe) checks the registry value HKLM\SYSTEM\ CurrentControlSet\Control\Session Manager\MemoryManagement\ExistingPageFiles for a list of existing page files from the previous boot. (See Chapter 5 of Part 1 for more information on page files.) It then cycles through the list, calling the function SmpCheckForCrashDump on each file present, looking to see whether it contains crash dump data. It checks by searching the header at the top of each paging file for the signature PAGESDUMP or PAGERD6U4 on 32-bit or 64-bit systems, respectively. (A match indicates that the paging file contains crash dump information.) If crash dump data is present, the Session Manager then reads a set of crash parameters from the HKLM\SYSTEM\CurrentControlSet\Control\ CrashControl registry key, including the DumpFile value that contains the name of the target dump file (typically %SystemRoot%\Memory.dmp, unless configured otherwise).

Smss exe then checks whether the target dump file is on a different volume than the paging file.


If so, it checks whether the target volume has enough free disk space (the size required for the crash


dump is stored in the dump header of the page file) before truncating the paging file to the size of the

crash data and renaming it to a temporary dump file name. (A new page file will be created later when

the Session Manager calls the NtCreatePagingFile function.) The temporary dump file name takes the

format DUMPxxxx.tmp, where xxxx is the current low-word value of the system's tick count (The system

attempts 100 times to find a nonconflicting value.) After renaming the page file, the system removes

both the hidden and system attributes from the file and sets the appropriate security descriptors to

secure the crash dump.

Next, the Session Manager creates the volatile registry key HKLM\SYSTEM\@CurrentControlSet, Control\CrashControl\MachineCrash and stores the temporary dump file name in the value DumpFile.

CHAPTER 10    Management, diagnostics, and tracing     549


---

It then writes a DWORD to the TempDestination value indicating whether the dump file location is only

a temporary destination. If the paging file is on the same volume as the destination dump file, a tempo rary dump file isn’t used because the paging file is truncated and directly renamed to the target dump

file name. In this case, the DumpFile value will be that of the target dump file, and TempDestination

will be 0.

Later in the boot, Wininit checks for the presence of the MachineCrash key, and if it exists, launches the Windows Fault Reporting process (WerFault.exe) with the -k -c command-line switches (the k flag indicates kernel error reporting, and the c flag indicates that the full or kernel dump should be converted to a minidump). WerFault reads the TempDestination and DumpFile values. If the TempDestination value is set to 1, which indicates a temporary file was used, WerFault moves the temporary file to its target location and secures the target file by allowing only the System account and the local Administrators group access. WerFault then writes the final dump file name to the FinalDumpFileLocation value in the MachineCrash key. These steps are shown in Figure 10-43.

![Figure](figures/Winternals7thPt2_page_581_figure_002.png)

FIGURE 10-43 Crash dump file generation.

To provide more control over where the dump file data is written to—for example, on systems that boot from a SAN or systems with insufficient disk space on the volume where the paging file is configured—Windows also supports the use of a dedicated dump file that is configured in the DedicatedDumpFile and DumpFileSize values under the HKLM\SYSTEM\CurrentControlSet\Control\ CrashControl registry key. When a dedicated dump file is specified, the crash dump driver creates the dump file of the specified size and writes the crash data there instead of to the paging file. If no DumpFileSize value is given, Windows creates a dedicated dump file using the largest file size that would be required to store a complete dump. Windows calculates the required size as the size of the total number of physical pages of memory present in the system plus the size required for the dump header (one page on 32-bit systems, and two pages on 64-bit systems), plus the maximum value for secondary crash dump data, which is 256 MB. If a full or kernel dump is configured but there is not enough space on the target volume to create the dedicated dump file of the required size, the system falls back to writing a minidump.

550      CHAPTER 10  Management, diagnostics, and tracing


---

### Kernel reports

After the WebFault process is started by Wininit and has correctly generated the final dump file,

WinFault generates the report to send to the Microsoft Online Crash Analysis site (or, if configured,

an internal error reporting server). Generating a report for a kernel crash is a procedure that involves

the following:

- 1. If the type of dump generated was not a minidump, it extracts a minidump from the dump file and
stores it in the default location of %SystemRoot%\Minidump, unless otherwise configured through
the MinidumpDir value in the HKLM\SYSTEM\CurrentControlSet\Control\CrashControl key.

2. It writes the name of the minidump files to HKLM\SOFTWARE\Microsoft\Windows\Windows
Error Reporting\KernelFaults\Queue.

3. It adds a command to execute Wrefault.exe (%SystemRoot%\System32\Wrefault.exe) with the
-k -rq flags (the rq flag specifies to use queued reporting mode and that Wrefault should be
restarted) to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce so that Wrefault
is executed during the first user's logon to the system for purposes of actually sending the
error report.
When the WerFault utility executes during logon, as a result of having configured itself to start, it launches itself again using the -k -q flags (the q flag on its own specifies queued reporting mode) and terminates the previous instance. It does this to prevent the Windows shell from waiting on WerFault by returning control to RunOnce as quickly as possible. The newly launched WerFault.exe checks the HKLM\SOFTWARE\Microsoft\Windows\Errors Error Reporting\KernelFaults\Queue key to look for queued reports that may have been added in the previous dump conversion phase. It also checks whether there are previously unsect crash reports from previous sessions. If there are, WerFault.Exe generates two XML-formatted files:

- The first contains a basic description of the system, including the operating system version,

a list of drivers installed on the machine, and the list of devices present in the system.

The second contains metadata used by the OCA service, including the event type that triggered

WER and additional configuration information, such as the system manufacturer.
WerFault then sends a copy of the two XML files and the minidump to Microsoft OCA server, which

forwards the data to a server farm for automated analysis. The server farm's automated analysis uses

the same analysis engine that the Microsoft kernel debuggers use when you load a crash dump file into

them. The analysis generates a bucket ID, which is a signature that identifies a particular crash type.

## Process hang detection

Windows Error reporting is also used when an application hangs and stops work because of some

defect or bug in its code. An immediate effect of an application hanging is that it would not react to

any user interaction. The algorithm used for detecting a hanging application depends on the applica tion type: the Modern application stack detects that a Centennial or UWP application is hung when

a request sent from the HAM (Host Activity Manager) is not processed after a well-defined timeout

(usually 30 seconds); the Task manager detects a hung application when an application does not reply

CHAPTER 10    Management, diagnostics, and tracing     551


---

to the WM_QUIT message; Win32 desktop applications are considered not responding and hung when a foreground window stops to process GDI messages for more than 5 seconds.

Describing all the hung detection algorithms is outside the scope of this book. Instead, we will consider the most likely case of a classical Win32 desktop application that stopped to respond to any user input. The detection starts in the Win32k kernel driver, which, after the 5-second timeout, sends a message to the DwmApiPort ALPC port created by the Desktop Windows Manager (DWM.exe). The DWM processes the message using a complex algorithm that ends up creating a "ghost" window on top of the hanging window. The ghost redraws the window's original content, blurring it out and adding the (Not Responding) string in the title. The ghost window processes GDI messages through an internal message pump routine, which intercepts the close, exit, and activate messages by calling the ReportHang routine exported by the Windows User Mode Crash Reporting DLL (faultrep.dll). The ReportHang function simply builds a WERSVC_REPORT_HDR) message and sends it to the WER service to wait for a reply.

The WER service processes the message and initializes the Hang reporting by reading settings values

from the HKLM\Software\Microsoft\Windows\Windows Error Reporting\Hangs root registry key. In par ticular, the MaxHangedInstances value is used to indicate how many hanging reports can be generated

in the same time (the default number is eight if the value does not exist), while the TerminationTimeout

value specifies the time that needs to pass after WER has tried to terminate the hanging process before

considering the entire system to be in hanging situation (10 seconds by default). This situation can happen

for various reasons—for example, an application has an active pending IRP that is never completed by

a kernel driver. The WER service opens the hanging process and obtains its token, and some other basic

information. It then creates a shared memory section object to store them (similar to user application

crashes; in this case, the shared section has a name: Global\<Random GUID>).

A WerFault process is spawned in a suspended state using the faulting process's token and the -h command-line switch (which is used to specify to generate a report for a hanging process). Unlike with user application crashes, a snapshot of the hanging process is taken from the WER service using a full SYSTEM token by invoking the the PssNICaptureSnapshot API exported in Ntidil. The snapshot's handle is duplicated in the suspended WerFault process, which is resumed after the snapshot has been successfully acquired. When the WerFault starts, it signals an event indicating that the report generation has started. From this stage, the original process can be terminated. Information for the report is grabbed from the cloned process.

The report for a hanging process is similar to the one acquired for a crashing process: The WerFault process starts by querying the value of the Debugger registry value located in the global HKLM\ Software\Microsoft\Windows\Windows Error Reporting\Hangs root registry key, if there is a valid debugger; it is launched and attached to the original hanging process. In case the Disable registry value is set to 1, the procedure is aborted and the WerFault process exits without generating any report. Otherwise, WerFault opens the shared memory section, validates it, and grabs all the information previously saved by the WER service. The report is initialized by using the WerReportCreate function exported in WER.dll and used also for crashing processes. The dialog box for a hanging process (shown in Figure 10-44) is always displayed independently on the WER configuration. Finally, the WerReportSubmit function (exported in WER.dll) is used to generate all the files for the report (including the minidump file) similarly to user applications crashes (see the "Crash report generation" section earlier in this chapter). The report is finally sent to the Online Crash Analysis server.

---

FIGURE 10-44 The Windows Error Reporting dialog box for hanging applications.

After the report generation is started and the WERSVC_RING_REPORTING_STARTED message is returned to DWM, WER kills the hanging process using the TerminateProcess API. If the process is not terminated in an expected time frame (generally 10 seconds, but customizable through the TerminationTimeout setting as explained earlier), the WER service relaunches another WERFault instance running under a full SYSTEM token and waits another longer timeout (usually 60 seconds but customizable through the LongTerminationTimeout setting). If the process is not terminated even by the end of the longer timeout, WER has no other chances than to write an ETW event on the Application event log, reporting the impossibility to terminate the process. The ETW event is shown in Figure 10-45. Note that the event description is misleading because WER hasn't been able to terminate the hanging application.

FIGURE 10-45 The Application log for a nonterminating hanging application.

CHAPTER 10   Management, diagnostics, and tracing      553


---

Global flags

Windows has a set of flags stored in two systemwide global variables named NLGlobalFlag and NLGlobalFlag2 that enable various internal debugging, tracing, and validation support in the operating system. The two system variables are initialized from the registry key HKLM\SYSTEM\ CurrentControlSet\Control\Session Manager in the values GlobalFlag and GlobalFlag2 at system boot time (phase 0 of the NT kernel initialization). By default, both registry values are 0, so it's likely that on your systems, you're not using any global flags. In addition, each image has a set of global flags that also turn on internal tracing and validation code (although the bit layout of these flags is slightly different from the systemwide global flags).

Fortunately, the debugging tools contain a utility named Gflags.exe that you can use to view and

change the system global flags (either in the registry or in the running system) as well as image global

flags. Gflags has both a command-line and a GUI interface. T o see the command-line flags, type


gflags /?. If you run the utility without any switches, the dialog box shown in Figure 10-46 is displayed.

![Figure](figures/Winternals7thPt2_page_585_figure_003.png)

FIGURE 10-46 Setting system debugging options with GFlags.

---

Flags belonging to the Windows Global flags variables can be split in different categories:

- ■ Kernel flags are processed directly by various components of the NT kernel (the heap manager,
exceptions, interrupts handlers, and so on).
■ User flags are processed by components running in user-mode applications (usually Ntdll).
■ Boot-only flags are processed only when the system is starting.
■ Per-image file global flags (which have a slightly different meaning than the others) are pro-
cessed by the loader, WER, and some other user-mode components, depending on the user-
mode process context in which they are running.
The names of the group pages shown by the GFlags tool is a little misleading. Kernel, boot-only, and user flags are mixed together in each page. The main difference is that the System Registry page allows the user to set global flags on the GlobalFlag and GlobalFlag2 registry values, parsed at system boot time. This implies that eventual new flags will be enabled only after the system is rebooted. The Kernel Flags page, despite its name, does not allow kernel flags to be applied on the fly to a live system. Only certain user-mode flags can be set or removed (the enable page heap flag is a good example) without requiring a system reboot: the GFlags tool sets those flags using the NTSeSystemInformation native API (with the SystemFlagsInformation information class). Only user-mode flags can be set in that way.

## EXPERIMENT: Viewing and setting global flags

You can use the lgflag kernel debugger command to view and set the state of the NTGlobalFlag kernel variable. The lgflag command lists all the flags that are enabled. You can use lgflag -t to get the entire list of supported global flags. At the time of this writing, the lgflag extension has not been updated to display the content of the NTGlobalFlag2 variable.

The Image File page requires you to fill in the file name of an executable image. Use this option

to change a set of global flags that apply to an individual image (rather than to the whole system).

The page is shown in Figure 10-47. Notice that the flags are different from the operating system ones

shown in Figure 10-46. Most of the flags and the setting available in the Image File and Silent Process

Exit pages are applied by storing new values in a subkey with the same name as the image file (that is,

notepad.exe for the case shown in Figure 10-47) under the HKLM\SOFTWARE\Microsoft\Windows NT\ CurrentVersion\Image File Execution Options registry key (also known as the IFO key). In particular,

the GlobalFlag (and GlobalFlag2) value represents a bitmask of all the available per-image global flags.

---

![Figure](figures/Winternals7thPt2_page_587_figure_000.png)

FIGURE 10-47 Setting per-image global flags with GFlags.

When the loader initializes a new process previously created and loads all the dependent librar ies of the main base executable (see Chapter 3 of Part 1 for more details about the birth of a process),

the system processes the per-image global flags. The LdrpInitializeExecutionOptions internal function

opens the IFEO key based on the name of the base image and parses all the per-image settings and

flags. In particular, after the per-image global flags are retrieved from the registry, they are stored in

the NTGlobalFlag (and NTGlobalFlag2) field of the process PEB. In this way, they can be easily accessed

by any image mapped in the process (including Ntll).

Most of the available global flags are documented at https://docs.microsoft.com/en-us/ windows-hardware/drivers/debugger/gflags-flag-table.

## EXPERIMENT: Troubleshooting Windows loader issues

In the "Watching the image loader" experiment in Chapter 3 of Part 1, you used the GFlags tool to display the Windows loader runtime information. That information can be useful for understanding why an application does not start at all (without returning any useful error information). You can retry the same experiment on mspaint.exe by renaming the Msftedit.dll file (the Rich Text Edit Control library) located in %SystemRoot%\system32. Indeed, Paint depends on that DLL indirectly. The Msftedit library is loaded dynamically by MSTCF.dll. (It is not statically

---

linked in the Paint executable.) Open an administrative command prompt window and type the following commands:

```bash
cd /c:/windows/system32
  takeown /msftedit.dll
  icacls /msftedit.dll /grant Administrators:
  rcm /msftedit.dll msftedit.disabled
```

Then enable the loader snaps using the Gflags tool, as specified in the "Watching the image

loader" experiment. If you start mpsnait.exe using Windbg, the loader snaps would be able to

highlight the problem almost immediately, returning the following text:

```bash
142c12e18 0 0050678 - LdrpInitializeNode - INFO: Calling init routine 00007FFC79258820 for
DLL C:\Windows\System32\MSFC3\DL142c133c 0 0229625 - LdrpResolveDllName - ENTER: DLL
name : \MSFTEDIT.DLL
142c133c 0 0229625 - LdrpResolveDllName - RETURN: Status: 0xc000135
142c133c 0 0229625 - LdrpResolveDllName - ENTER: DLL name: C:\Program Files\Debugging Tools
for Windows (x64)\MSFTEDIT.DLL
142c133c 0 0229625 - LdrpResolveDllName - RETURN: Status: 0xc000135
142c133c 0 0229625 - LdrpResolveDllName - ENTER: DLL name: C:\Windows\system32\MSFTEDIT.DLL
142c133c 0 0229625 - LdrpResolveDllName - RETURN: Status: 0xc000135
C:\Users\testAppData\Local\Microsoft\WindowsApps\MSFTEDIT.DLL
142c133c 0 0229625 - LdrpResolveDllName - RETURN: Status: 0xc000135
142c133c 0 0229625 - LdrpSearchPath - RETURN: Status: 0xc000135
142c133c 0 0229625 - LdrpProcessWork - ERROR: Unable to load DLL: "\MSFTEDIT.DLL", Parent
Module: ("null"), Status: 0xc0000135
142c133c 0 0229625 - LdrpLoadDllInternal - RETURN: Status: 0xc000135
142c133c 0 0229625 - LdrpLoadDll - RETURN: Status: 0xc000135
```

## Kernel shims

New releases of the Windows operating system can sometime bring issues with old drivers, which

can have difficulties in operating in the new environment, producing system hangs or blue screens of

death. To overcome the problem, Windows 8.1 introduced a Kernel Shim engine that's able to dynami cally modify old drivers, which can continue to run in the new OS release. The Kernel Shim engine is

implemented mainly in the NT kernel. Driver's shims are registered through the Windows Registry and

the Shim Database file. Drivers' shims are provided by shim drivers. A shim driver uses the exported KsEregister/ShimEx API to register a shim that can be applied to target drivers that need it. The Kernel

Shim engine supports mainly two kinds of shims applied to devices or drivers.

### Shim engine initialization

In early OS boot stages, the Windows Loader, while loading all the boot-loaded drivers, reads and maps the driver compatibility database file, located in %SystemRoot%\apppath\Drvmain.sdb (and, if it exists, also in the Drvpatch.sdb file). In phase 1 of the NT kernel initialization, the I/O manager starts the two phases of the Kernel Shell engine initialization. The NT kernel copies the binary content of

CHAPTER 10    Management, diagnostics, and tracing     557


---

the database file(s) in a global buffer allocated from the paged pool (pointed by the internal global KepShimDB variable). It then checks whether Kernel Shims are globally disabled. In case the system has booted in Safe or WinPE mode, or in case Driver verifier is enabled, the shim engine wouldn't be enabled. The Kernel Shim engine is controllable also using system policies or through the HKLM\ SystemCurrentControlSet(ControlCompatibility)DisableFlags registry value. The NT kernel then gathers low-level system information needed when applying device shims, like the BIOS information and OEM ID, by checking the System Fixed ACPI Descriptor Table (FADT). The shim engine registers the first built-in shim provider, named DriverScope, using the KseRegisterShimEx API. Built-in shims provided by Windows are listed in Table 10-21. Some of them are indeed implemented in the NT kernel directly and not in any external driver. DriverScope is the only shim registered in phase 0.

TABLE 10-21 Windows built-in kernel shims

<table><tr><td>Shim Name</td><td>GUID</td><td>Purpose</td><td>Module</td></tr><tr><td>DriverScope</td><td>(BC04AB4A5-EA7E-4A11-A7BB-977615F4CAAE)</td><td>The driver scope shim is used to collect health ETW events for a target driver. Its hooks do nothing other than writing an ETW event before or after calling the original nonshimmed callbacks.</td><td>NT kernel</td></tr><tr><td>Version Lie</td><td>(3E28B2D1-E633-408C-8EB9-2AA64647ECC3) (7) (4771255-BD93-43FC-9248-B9A83710066) (8) (21C4FB58-D477-4839-A7EA-AD6918BC518) (8.1)</td><td>The version lie shim is available for Windows 7, 8, and 8.1. The shim communicates a previous version of the OS when required by a driver in which it is applied.</td><td>NT kernel</td></tr><tr><td>SkipDriverUnload</td><td>(3E8C2C6A-34E2-4DE6-8A1E-9692DDE3361B)</td><td>The shim replaces the driver&#x27;s unload routine with one that doesn&#x27;t do anything except logging an ETW event.</td><td>NT kernel</td></tr><tr><td>ZeroPool</td><td>(688A7429-C430-4682-B55F-FD1A7B55465)</td><td>Replace the ExAllocatePool API with a function that allocates the pool memory and zeroes it out.</td><td>NT kernel</td></tr><tr><td>ClearPCIDBits</td><td>(84678D7D-8D3E-46C9-923B-857334838083)</td><td>Clear the PCID bits when some antivirus drivers are mapping physical memory referred by CR3.</td><td>NT kernel</td></tr><tr><td>Kaspersky</td><td>(84678D7DF-CC3E-46C9-923B-857334838083)</td><td>Shim created for specific Kaspersky filter drivers for making the real value of the used malware registry value, which could have caused bug checks on old versions of the antivirus.</td><td>NT kernel</td></tr><tr><td>Mempcy</td><td>(8A2517C1-35D6-4CA8-9EC8-9BA12762891B)</td><td>Provides a safer (but slower) memory copy implementation that always zeroes out the destination buffer and can be used with device memory.</td><td>NT kernel</td></tr><tr><td>KernelPadSectionsOverride</td><td>(4E55C0DB-7D3D-43F2-9723-8A9C7FD939D)</td><td>Prevents discardable sections of any kernel module to be freed by the memory manager and blocks the loading of the target driver (where the shim is applied).</td><td>NT kernel</td></tr><tr><td>NDIS Shim</td><td>(49691313-1862-4e75-8c2a-2dd72928eb5)</td><td>NDIS version compatibility shim (returns 6.40 where applied to a driver).</td><td>Ndis.sys</td></tr><tr><td>SrbShim</td><td>(434ABAFD-08FA-4c3d-A8D8-D09A88E2AB17)</td><td>SCSI Request Block compatibility shim that intercepts the IOCTL_STORAGE_QUERY_PROPERTY.</td><td>Storport.sys</td></tr></table>


---

<table><tr><td>Shim Name</td><td>GUID</td><td>Purpose</td><td>Module</td></tr><tr><td>DeviceIdShim</td><td>{0332ec62-865a-a4a9-848f-cda6e855f423}</td><td>Compatibility shim for RAID devices.</td><td>Starport.sys</td></tr><tr><td>ATADeviceIdShim</td><td>{26665d75-2158-4eb-a959-c917d3a04de}</td><td>Compatibility shim for serial ATA devices.</td><td>Starport.sys</td></tr><tr><td>Bluetooth Filter Power shim</td><td>{16AD90D4D-C144-4E9D-AOCF-AE5FC801EBD}</td><td>Compatibility shim for Bluetooth filter drivers.</td><td>Bthport.sys</td></tr><tr><td>UsbShim</td><td>{ffd8df62e-49d4-4fc7-8a68-b1ff865a706b}</td><td>Compatibility shim for old Conexant USB modem.</td><td>Usbd.sys</td></tr><tr><td>Nokia Usber Filter Shim</td><td>{17DB0697-651F-4ECB-B893-BEC8050F3BD7}</td><td>Compatibility shim for Nokia Usber filter drivers (used by Nokia PC Suite).</td><td>Usbd.sys</td></tr></table>


A shim is internally represented through the KSE_SHIM data structure (where KSE stands for Kernel

Shim Engine). The data structure includes the GUID, the human-readable name of the shim, and an

array of hook collection (KSE_HOOK_COLLECTION data structures). Driver shims support different

kinds of hooks: hooks on functions exported by the NT kernel, HAL, and by driver libraries, and on

driver's object callback functions. In phase 1 of its initialization, the Shim Engine registers the Microsoft Windows-Kernel-ShimEngine ETW provider (which has the 0f6b2fb94-7b60-4bd4-9766-e82f658df540)

GUID), opens the driver shim database, and initializes the remaining built-in shims implemented in the

NT kernel (refer to Table 10-21).

To register a shim (through KseRegisterShimEx), the NT kernel performs some initial integrity checks on both the KSE_SHIM data structure, and each hook in the collection (all the hooks must reside in the address space of the calling driver). It then allocates and fills a KSE_REGISTERED_SHIM_ENTRY data structure which, as the name implies, represents the registered shim. It contains a reference counter and a pointer back to the driver object (used only in case the shim is not implemented in the NT kernel). The allocated data structure is linked in a global linked list, which keeps track of all the registered shims in the system.

## The shim database

The shim database (SDB) file format was first introduced in the old Windows XP for Application

Compatibility. The initial goal of the file format was to store a binary XML-style database of programs

and drivers that needed some sort of help from the operating system to work correctly. The SDB file

has been adapted to include kernel-mode shims. The file format describes an XML database using tags.

A tag is a 2-byte basic data structure used as unique identifier for entries and attributes in the data base. It is made of a 4-bit type, which identifies the format of the data associated with the tag, and a

12-bit index. Each tag indicates the data type, size, and interpretation that follows the tag itself. An SDB

file has a 12-byte header and a set of tags. The set of tags usually defines three main blocks in the shim

database file:

- ■ The INDEX block contains index tags that serve to fast-index elements in the database. Indexes
in the INDEX block are stored in increasing order. Therefore, searching an element in the index-
es is a fast operation (using a binary search algorithm). For the Kernel Shim engine, the elements
are stored in the INDEXES block using an 8-byte key derived from the shim name.
---

- ■ The DATABASE block contains top-level tags describing shims, drivers, devices, and executables.
Each top-level tag contains children tags describing properties or inner blocks belonging to the
root entity.

■ The STRING TABLE block contains strings that are referenced by lower-level tags in the
DATABASE block. Tags in the DATABASE block usually do not directly describe a string but
instead contain a reference to a tag (called STRINGREF) describing a string located in the string
table. This allows databases that contain a lot of common strings to be small in size.
Microsoft has partially documented the SDB file format and the APIs used to read and write it at

https://docs.microsoft.com/en-us/windows/win32/devnotes/application-compatibility-database. All the

SDB APIs are implemented in the Application Compatibility Client Library (apphelp.dll).

## Driver shims

The NT memory manager decides whether to apply a shim to a kernel driver at its loading time, using the KseDriverLoadImage function (boot-loaded drivers are processed by the I/O manager, as discussed in Chapter 12). The routine is called at the correct time of a kernel-module life cycle, before either Driver Verifier, Import Optimization, or Kernel Patch protection are applied to it. (This is important; otherwise, the system would bugcheck.) A list of the current shimmed kernel modules is stored in a global variable. The KepGetShimsForDriver routine checks whether a module in the list with the same base address as the one being loaded is currently present. If so, it means that the target module has already been shimmed, so the procedure is aborted. Otherwise, to determine whether the new module should be shimmed, the routine checks two different sources:

- ■ Queries the "Shims" multistring value from a registry key named as the module being loaded
and located in the HKLM\System\CurrentControlSet\Compatibility\Driver root key. The
registry value contains an array of shims' names that would be applied to the target module.

■ In case the registry value for a target module does not exist, parses the driver compatibility da-
tabase file, looking for a KDRIVER tag (indexed by the INDEX block), which has the same name
as the module being loaded. If a driver is found in the SDB file, the NT kernel performs a com-
parison of the driver version (TAG_SOURCE_OS stored in the KDRIVER root tag), file name, and
path (if the relative tags exist in the SDB), and of the low-level system information gathered at
engine initialization time (to determine if the driver is compatible with the system). In case any
of the information does not match, the driver is skipped, and no shims are applied. Otherwise,
the shim names list is grabbed from the KSHIM_REF lower-level tags (which is part of the root
KDRIVER). The tags are reference to the KSHIMs located in the SDB database block.
If one of the two sources yields one or more shims names to be applied to the target driver, the SDB file is parsed again with the goal to validate that a valid KSHIM descriptor exists. If there are no tags related to the specified shim name (which means that no shim descriptor exists in the database), the procedure is interrupted (this prevents an administrator from applying random non-Microsoft shims to a driver). Otherwise, an array of KSE_SHIM_INFO data structure is returned to KseGetShimsForDriver.

---

The next step is to determine if the shims described by their descriptors have been registered in the system. To do this, the Shim engine searches into the global linked list of registered shims (filled every time a new shim is registered, as explained previously in the "Shim Engine initialization" section). If a shim is not registered, the shim engine tries to load the driver that provides it (its name is stored in the MODULE child tag of the root KSHIM entry) and tries again. When a shim is applied for the first time, the Shim engine resolves the pointers of all the hooks described by the KSE_HOOK_COLLECTION data structures' array belonging to the registered shim (KSE_SHIM data structure). The shim engine allocates and fills a KSE_SHIMMED_MODULE data structure representing the target module to be shimmed (which includes the base address) and adds it to the global list checked in the beginning.

At this stage, the shim engine applies the shim to the target module using the internal KeepApplyShimsToDriver routine. The latter cycles between each hook described by the KSE_HOOK_ COLLECTION array and patches the import address table (IAT) of the target module, replacing the original address of the hooked functions with the new ones (described by the hook collection). Note that the driver's object callback functions (IRP handlers) are not processed at this stage. They are modified later by the I/O manager before the DriverInit routine of the target driver is called. The original driver's IRP callback routines are saved in the Driver Extension of the target driver. In that way, the hooked functions have a simple way to call back into the original ones when needed.

## EXPERIMENT: Witnessing kernel shims

While the official Microsoft Application Compatibility Toolkit distributed with the Windows Assessment and Deployment Kit allows you to open, modify, and create shim database files, it does not work with system database files (identified through to their internal GUIDs), so it won't be able to parse all the kernel shims that are described by the drvmain.sdb database. Multiple third-party SDB parsers exist. One in particular, called SDB explorer, is freely downloadable from https://ericzimmerman.github.io/.

In this experiment, you get a peek at the drvim system database file and apply a kernel shim

to a test driver, ShimDriver, which is available in this book's downloadable resources. For this experi ment, you need to enable test signing (the ShimDriver is signed with a test self-signed certificate).

1. Open an administrative command prompt and type the following command:

- bcedit /set testsigning on

2. Restart your computer, download SDB Explorer from its website, run it, and open the
drvmin.sdb database located in %SystemRoot%\appatch.

3. From the SDB Explorer main window, you can explore the entire database file, orga-
nized in three main blocks: Indexes, Databases, and String table. Expand the DATABASES
root block and scroll down until you can see the list of KSHMs (they should be located
after the KDEVCs). You should see a window similar to the following:
---

![Figure](figures/Winternals7thPt2_page_593_figure_000.png)

4. You will apply one of the Version lie shims to our test driver. First, you should copy the ShimDriver to the %SystemRoot%\System32\Drivers. Then you should install it by typing the following command in the administrative command prompt (it is assumed that your system is 64-bit):

```bash
sc create ShmDriver type: kernel start= demand error= normal.binPath= c:\
Windows\System32\ShmDriver64.sys
```

5. Before starting the test driver, you should download and run the DebugView tool,

available in the Sysinternals website (https://docs.microsoft.com/en-us/sysinternals/

downloads/debugview). This is necessary because ShimDriver prints some debug messages.

6. Start the ShimDriver with the following command:

```bash
sc start_shimdriver
```

7. Check the output of the DebugView tool. You should see messages like the one shown in the following figure. What you see depends on the Windows version in which you run the driver. In the example, we run the driver on an insider release version of Windows Server 2022:

![Figure](figures/Winternals7thPt2_page_593_figure_007.png)

562     CHAPTER 10 Management, diagnostics, and tracing


---

8. Now you should stop the driver and enable one of the shims present in the SDB database. In this example, you will start with one of the version lie shims. Stop the target driver and install the shim using the following commands (where ShimDriver64.sys is the driver's file name installed with the previous step):

```bash
sc stop shimdriver
reg add "H-KLM\System\CurrentControlSet\Control\Compatibility\Driver\
    \ShimDriver64.sys" / v Shims /t REG_MULTI_SZ /d
Win8WinVersion1e /f reg:64
```

9. The last command adds the Windows 8.1 version lie shim, but you can freely choose other versions.

10. Now, if you restart the driver, you will see different messages printed by the DebugView

tool, as shown in the following figure:

![Figure](figures/Winternals7thPt2_page_594_figure_004.png)

11. This is because the shim engine has correctly applied the hooks on the NT APIs used for retrieving OS version information (the driver is able to detect the shim, too). You should be able to repeat the experiment using other shims, like the SkipDriverUnload or the KernelPadSectionsOveride, which will zero out the driver unload routine or prevent the target driver from loading, as shown in the following figure:

![Figure](figures/Winternals7thPt2_page_594_figure_006.png)

---

## Device shims

Unlike Driver shims, shims applied to Device objects are loaded and applied on demand. The NT kernel exports the KseQueryDeviceData function, which allows drivers to check whether a shim needs to be applied to a device object. (Note also that the KseQueryDeviceFlags function is exported. The API is just a subset of the first one, though.) Querying for device shims is also possible for user-mode applications through the NTQuerySystemInformation API used with the SystemDeviceDataInformation information class. Device shims are always stored in three different locations, consulted in the following order:

- 1. In the HKLM\System{CurrentControlSet}Control\Compatibility\Device root registry key, using
a key named as the PNP hardware ID of the device, replacing the \ character with a ! (with the
goal to not confuse the registry). Values in the device key specify the device's shimmed data
being queried (usually flags for a certain device class).

2. In the kernel shim cache, The Kernel Shim engine implements a shim cache (exposed through
the KSE_CACHE data structure) with the goal of speeding up searches for device flags and data.

3. In the Shim database file, using the KDEVICE root tag. The root tag, among many others (like
device description, manufacturer name, GUID and so on), includes the child NAME tag contain-
ing a string composed as follows: <DataName:HardwareID>. The KFLAG or KDATA children tags
include the value for the device's shimmed data.
If the device shim is not present in the cache but just in the SDB file, it is always added. In that way, future interrogation would be faster and will not require any access to the Shim database file.

## Conclusion

In this chapter, we have described the most important features of the Windows operating system that provide management facilities, like the Windows Registry, user-mode services, task scheduling, UBPM, and Windows Management Instrumentation (WMI). Furthermore, we have discussed how Event Tracing for Windows (ETW), DTrace, Windows Error Reporting (WER), and Global Flags (GFlags) provide the services that allow users to better trace and diagnose issues arising from any component of the OS or user-mode applications. The chapter concluded with a peek at the Kernel Shrim engine, which helps the system apply compatibility strategies and correctly execute old components that have been designed for older versions of the operating system.

The next chapter delves into the different file systems available in Windows and with the global caching available for speeding up file and data access.

---

CHAPTER 11

