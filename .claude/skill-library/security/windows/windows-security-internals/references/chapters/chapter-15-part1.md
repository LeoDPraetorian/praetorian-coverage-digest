## 15

## NEGOTIATE AUTHENTICATION AND OTHER SECURITY PACKAGES

![Figure](figures/WindowsSecurityInternals_page_529_figure_002.png)

The two previous chapters covered the two main network authentication protocols in Windows, NTLM and Kerberos. However,

Windows supports several more packages for performing authentication. In this chapter, we'll briefly cover some of these other security packages.

I'll begin by providing more detail about how applications and security packages can use buffers to pass data back and forth using the SSPI APIs. This will help you understand some of the packages' quirks. Then we'll examine the Negotiate security package, as well as the less common secure channel and CredSSP packages. I'll give a quick overview of some additional configuration options you have when setting up a network authentication context and finish up with a description of what happens when you want to use network authentication inside a process with a lowbox token.

---

## Security Buffers

So far, I've implied that using the SSI APIs is simple: you generate a client authentication token, pass it to the server application, update the server authentication context, receive a token in response, and repeat the process until the authentication is complete. However, because of the complexity of the supported network authentication protocols, these APIs can accept and return more than just an authentication token.

The authentication context, encryption, and signature APIs accept arrays of generic security buffer structures as parameters. This security buffer structure, called SecBuffer in the native SDK, is wrapped by the SecurityBuffer class in the PowerShell module. Each security buffer structure contains a field that determines what type of data the buffer represents and a sized memory buffer for the contents. You can create a buffer using the New-IsaSecurityBuffer PowerShell command, specifying the type and contents of the buffer:

```bash
PS> $buf = New-LsaSecurityBuffer -Type Data -Byte @(0, 1, 2, 3)
```

You can specify either a byte array or a string when initializing the data.


You also specify a type for the buffer. The following is a short list of the


most important buffer types you'll encounter:

Empty: Contains no data; sometimes used as a placeholder for a return value

Data — Contains initialized data; used to pass and return data, such as a message to encrypt

Token Contains a token; used to pass and return authentication tokens and signatures

PkgParams Contains additional configuration parameters for the security package

StreamHeader  Contains the header of a streaming protocol

StreamTrailer  Contains the trailer of a streaming protocol

Stream   Contains the data of a streaming protocol

Extra   Contains extra data generated by the security package

ChannelBindings     Contains the channel binding data

You can use security buffers as either input or output, depending on the security package's requirements and the API used. If you want to define an output-only buffer, you can use the Size parameter when creating the buffer:

```bash
PS> $buf = New-LsaSecurityBuffer -Type Data -Size 1000
```

Sometimes you may want to pass an initialized buffer whose contents the package shouldn't modify. To indicate this, the APIs specify two additional flags you can add to the type:

500 Chapter 15

---

ReadOnly The buffer is read-only but is not part of the signature.

ReadOnlyWithChecksum The buffer is read-only and should be part of the signature.

You specify these additional flags using the ReadOnly或 ReadOnlyWith checksum parameter when creating a buffer, as in the following example:

```bash
PS> $buf = New-LsaSecurityBuffer -Type Data -Byte @(0, 1, 2, 3) -ReadOnly
```

Whether the difference between the two read-only flags is honored depends on the security package. For example, NTLM ignores the difference and always adds a read-only buffer to the signature, while Kerberos adds the buffer as part of the signature only if the buffer you supply has the ReadOnlyWithChecksum flag.

## Using Buffers with an Authentication Context

The SSPI APIs used by the Update-LsaClientContext and Update-LsaServer

Context PowerShell commands take two lists of security buffers: one to use

as input to the API and one to use as output. You can specify the list of

these buffers using the InputBuffer and OutputBuffer parameters, as shown in

Listing 15-1.

```bash
0 PS> $in_buf = New-LsaSecurityBuffer -Type PkgParams -String "AuthParam"
0 PS> $out_buf = New-LsaSecurityBuffer -Type Data -Size 100
0 PS> Update-LsaClientContext -Client $client -Token $token -InputBuffer $in_buf
-OutputBuffer $out_buf
PS> $out_buf.Type
Extra
PS->ConvertFrom+=LsaSecuizyBuffer $out_buf | Out-HexDump
00 11 22 33
```

Listing 15-1: Using input and output buffers with an authentication context

This listing shows a hypothetical use of input and output buffers during authentication. (You'll see actual examples over the course of this chapter.) This example assumes you've already set up a client authentication context as $client and a server authentication token as $token.

We first create one input buffer of type PkgParams containing a string . The contents of the buffer depend on the package you're using; normally, the API's documentation will tell you what you need to specify. Next, we create an output buffer of type Data , allocating a maximum buffer size of 100 bytes . We then update the client context, passing it the server authentication token and the input and output buffers .

The command will add the token as a Token type buffer to the start of the input list, and will also append any channel bindings specified when creating the context. Therefore, the input buffer list passed in this case would contain the Token buffer followed by the PkgParams buffer. Sometimes

Negotiate Authentication and Other Security Packages   501

---

the package doesn't want you to include the Token buffer; in that case, you can specify the NoToken parameter to exclude it from the input list.

The command also automatically adds the output Token buffer for the new authentication token to the output list. If the API call succeeds, it will assign the contents of this buffer to the context's Token property. It's not normally necessary to exclude that buffer from the output, so the command doesn't give you that option.

After a successful call, we check the output buffer, which has been updated. Certain packages might change an output buffer's type, size, and contents. For instance, the type in this example has been changed from Data to Extra. We can convert the buffer back to a byte array using the ConvertFrom-LsaSecurityBuffer command. Displaying the output shows that the 100-byte buffer we've created now has only 4 valid bytes. The security package initialized these 4 bytes and updated the structure's length accordingly.

## Using Buffers with Signing and Sealing

Using the Buffer parameter, you can specify buffers during signing and sealing operations when calling the get-LsaContextSignature and Test-LsaContext Signature PowerShell commands, as well as Protect-LsaContextMessage and Protect-LsaContextMessage. The underlying APIs take only a single list of buffers to use for both the input and output. In Listing 15-2, we encrypt a buffer containing an additional header.

```bash
PS> $header = New-LsaSecurityBuffer -Type Data -Byte @0, 1, 3, 4) -
-ReadOnlyWithChecksum
PS> $data = New-LsaSecurityBuffer -Type Data -String "HELLO"
PS> $sig = Protect-LsaContextMessage -Context $client -Buffer $header, $data
PS> ConvertFrom-LsaSecurityBuffer -Buffer $header | Out-HexDump
00 01 03 04
PS> ConvertFrom-LsaSecurityBuffer -Buffer $data | Out-HexDump
DS 05 4F 40 22 5A 9F F9 49 66
PS> Unprotect-LsaContextMessage -Context $server -Buffer $header, $data
-Signature $sig
PS> ConvertFrom-LsaSecurityBuffer -Buffer $data -AsString
HELLO
```

Listing 15-2: Encrypting a message with buffers

We first create the header buffer, marking it as read-only with a checksum. By marking it as read-only, we ensure that the contents won't be encrypted but will still be included in the signature. Next, we create the data buffer from a string.

We then pass the buffers to Protect-LSaContextMessage. This command returns the signature for the encryption operation and updates the encrypted data in place. When dumping the buffers, we can see that the header is still unencrypted even though the data buffer has been encrypted.

502      Chapter 15

---

We can decrypt the buffer using Unprotect-LSaContextMessage in a manner similar to how we encrypted the buffer: by passing the buffers and the signature to the command. Once the buffer is decrypted, we can convert it back to a string. If the signature for the buffers isn't valid, the command will throw an error.

Now that you know how to use security buffers for the SSPI APIs, let's look at the Negotiate protocol, which allows Windows to automatically select the best authentication protocol to use based on what credentials are available to the caller.

## The Negotiate Protocol

What happens if you don't know what types of network authentication the server supports? You might first try using Kerberos and then, if it isn't supported, switch to NTLM. But that's not a very efficient use of resources. Also, if Microsoft were to later introduce a new, more secure authentication protocol, you'd have to update your application to support it. The Negotiate protocol solves both problems by allowing a client and server to negotiate the best available network authentication protocol. Microsoft's implementation of Negotiate is based on the Simple and Protected Negotiation Mechanism (SPRENGO) protocol, defined in RFC4178.

To select the Negotiate protocol, use the negotiate package in both the client and the server authentication context. The first token generated by a client authentication context contains a list of the authentication protocols the client supports. In its ASN.1 structure, it can also embed the first authentication token for whichever of the supported authentication protocols the client would prefer to use. For example, it might embed an NTLM NEGOTIATE token. In Listing 15-3, we initialize the Negotiate client authentication context.

```bash
__ PS> $credout = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Outbound
__ PS> $client = New-LsaClientContext -CredHandle $credout
__ PS> Format-LsaAuthToken -Token $client.Token
__  <$PNEGO Init>
__ Mechanism list      :
__  1.3.6.1.4.1.311.2.2.10           - NTLM
__  1.2.840.48018.1.2.2             - Microsoft Kerberos
__  1.2.840.113554.1.2.2             - Kerberos
__  1.3.6.1.4.1.311.2.2.30           - Microsoft Negotiate Extended
__  <$PNEGO Token>
__ <NTLM NEGOTIATE>
Flags: Unicode, Oem, RequestTarget, Signing, LMKey, NTLM,...
Domain: MINERAL
Workstation: GRAPHITE
__ Version: 10.0.18362.15
</$PNEGO Token>
```

Listing 15-3: Initializing the Negotiate client authentication

---

We specify the credentials for using the Negotiate security package ❶ , then continue as normal by creating the context. In the formatted token, we first see SPNEO Init , which indicates that this is an initialization token ❷ . Following the header is the list of supported authentication protocols, or security mechanisms ❸ . The list is sorted in descending order of preference, so in this case, the client prefers NTLM over Kerberos. You won't see Kerberos in the list unless you're on a domain-mounted system.

You might notice the mechanism list contains two types of Kerberos: The presence of the Microsoft Kerberos identifier is due to a bug in Windows 2000: the value 113554 in the identifier, or 0x1BB92 in hexadecimal, was truncated to 16 bits, resulting in the value 0x0BB92, or 48018. Microsoft has left this mistake for backward compatibility reasons, and the two values represent the same Kerberos authentication protocol. Microsoft also defines an extended negotiation protocol, the fourth mechanism in this list, but we won't discuss it here.

Following the list of supported protocols is an authentication token . In this case, the client has chosen to send the initial NTLM Negotiate token .

The server authentication context can select the most appropriate authentication protocol it supports. Most commonly, it will use the protocol that is the client's preferred choice, determined by the ordering of the list of supported authentication protocols. However, it can also ignore the client’s preference and request a different authentication protocol if desired. It sends the selected authentication protocol and any further authentication tokens to the client. This authentication exchange process continues until either an error occurs or the process is complete. Listing 15-4 shows how the server responds to the client's request.

```bash
PS> $credin = New-LsaCredentialHandle -Package "Negotiate" -UseFlag Inbound
PS> $server = New-LsaServerContext -CredHandle $credin
PS> Update-LsaServerContext -Server $server -Token $client.Token
PS> Format-ListAuthToken -Token $server.Token
<SPNEGO Response>
Supported Mech      : 1.3.6.1.4.1.311.2.2.10 - NTLM
State           : Incomplete
<SPNEGO Token>
<NTLM CHALLENGE>
Flags        : Unicode, RequestTarget, Signing, NTLM, LocalCall, AlwaysSign,... -
--snip--
```

Listing 15-4: Continuing the Negotiate authentication on the server

We first pass the client authentication token to the server authentication context that we create. In the formatted output, we can see that it's an


SPNEGO Response, and that the server has opted to use NTLM. The response has a State flag, which indicates that the negotiation is currently incomplete. Following that is the authentication token, which, as expected, is now an NTLM CHALLENGE token.

In Listing 15-5, we complete the authentication.

504 Chapter 15

---

```bash
PS> Update-LsaClientContext -Client $client -Token $server.Token
  PS> Format-LsaAuthToken -Token $client.Token
  <SPNEGO Response>
  State               : Incomplete
  <SPNEGO Token>
  © NTLM AUTHENTICATE>
  Flags    : Unicode, RequestTarget, Signing, NTLM, LocalCall, AlwaysSign,...
  --snlp!
  PS> Update-LsaServerContext -Server $server -Token $client.Token
  PS> Format-LsaAuthToken -Token $server.Token
  <SPNEGO Response>
  State               : Completed
  PS> Update-LsaClientContext -Client $client -Token $server.Token
  PS> $client.PackageName
    NTLM
```

Listing 15-5: Completing the Negotiate authentication

The next client authentication token sent is the NTLM AUTHENTICATE token. Note that the supported authentication protocol field is not present. This is only required in the initial server token, and it's omitted from subsequent tokens.

In normal NTLM authentication, the authentication would typically complete at this point. However, in Negotiate authentication, the client's state is considered Incomplete until we generate a final server token and update the client with this token, which then marks the state as Completed . We can then query the final package using the PackageName property in which shows that we negotiated NTLM.

To negotiate the use of Kerberos, the protocol acts in a similar manner. But as Kerberos needs an SPN to function, you must specify the target name using the Target parameter when creating the client authentication context; otherwise, the protocol will select NTLM. The output of the Kerberos authentication will replace the NTLM tokens with Kerberos AP-REQ and AP-REP tokens.

Now that we've covered the Negotiate protocol, let's discuss a few less common security packages that you might encounter during an analysis of a Windows system.

## Less Common Security Packages

We've covered the three main security packages you're most likely to use on Windows: NTLM, Kerberos, and Negotiate. But there are a few other security packages that have important functions, even if you're less likely to use them directly. We won't spend very much time discussing these, but I'll give you a quick example of each so that you understand their purpose and function.

---

## Secure Channel

Sending sensitive information (like user credentials) unencrypted over the internet is generally considered a bad idea. Several network protocols can encrypt network traffic, but by far the most common is Transport Layer Security (TLS), which was once called Secure Sockets Layer (SSL) and was originally developed by Netscape in the mid-1990s to secure HTTP connections. A variant of TLS, the Datagram Transport Layer Security (DTLS) protocol, can encrypt traffic from unreliable protocols, such as the User Datagram Protocol (UDP).

Secure channel is an implementation of TLS provided as a security package, and you can access it through the Channel package using the same SSPI APIs as for other network authentication protocols. While you can use secure channel as a TLS or DTLS encryption layer for network traffic, you can also use it to provide client authentication facilities to a server through client certificates.

Let's walk through a simple example of how to use the package. Listing 15-6 starts by setting up the client credentials handle and the client authentication context.

```bash
PS> $credout = New-LsaCredentialHandle -Package "Schannel" -UseFlag Outbound
PS> $name = "NotReallyReal.com"
PS> $client = New-LsaClientContext -CredHandle $credout -Target $name
-RequestAttribute ManualCredValidation
PS> Format-LsaAuthToken -Token $client.Token
Schannel Record 0
Type   : Handshake
Version: 3.3
Data    :
        ...... 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  -  0123456789ABCDEDF
----------------------
00000000: 01 00 00 AA 03 03 60 35 C2 44 30 A9 CE C7 88 81  - ......`5_00.....
00000000: EB 67 EC F3 9A E3 FD 71 05 70 6C BB 92 19 31 C9   -g.....q.pl...1..
--snip--
```

Listing 15-6: Setting up the secure channel client authentication context

When setting up the context, you need to specify a target name, which is typically the DNS name of the server. The protocol uses this target name to verify that the server has a valid certificate for that name. TLS connections can also be cached, so the protocol can check whether an existing cache entry exists for the target name. In this case, the name won't matter because we specify the @authored@idiation request attribute, which disables the server certificate checks so that we can use a self-signed certificate for the server.

We then format the authentication token, which displays the TLS protocol’s simple record structure (shown in Figure 15-1).

506   Chapter 15

---

![Figure](figures/WindowsSecurityInternals_page_537_figure_000.png)

Figure 15-1: The TLS record structure

The record structure contains a 5-byte header consisting of a record type, the major and minor versions of the protocol, and a data length. The header is followed by a list of bytes whose interpretation depends on the record type. In Listing 15-6, the type is handshake, a record used during the connection setup to negotiate the encryption protocol to use, exchange certificates, and communicate the encryption keys. Its version is 3.3, which corresponds to TLS 1.2. (The designers of the protocol considered TLS to be a minor addition to SSL 3.0, so they increased only its minor version number.)

In Listing 15-7, we generate an X.509 certificate and finish setting up the server side of the secure channel authentication.

```bash
PS> $store = "cert:UserID:My"~  @PS$cert = Get-ChildItem $store | Where-Object Subject -Match $name~  @PS if ($snull -eq $cert) {~  @PS $cert = New-SelfSignedCertificate -DnsName $name -CertStoreLocation $store~}@PS $server_cred = Get-LsaChannelCredential -Certificate $cert~  @PS $credin = New-LsaCredentialHandle -Package "Schannel" -UseFlag Inbound~-Credential $server_cred~  @PS $server = New-LsaServerContext -CreditHandler $credin~  @PS while((Test-LsaContext $client) and ((Test-LsaContext $server)) {~    Update-LsaServerContext -Server $server -Client $client~    Update-LsaClientContext -Client $client -Server $server~}~  Listing 15-7: Initializing a security channel server context and completing authentication
```

We start by checking whether we have a certificate whose subject name is the DNS name we specified when creating the client authentication context ❶ . PowerShell exposes the system's certificate store via the Cert drive provider. In this case, we check only the current user's personal certificate store for a matching certificate.

If the certificate doesn't already exist, we create a new one using the New-SelfSignedCertificate command with the DNS name as the subject, storing it in the current user's personal store . This certificate isn't trusted for the TLS certificate chain. You could add the new certificate to Cert\ CurrentUserRoot, which would make it trusted; however, it's safer to just disable the certificate checking in the client for this example.

---

To use the certificate for the server, we need to create a set of secure channel credentials, specifying the certificate for use by the server ❸ . Note that the certificate must have an associated private key for the server to use. If you pick a certificate without the private key, this line of code will generate an error. We can use the credentials to create a handle and, from that, the server authentication context.

Finally, we exchange tokens between the server and client authentication context until the authentication completes . Of course, in a real application this process would exchange the tokens over a network connection, but for the sake of simplicity, we ignore the network entirely here.

Before we do anything else, we can inspect the negotiated security information, as shown in Listing 15-8.

```bash
PS> $client.ConnectionInfo
Protocol      Cipher  Hash   Exchange
-------       ---------  ---------        -----------------
TLS1_2_CLIENT AES_256 SHA_384 ECDH_EPHEM
PS> $client.RemoteCertificate
Thumbprint                          Subject
----------------------------- ---------
2A814A450D93FE86BA45C4A1F7046459D75176  CN=NotReallyReal.com
PS> $server.ConnectionInfo
Protocol      Cipher  Hash   Exchange
-------       ---------    ---------        -----------------
TLS1_2_SERVER AES_256 SHA_384 ECDH_EPHEM
```

Listing 15-8: Inspecting the connection information

Note that the ConnectionInfo property returns the negotiated protocol and encryption algorithms. In this case, we've negotiated TLS 1.2 using the AES256 encryption algorithm, SHA384 for integrity, and elliptic curve Diffie-Hellman to exchange an ephemeral encryption key.

We can also query the server's certificate. This should match the one we used in the server's credentials. As we specified manual credential validation, we can check whether the certificate is valid; if we hadn't requested manual validation, the handshake process would have generated an error. Finally, we can also query the server's connection information to doublecheck that it's the same as the client's.

At this point, we've set up the connection, but we have yet to transfer a single byte of user data to the server. Listing 15-9 shows how to encrypt and decrypt application data sent over the network connection.

```bash
© PS$header = New-LsaSecurityBuffer -Type StreamHeader
    -Size $client.StreamHeaderSize
  PS>$data = New-LsaSecurityBuffer -Type Data -Byte 0, 1, 2, 3
  PS$ trailer = New-LsaSecurityBuffer -Type StreamTrailer
    -Size $client.StreamTrailerSize
  PS$empty = New-LsaSecurityBuffer -Empty
  PS>$bufs = $header, $data, $trailer, $empty
```

508    Chapter 15

---

```bash
#> PS> Protect-LsaContextMessage -Context $client -Buffer $bufts -NoSignature
#> $msg = $header, $data, $ trailer | ConvertFrom-LsaSecurityBuffer
#> $msg_token = Get-LsaAuthToken -Context $client -Token $msg
#> PS> Format-LsaAuthToken $msg_token
#> SChannel Record 0
# Type   : ApplicationData
# Version : 3.3
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#               _
#
```

Listing 15-9: Encrypting and decrypting application data

Secure channel requires passing four buffers to the Protect-LSaContext


Message command . The first buffer is for the TLS record header. It needs to be of type StreamHeader and should be of a size queried from the context using the StreamHeaderSize property.

The second buffer is for the data to encrypt and must be of type Data.


There is a maximum allowed size for this buffer, which you can query using the StreamMessageSize property. The maximum size is typically 16KB, so the 4 bytes we use here should fall well within the limit. If the application data to encrypt is larger than the maximum size, you'll need to fragment the data into smaller parts.

The third buffer will contain the stream trailer, which must be of type StreamTrailer and of size StreamTrailerSize. The final buffer is an empty one. The secure channel package doesn't seem to use the buffer to store anything, but you must pass it, or the call will fail.

We can now encrypt the data by passing all four buffers to the Protect-IsaContextMessage command . One important thing to note is that you should also pass the NoSignature parameter. Any generated signature will be part of the generated protocol data, not returned separately, so there is no need for the command to automatically handle the signature.

The result of the encryption is that the header, data, and trailer buffers are populated with the data required to transmit the application data to the server. We need to concatenate the buffers together using the ConvertFrom-TsaSecurityBuffer command ❶ . In this case, we already know that the data generated is a TLS record, so we can use the authentication context commands to inspect its structure. We can see that the record type is now ApplicationData ❶ whereas in Listing 15-6 the record type was

---

Handshake. The use of ApplicationData indicates that this is an encrypted data record.

Now we need to decrypt the data on the server. To do so, we again need four buffers; however, their configuration is slightly different. For decryption, we must place the entire TLS record in the first buffer as a Data type ❸. The next three buffers can be empty; they'll be populated during decryption with the appropriate parts of the message.

We pass the buffers to the Unprotect-LsaContextMessage command, again specifying the NoSignature parameter, as the signature is part of the protocol ❹. When checking the data buffer, which was originally empty, we now find it's populated with the original unencrypted data.

I've made secure channel look easy to use, but it's much more complex than shown here. For example, you'll have to deal with out-of-band alerts, which indicate problems with the connection. I recommend that you use an existing class (such as $151stream_, which comes with .NET) to add TLS support to your application unless there's a niche feature not exposed that you need to use.

By default, the TLS protocol verifies only the server in the secure channel connection, using the X.509 certificate; however, the server can request that the client also present a valid certificate for verification purposes. To require the client to send a certificate, specify the MutualAuth request attriute when creating the server authentication context. By default, secure channel will try to find a suitable certificate for the user on the client, but you can override this search by setting an explicit certificate when generating the client's credentials.

The server can query for the client's certificate using the same

RemoteCertificate property on the server authentication context. Note

that secure channel doesn't validate the contents of the client certificate by default; doing so is up to the server application. The only thing secure channel guarantees is that the client can prove they have the corresponding private key for the certificate. If the server is part of an enterprise network, it's possible to add an identity certificate to Active Directory so that the client certificate can be mapped to a user account and a

Token object can be queried for the user's identity without any further authentication.

