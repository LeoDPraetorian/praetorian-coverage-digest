## []{#ch23.xhtml_page_217 .pagebreak}**23  Game Boy Via ROM** {#ch23.xhtml_ch23 .h2a}

Nintendo's Game Boy, internally known as the Dot Matrix Game (DMG), did
not feature the CIC protection chip that we'll discuss in [Chapter
25](#ch25.xhtml_ch25). Instead of a lockout chip, the game cartridge is
required to contain Nintendo's logo.

This is enforced by a first-stage boot ROM that compares its own copy of
the logo to one in the cartridge. If the logos match, a short animation
and sound are presented before the ROM disables itself and jumps into
the game cartridge. In this chapter, we'll take the last chapter's
theory and use it to rip out the ROM contents and make our own
disassembly.

Perhaps you've already realized that anyone can put any logo into a
cartridge, and that the logo comparison is not a technical challenge
when making an unlicensed game. The enforcement mechanism was not
technical; rather, it was Nintendo's legal counsel, who would gleefully
sue the living hell out of anyone who used their trademark without
permission. And if you, dear reader, happen to be one of Nintendo's
lawyers, please don't sue me.

Neviksti (2005) describes an extraction of the ROM. I repeated this in
my own lab to produce the ROM photograph in [Figure
23.5](#ch23.xhtml_ch23fig5). Bits are clearly visible in surface
photographs of the die, without any delayering or staining, making this
an excellent first target.

As with any chemistry, please be careful not to get yourself hurt. The
hassles of doing this slowly and safely are worth keeping your eyes and
your fingers.

::: image
[]{#ch23.xhtml_page_218
.pagebreak}![Image](images/f0218-01.jpg){#ch23fig1}

> **Description:** Assembly code listing showing Nintendo logo verification routine starting at address 0x00A8. The code contains embedded Nintendo logo data in hexadecimal bytes, followed by a comparison routine at 0x00E0 that validates the cartridge logo against DMG ROM data. Key addresses include HL=$0104 pointing to cart logo and DE=$00e3 pointing to DMG ROM, making this an authentication check vulnerable to bypass attacks.

:::

Figure 23.1: End of the Game Boy ROM from Neviksti (2005)

### []{#ch23.xhtml_page_219 .pagebreak}**Decapsulation** {#ch23.xhtml_ch00lev1sec69 .h3}

To get the ROM, we first need to sacrifice a Game Boy. The CPU is
labeled [DMG-CPU B]{.literal}, and you can find it on the board that is
closer to the back of the device, away from the LCD.

(ROMs of the Game Boy Color and the Super Game Boy are not clearly
visible from the surface. See [Chapter E.4](#app05.xhtml_app05_4) for a
glitching attack that keeps the ROM visible while executing code from
cartridge memory.)

Decapsulation is performed with the HNO~3~ bath method from [Chapter
18](#ch18.xhtml_ch18). Bits are surface visible, so there's no need for
the delayering procedures that require more dangerous chemicals. We
pretty much just boil the whole QFP package in 65% nitric acid until the
packaging falls away, then clean it in acetone and isopropyl alcohol for
photography.

### **Photography** {#ch23.xhtml_ch00lev1sec70 .h3}

The ROM that we're after is in the CPU, whose surface die photograph is
shown in [Figure 23.2](#ch23.xhtml_ch23fig2). Bits are impossible to see
at that magnification, so see [Figure 23.3](#ch23.xhtml_ch23fig3) for a
closeup.

To locate the ROM, first find the memory bus, which is the horizontal
nest of wires roughly in the middle of the chip. Starting from the
western edge, follow the bus toward the east until it dead-ends at the
eastern sea of gates. The ROM is the thin horizontal structure just
north of that bus and just west of the sea of gates. At a decent
magnification, the bits will pop out at you, looking almost like foreign
writing at a distance just too far to resolve.

The dark spots are via wires that connect layers vertically, while the
bright spots are the absence of a via. This makes the color of the spot
imply the value of the bit. Not all vias are bits, of course, but in
[Figure 23.3](#ch23.xhtml_ch23fig3) you should see two columns of eight
bits and the first six rows. The vias in the longer metal lines, those
that reach the power rail at the top of the image, are not bits and
should not be extracted. To be sure that you understand what is and is
not a bit, please take a moment to produce the ASCII art table from the
photograph.

::: image
[]{#ch23.xhtml_page_220
.pagebreak}![Image](images/f0220-01.jpg){#ch23fig2}

> **Description:** Die photograph of a Game Boy cartridge chip showing complete die layout with bond pads around the perimeter. Large vertical striped sections dominate the center, indicating ROM arrays, while surrounding areas contain address decoders and logic circuits. The regular memory array structure with clear row/column organization makes this chip susceptible to visual extraction through delayering and microscopy techniques.

:::

Figure 23.2: Nintendo DMG-01-CPU from a Game Boy

::: image
[]{#ch23.xhtml_page_221
.pagebreak}![Image](images/f0221-01.jpg){#ch23fig3}

> **Description:** Microscope image showing ROM array with binary data overlaid below the physical structure. Two columns of bits are displayed, showing the actual bit patterns (1s and 0s) stored in the corresponding physical memory cells above. The correlation between physical cell appearance and binary state enables optical ROM reading attacks where programmed cells appear visually distinct from unprogrammed cells.

:::

Figure 23.3: Close-up of DMG-01-CPU Bits

::: image
![Image](images/f0221-01a.jpg){#ch23fig4}

> **Description:** Pixelated rendering of the text "Nintendo" in 8-bit style font using black blocks. This represents logo data stored in ROM that must match the authentic Nintendo logo during boot authentication. The simple bitmap pattern is embedded in cartridge ROM and verified by console firmware, making it a target for cloning and authentication bypass attacks.

:::

Figure 23.4: Nintendo Logo at [0xA8]{.literal} (ROM) and
[0x104]{.literal} (Cart).

[]{#ch23.xhtml_page_222 .pagebreak}After locating the ROM and its bits,
I photographed it as a panorama of twenty-two images at 50x
magnification through a metallurgical microscope. These images were
stitched together with Hugin and Panotools to form a panorama that is
9,000 pixels wide and 2,249 pixels tall. You can find it in reduced
resolution as [Figure 23.5](#ch23.xhtml_ch23fig5), or as a digital
file.^[1](#footnotes.xhtml_ch23fn1){#ch23.xhtml_ch23fn_1}^

### **Bit Extraction** {#ch23.xhtml_ch00lev1sec71 .h3}

Having a photograph of the chip, the next step is to extract the bits
into a textfile.

I used Mask ROM Tool for this, drawing lines for each column and row.
This ROM is rather small and the stitched image was quite well aligned,
so I could place row and column lines that span the entire length of the
ROM.

The software marks a bit wherever a row and column intersect, and it
helpfully draws a histogram of the bits for me to choose a threshold
color between ones and zeroes. Both the red and green colors channels
have a clear separation between ones and zeroes, but I found that green
had a wider gap, so that's the best channel for sampling. The color I
used was that of the pixel at the center of the bit; there was no need
for more complicated sampling strategies.

::: image
[]{#ch23.xhtml_page_223
.pagebreak}![Image](images/f0223-01.jpg){#ch23fig5}

> **Description:** Die photograph showing dense memory array with regular grid structure containing thousands of bit cells. Binary data overlay at bottom shows extracted bits in rows, with each row representing decoded memory contents. The visible regularity in cell structure combined with optical density variations enables systematic bit extraction through image analysis and pattern recognition algorithms.

:::

Figure 23.5: ASCII Art of the DMG-01-CPU Bits

::: image
[]{#ch23.xhtml_page_224
.pagebreak}![Image](images/f0224-01.jpg){#ch23fig6}

> **Description:** Memory map diagram of Game Boy address space showing memory regions from 0000 to ffff. Key sections include Cartridge ROM (Fixed 0000-3fff and Banked 4000-7fff), Video RAM (8000-9fff), Cartridge RAM (a000-bfff), Work RAM (c000-dfff with mirror at e000-fdff), OAM (fe00-fe9f), I/O Registers (ff00-ff7f), and High RAM (ff80-fffe) with Interrupt Enable Register at ffff. Critical attack surfaces include cartridge interface and I/O registers vulnerable to hardware manipulation.

:::

Figure 23.6: Game Boy Memory Map

### []{#ch23.xhtml_page_225 .pagebreak}**Bit Decoding** {#ch23.xhtml_ch00lev1sec72 .h3}

After extracting the physically ordered ASCII art bits in [Figure
23.5](#ch23.xhtml_ch23fig5), the next challenge is to decode it. Let's
look at three ways to do that.

McMaster (2018) uses this chip as an example for automatically solving
bit decoding given known plaintext. The Game Boy uses a Sharp LR35902
CPU, which is roughly like a Z80. Like the Z80, LR35902 code usually
sets the stack pointer in the very first instruction with the
[0x31]{.literal} opcode. McMaster therefore searches with his Zorrom
tool for all decodings in which the first byte comes out as
[0x31]{.literal}.

::: imagel
![Image](images/f0225-01.jpg)

> **Description:** Terminal output showing Python solver script execution for ROM extraction. Command "% ./solver.py --bytes 0x31 rom.txt rom" produces two matches, writing output files "rom/r-180_flipx-1_invert-1_cols-left.bin" and "rom/r-180_flipx-1_invert-1_cols-downr.bin". This demonstrates automated ROM extraction with transformations including 180-degree rotation, X-axis flip, bit inversion, and column reordering to reconstruct original data from die photographs.

:::

These filenames contain the decoding parameters, in which both are
rotated 180 ^°^C and flipped on the X axis. Bits are inverted, and the
only difference is that one uses the [cols-left]{.literal} strategy
while the other uses the [cols-downr]{.literal} strategy.

He then uses the [unidasm]{.literal} disassembler from MAME to examine
each file's first instruction. The [cols-left]{.literal} variant begins
with [31 11 47]{.literal}, setting the stack pointer to
[0x4711]{.literal}, while the [cols-downr]{.literal} variant begins with
[31 fe ff]{.literal}, setting the stack pointer to [0xfffe]{.literal}.
From the memory map in [Figure 23.6](#ch23.xhtml_ch23fig6), we can see
that the latter is a much more reasonable value, at the tail end of high
RAM rather than a random address in the middle of the banked cartridge
ROM.

We can also perform the same solution with GatoROM.

::: imagel
![Image](images/f0225-02.jpg)

> **Description:** Terminal output showing gatorom tool execution with command "% gatorom rom.txt --solve --solve-bytes 0:0x31 --decode-cols-left -i -r 0 --flipx". Returns two output lines "31 11 47" and "31 fe ff", representing decoded byte sequences from ROM image. The parameters specify solving mode, byte range, column decoding, inversion, rotation, and flip transformations necessary to extract correct data orientation.

:::

[]{#ch23.xhtml_page_226 .pagebreak}Automated tools are great when they
work, but we should always be suspicious of tools that we don't
understand. The [cols-downr]{.literal} mode is not very complex; it just
means that bytes are encoded in 16-bit logical columns made of two 8-bit
physical columns. The leftmost column contains the most significant
bits, and the first byte of the row is in the leftmost position. To get
the next byte, first work downward and then move everything one step to
the right.

The tail end of the ROM, shown in disassembly in [Figure
23.1](#ch23.xhtml_ch23fig1), disables read access at [0x00fe]{.literal}
by writing 1 into the register at [0xff50]{.literal} before continuing
into cartridge memory at [0x0100]{.literal}. This is why dumping the ROM
is not as simple as building a cartridge to display it on the screen,
export it through the link port, or beep it through the speaker.

[]{#ch24.xhtml}

