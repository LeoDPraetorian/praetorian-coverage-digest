## []{#app02.xhtml_page_281 .pagebreak}**B  More Debugger Attacks** {#app02.xhtml_app02 .h2}

### **B.1 STM32 Clones** {#app02.xhtml_app02_1 .h3}

The GD32F103 clone of the STM32F103 inherits its ancestor's security
model, in which RDP Level 1 allows for a JTAG connection but disconnects
flash memory. Obermaier, Schink, and Moczek (2020) describes a clever
exploit for this.

The authors noticed that flash memory restrictions apply when the
[C_DEBUGEN]{.literal} bit of the [DHSR]{.literal} register is set, which
occurs when the CPU debug module is enabled to halt the CPU or access
the processor's registers. The restrictions do not apply when system
components such as the peripherals are accessed through JTAG. The
challenge is to trigger code execution without touching the CPU
registers, only the peripherals.

One of their exploits works like this: first a JTAG debugger takes
control of the CPU to write shellcode into a region of SRAM that is not
initialized by the firmware. The target is reset, which restores access
to flash memory but disconnects the debugger. After reconnecting, JTAG
is used to adjust the vector table offset register (VTOR) to point to
shellcode in SRAM, carefully avoiding any operations that debug the CPU
and enable restrictions. Because of the new VTOR value, the next
interrupt that fires triggers a handler in the SRAM shellcode, that
dumps all flash memory.

The same paper describes using JTAG to debug other peripherals of
GD32F103 and CKS32F103 chips while still carefully
[]{#app02.xhtml_page_282 .pagebreak}avoiding any debug operations
against the CPU. In this case, the target is the DMA engine rather than
the VTOR we saw in the last section.

On the CKS32F103, the DMA engine is always allowed to read from flash
memory, even after the CPU's access has been revoked, so you can simply
use DMA to copy from flash memory to SRAM in memory-to-memory mode. CPU
debugging is used to halt the CPU, order the DMA engine to copy from
flash to SRAM, and fetch the contents of SRAM.

On the GD32F103, we can still use JTAG to read out the buffer but
*cannot* halt the CPU with it, as that would enable flash memory
restrictions for the DMA engine. Because the CPU must still be halted to
prevent memory access conflicts, they use the VTOR trick from [Chapter
B.1](#app02.xhtml_app02_1) to relocate the interrupt vector table to
[0xF0000000]{.literal}, an illegal address that causes the CPU to crash
on the next non-maskable interrupt (NMI). This halts the CPU but not the
DMA engine, preventing bus conflicts from ruining the reliability of the
rest of memory being transferred.

Another attack from the paper impacts the CKS32F103 and GD32VF103, the
latter of which uses a RISC-V core instead of the ARM core of the
original STM32 chips and their other clones. Instead of directing the
DMA peripheral to copy memory over JTAG, this attack makes use of the
fact that flash memory access is not disabled when the CPU executes code
from certain regions of the chip.

In the GD32VF103, firmware executed from flash memory or from SRAM can
read flash memory, even when the chip is read-protected and the debugger
cannot directly read flash memory. So to dump memory, you just write
some shellcode into RAM, run it to perform a copy from flash memory, and
then use your debugger to read the buffer out of RAM.

The CKS32F103 has a similar loophole, but only for code
[]{#app02.xhtml_page_283 .pagebreak}running from ROM, and not for code
running from RAM. One method to exploit this would be to blindly search
for an appropriate gadget in code memory, as we saw for the nRF51 in
[Chapter 9](#ch09.xhtml_ch09). Obermaier takes a different approach,
dumping the bootloader of an unlocked chip to find gadgets that exist at
reliable addresses for all CKS32F103 devices.

### **B.2 GD32 GigaVulnerability** {#app02.xhtml_app02_2 .h3}

Kovrizhnykh (2023) presents three new vulnerabilities for GD32
microcontrollers by expanding the work of Obermaier, Schink, and Moczek
(2020). These vulnerabilities impact different devices; see [Table
B.1](#app02.xhtml_chBtab1) to find the one that works for your chip of
interest.

In these chips, protection levels are roughly same as in a real STM32.
RDP Level 0 is unprotected, Level 1 allows debugging at the cost of
disabling flash memory, and Level 2 ought to prohibit all debugging. The
debugging protocol here is SWD, not JTAG.

Each of these attacks depends upon an odd observation that SWD debugging
is possible while the chip is held in reset. SRAM and flash memory
always read as zero. Peripherals can be read, but only as their reset
values. SWD buffers, such as the result of a read or the address that
might soon be read, do not seem to be erased.

The first of these three vulnerabilities is that in some chips, such as
the GD32L23x, GD32E23x, and GD32E50x, a read that is queued up during
reset can be performed just as the chip exits reset. Kovrizhnykh found
that he could leak words of SRAM this way.

While the !RST pin is low, he sends "[W AP4 0x20000008]{.literal}" to
prepare a read of SRAM. !RST is then raised, which takes the chip out of
reset and begins to boot it. Just 1.45 µs later, he sends "[R
APc]{.literal}" to perform the read and drops the !RST pin low shortly
after the read command is sent. In all, the chip is only out of reset
for 55 µs. When the chip is back in reset, he sends "[RDBUFF]{.literal}"
and the chip happily provides [0x0800186c]{.literal}, the value at the
expected address.

::: image
[]{#app02.xhtml_page_284
.pagebreak}![Image](images/f0284-01.jpg){#chBfig1}

> **Description:** Die photograph of large memory-dominant chip showing regular array structure occupying majority of die area. Central region contains massive ROM with consistent vertical striping pattern. Left side shows peripheral logic including address decoders and sense amplifiers. Right edge has smaller memory blocks and interface circuits. Bond pads around perimeter connect to package pins. The predominantly regular structure with minimal logic overhead indicates mask ROM or EEPROM, making systematic optical extraction feasible across entire memory array.

:::

Figure B.1: GD32F130, Lower Die

::: image
[]{#app02.xhtml_page_285
.pagebreak}![Image](images/f0285-01.jpg){#chBtab1}

> **Description:** Table showing GigaDevice GD32 microcontroller vulnerability matrix for RDP (Readout Protection) levels. Lists 11 chip variants (GD32F130/330/405/L233/E230/E503/C103/E103/F205/F303/F403) divided into RDP 2 and RDP 1 protection levels. Columns show three vulnerability types: Vuln1 (SRAM), Vuln2 (Flash), Vuln3 (Flash). Different chips marked "Yes" or "No" for each vulnerability, revealing specific attack vectors applicable to different product lines. This matrix guides targeted exploitation based on protection level and chip variant.

:::

Table B.1: GigaVulnerability Success Table

The mechanism here is a race condition. If the chip were given time to
fully boot, the debugging restrictions would come online and the read
would be denied. This technique does not allow flash memory to be
extracted, presumably because flash takes longer than SRAM to become
available after a reset.

The second vulnerability relies on disconnecting the debugger
altogether, as the readout protection is triggered when the debug domain
is enabled with [CDBGPWRUPREQ]{.literal}. It is exploited by loading a
dumper application into SRAM and starting the application, then clearing
the debug domain bit with [chip.dap dpreg 0x4]{.literal}
[]{#app02.xhtml_page_286 .pagebreak}[0x0]{.literal} in OpenOCD. Memory
happily falls out the UART, and not just SRAM but also flash memory can
be directly extracted this way.

Most of the tested devices are vulnerable to this attack, but the
GD32F3x0 is a stubborn exception, vulnerable to neither the first nor
the second methods.

A third variant involves a race condition in the power-on reset sequence
of the F-series chips in this family. SWD will not work after the !RST
pin goes high, but you can use it by powering down the chip, pulling
!RST to ground, and then powering the chip up. Power analysis showed
Kovrizhnykh that the race window is much wider on this series, 1600 µs
instead of the 20 µs window of the E and L series.

There are two more complications to this third variant. SRAM has faded
out from the loss of power, so we cannot expose its contents in the way
that the first variant allows. Another complication is that while SWD is
allowed, debugging the CPU is not, so any reading of the flash memory
will have to be performed by the peripherals. Forbidden from using the
CPU, Kovrizhnykh instead configured the DMA peripheral to dump all flash
memory directly to the UART.

### **B.3 Xilinx Bitstream Decryption Oracle** {#app02.xhtml_app02_3 .h3}

The 7-Series FPGAs from Xilinx internally store the bitstream in SRAM
during operation, requiring them to load the configuration from either
an external memory chip or a microcontroller. To provide for protection
of these bitstreams without the cost of adding a nonvolatile memory,
Xilinx allows the bitstream to be encrypted with AES-256 in CBC-mode,
using a key that has been burned into the limited eFuse memory of the
FPGA.

[]{#app02.xhtml_page_287 .pagebreak}Reading out the bitstream by JTAG is
disabled by the encryption feature, but Ender, Moradi, and Paar (2020)
describes an exploit that leaks 32 bits of the cleartext bitstream at a
time. They noticed that the [WBSTAR]{.literal} register is loaded with a
*decrypted* word of the bitstream just before an HMAC error. They can
then reset the FPGA and read out the contents of this register, as it is
not cleared by the reset.

This attack is slow but effective, decrypting the bitstream of a
Kintex-7 XC7K160T in three hours and 42 minutes. The Virtex 6 family is
also vulnerable to this attack, with the limitation that two bits of
each 32-bit word are corrupted and lost during the reset.

### **B.4 CC2510, CC1110** {#app02.xhtml_app02_4 .h3}

The CC2510 and CC1110 from Texas Instruments were some of the first
chips to combine nonvolatile memory, a radio transceiver, and a
microcontroller into a single package. This generation uses an 8051 as
the MCU.

Devreker (2023) describes a voltage glitching attack for dumping
firmware from these chips, inspired by their use in an eInk price tag
with an as-yet-unknown radio protocol. Devreker began by implementing
the debugging interface with a Raspberry Pi Pico, then added glitching
support to it through an IRLML6246 MOSFET on the DCOUPL pin, a more or
less direct tap of the internal 1.8V line intended for attaching a
decoupling capacitor. His code is freely
available.^[1](#footnotes.xhtml_app2fn1){#app02.xhtml_app2fn_1}^

He notes a number of handy tricks in his article. Over-clocking the Pi
Pico to 250MHz from the default 125MHz doubles the glitching precision.
This chip has multiple cores, and running the glitch on a separate core
from the USB stack keeps USB interrupts from influencing timing.
Increasing the drive strength of the glitching pin gives it a faster
slew rate than the default, so that the glitch has sharper edges.
Powering the CC2510 directly from GPIO pins of the Pi Pico makes it easy
to power cycle the target after a failure. These little tricks might not
all be strictly necessary, but they add some portability to his paper
and make for good reading even if you're working against a very
different target.

::: image
[]{#app02.xhtml_page_288
.pagebreak}![Image](images/f0288-01.jpg){#chBfig2}

> **Description:** Die photograph of microcontroller showing complex mixed-signal architecture. Upper left contains two large circular analog structures likely phase-locked loops or oscillators. Upper section has dense memory arrays and control logic. Large irregular region in center-left appears to be flash memory with random bitcell patterns. Lower central area shows extensive peripheral circuits and communication interfaces. Multiple memory blocks positioned strategically throughout die. The combination of analog, flash, SRAM, and peripherals indicates security-focused microcontroller with multiple attack surfaces including power analysis on analog blocks.

:::

Figure B.2: Texas Instruments CC2510

[]{#app02.xhtml_page_289 .pagebreak}As for the glitch itself, attacking
the state machine of a debugging protocol can be quite different from
attacking the software parser of a bootloader. The lock status of the
chip is checked whenever the debugger orders the chip to execute an
instruction. This can be bypassed with a glitch just after the
[DEBUG_INSTR]{.literal} debugging command, but it takes a minimum of two
instructions to first [MOV]{.literal} a 16-bit address into
[DPTR]{.literal} and then [MOVX]{.literal} the byte at
[\@DPTR]{.literal} into the accumulator. Both glitches must be
successful to read one byte.

With this requirement for a double glitch, Devreker's exploit is quite
slow. He reports a success rate of roughly 5% on each glitch, for a
combined success rate of 0.25% on the double glitch. This gets him a
single byte every twenty seconds, or the full 32kB firmware image in
four days.[]{#app02.xhtml_page_290 .pagebreak}

[]{#app03.xhtml}

