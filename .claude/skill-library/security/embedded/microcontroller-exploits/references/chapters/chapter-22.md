## []{#ch22.xhtml_page_203 .pagebreak}**22  Mask ROM Photography** {#ch22.xhtml_ch22 .h2a}

Some chips store their program bits as markings on the masks that
lithographically draw the microchip. We call this a mask ROM, to
distinguish it from EEPROM, flash ROM, and other field-programmable
technologies. In this chapter, we'll go over the theory behind
photographing these ROMs to extract their bits, and in the following
chapters we'll work out examples of real targets from beginning to end.

Mask ROMs come in three types: via, diffusion, and implant. These are
quite different chemically and physically, but in extracting them, we
just need to understand them well enough to make the bits visible.
[Table 22.1](#ch22.xhtml_ch22tab1) lists a number of microcontrollers
and their ROM processes.

*Via* or *contact* ROMs use a via between layers to mark a bit. These
aren't very efficient for layout space, but they are quite easy to
decode because the bits are clearly visible when you find them. Many of
them, such as those in the Nintendo Game Boy, are even visible from the
surface without delayering!

*Diffusion* ROMs are lower in the chip. Bits here are marked by the
presence of a diffusion pool making a working transistor, or the absence
of the diffusion pool breaking that transistor. Because they are so low,
you almost always need to delayer the chip to see them, but there's
little risk of damaging the chip during the process.

*Implant* ROMs are the most frustrating of these three. Bits are encoded
by an additional ion implant in an otherwise working transistor, and by
some infernal coincidence the damaged and undamaged transistors are
exactly the same color! These ROMs generally require delayering to the
inside of the bits, then staining a difference into their coloring with
a Dash etch, which we will discuss shortly.

+-------------------------------------------------+--------------------+
| []{#ch22.xhtml_page_204 .pagebreak}             | ROM Type           |
|                                                 |                    |
| Model                                           |                    |
+-------------------------------------------------+--------------------+
| TMS1000                                         | Via                |
+-------------------------------------------------+--------------------+
| Game Boy                                        | Via                |
+-------------------------------------------------+--------------------+
| T44C080C                                        | Via                |
+-------------------------------------------------+--------------------+
| TMS320C15                                       | Via                |
+-------------------------------------------------+--------------------+
| MSP430F1, F2, F4                                | Via                |
+-------------------------------------------------+--------------------+
| 6500/1                                          | Diffusion          |
+-------------------------------------------------+--------------------+
| EMZ1001                                         | Diffusion          |
+-------------------------------------------------+--------------------+
| MYK82                                           | Diffusion          |
+-------------------------------------------------+--------------------+
| Tengen Rabbit                                   | Diffusion          |
+-------------------------------------------------+--------------------+
| TMS32C10NL                                      | Diffusion          |
+-------------------------------------------------+--------------------+
| HCS300                                          | Diffusion          |
+-------------------------------------------------+--------------------+
| Z8                                              | Diffusion          |
+-------------------------------------------------+--------------------+
| SM590                                           | Implant            |
+-------------------------------------------------+--------------------+
| MK3870                                          | Implant            |
+-------------------------------------------------+--------------------+
| TLCS-47 (TMP47)                                 | Implant            |
+-------------------------------------------------+--------------------+

Table 22.1: Example ROM Types

[]{#ch22.xhtml_page_205 .pagebreak}There are of course as many ways to
encode bits as there are unique shapes invented by the silicon wizards.
I use these broad categories to describe the effort required for bit
extraction, but there are of course ROMs with markings on the metal
layers instead of the via layer, which are also surface visible. Like
anything in reverse engineering, let's use this abstraction until it
ceases to be useful, then dig a little deeper to see what's inside.

### **Microscopy** {#ch22.xhtml_ch00lev1sec64 .h3}

Once the chip is ready, we'll need to photograph it.

You will need a metallurgical microscope, which is one in which the
column of light comes down through the lens to reflect back from the
die. Microscopes that send light up through the sample are great for
biology, but they will not help to photograph an opaque microchip.

A camera is also required. While it's possible to get decent pictures
from a lens adapter on a monocular microscope, it's much easier to use a
trinocular scope so that your own eyes can find the target and the
camera is only required at the end for the photos.

It's generally impossible to zoom out enough to keep the whole image in
frame while also keeping its details in focus, so we instead photograph
a series of shots that overlap one another. These can be combined after
the fact with panorama software, such as Hugin.

This photography can be quite tedious at the limits of your scope's
capabilities, so I generally try to first make a whole-chip
[]{#ch22.xhtml_page_206 .pagebreak}panorama at minimum magnification and
then follow that with high-magnification panoramas of my area of
interest, such as the ROM. A million thanks to John McMaster for selling
me a microscope with a motorized stage, so all of my photographs now
have consistent spacing and filenames that indicate the row and column.

### **Delayering with Hydrofluoric Acid** {#ch22.xhtml_ch00lev1sec65 .h3}

To delayer a chip, I heat it in dilute hydrofluoric acid (HF), which is
available over the counter in the States as Whink or Rust-Go branded
rust stain remover.

Hydrofluoric acid is dangerous to your bones, and it will damage them
without giving the courtesy of much skin pain. Be very careful if you
mess with this stuff, and do not skimp on
safety.^[1](#footnotes.xhtml_ch22fn1){#ch22.xhtml_ch22fn_1}^ Another
hassle with hydrofluoric acid is that we are using it because it attacks
glass, so we can't very well use a glass beaker to hold the reaction.
Plastic beakers, or plastic centrifuge tubes, are critical here.

As the HF attacks your target, you'll see some bubbles as it reacts to
metals. The first flurry of bubbles usually indicates the top metal
layer, and in reactions where you need to get a particular depth into
the chip, it's often handy to delayer many chips at once and to sort
them after the fact to find your right depth.

You might notice that the metal layers lift off of the chip rather than
dissolving into a liquid. A little agitation is helpful to get these
away from the die, so that they don't mask your delayering reactions.

### []{#ch22.xhtml_page_207 .pagebreak}**Dash Etching for Implant ROMs** {#ch22.xhtml_ch00lev1sec66 .h3}

For implant ROMs, where the bits are identical in color, we need to give
them different colors in order to photograph them. This is accomplished
after delayering by a Dash etch, which is best described in Beck (1998)
and McMaster (2019).

Delayering here can be quite confusing, as you can't really see how
close we are to the implants that we'd like to photograph. It might help
to delayer many samples, returning those that haven't been sufficiently
delayered to the bath.

The Dash etch consists of three parts. Hydrofluoric acid and nitric acid
attack the silicon, while acetic acid (HAc) buffers the reaction to slow
it down. When the ratios are right, p-type doping will slightly tip this
reaction in favor of oxidization, causing the p-type silicon to turn
brown faster than the n-type silicon does.

I perform this with John McMaster's Rust-Go solution, which is made from
3mL of 65% HNO~3~, 4mL of 12% HF (Rust-Go), and 8mL of acetic acid. The
final proportions are roughly 4.3% HNO~3~ and 3.2% HF; the remainder of
the solution is HAc and H~2~O to buffer the reaction.

Beck recommends a solution of 3mL 65% HNO~3~, 1mL 48% HF, and 10 mL to
12 mL 98% HAc. McMaster himself has moved on to this mixture, and I only
hesitate to follow because HF is a nasty
poison.^[2](#footnotes.xhtml_ch22fn2){#ch22.xhtml_ch22fn_2}^

Whichever solution is used, the already delayered die is placed into it
under a bright light, such as that from a halogen fiber lamp. A minute
or two under the light will darken the chip in splotches, and if you're
lucky, the ones will stand out as much darker than the zeroes.

::: image
[]{#ch22.xhtml_page_208
.pagebreak}![Image](images/f0208-01.jpg){#ch22fig1}

> **Description:** Multi-panel display showing character ROM data organization. Top panels show typical 8-byte character representation in a grid pattern and hexadecimal data table with standard character data starting at address 0x9b0d. Bottom section displays four columns of die photograph showing ROM bit cell arrays with regular repeating structures. The vertical white lines indicate character boundaries in the physical layout, useful for optical ROM extraction attacks.

:::

Figure 22.1: TMP47C434N Implant ROM

[]{#ch22.xhtml_page_209 .pagebreak}It is absolutely critical to keep the
metal content low during these reactions. You mustn't have any metal
salts from a delayering reaction on your glassware, and you mustn't have
any remnant of the lead frame beneath the die. Quite often, you can even
see markings on the edge of the die from your tweezers during the
reaction.

[Figure 22.1](#ch22.xhtml_ch22fig1) shows the datasheet description of
the TMP47C-434N's font implant ROM, along with a die photograph from my
lab after staining the bits with a Dash etch. Notice how the Dash etch
leads to uneven contrast; some are much darker or lighter than others.

### **From Photographs to Bits** {#ch22.xhtml_ch00lev1sec67 .h3}

After capturing the bits photographically, it's necessary to extract the
bits digitally. One way to do this is by carefully writing them down,
patiently marking each one or zero without losing your place or losing
your mind. Another way is to let software do the boring work. "Work
smarter, not harder," as Coach Crigger would tell me back in high
school.

An early public example of this is Rompar from Laurie (2013), a Python
application written to mark the bits in a MARC4 microcontroller from a
car's key fob. More recently, Bitractor from Gerlinsky (2019) and my own
Mask ROM Tool from Goodspeed (2024), both in C[++]{.literal}. These
three tools vary dramatically in their implementation and usage, but the
general principle is to come up with a matrix of bit positions, then to
sample the color of each bit to determine the difference between the
ones and the zeroes.

::: image
[]{#ch22.xhtml_page_210
.pagebreak}![Image](images/f0210-01.jpg){#ch22fig2}

> **Description:** High-magnification die photograph of ROM array showing individual memory cells in a regular matrix pattern. Distinct bright cells indicate programmed bits while darker cells show unprogrammed states. The repetitive structure with periodic variations reveals the stored binary data pattern, making this vulnerable to visual ROM extraction through microscopy and image processing techniques.

:::

Figure 22.2: MYK82 Bits in the Diffusion Layer

::: image
![Image](images/f0210-02.jpg){#ch22fig3}

> **Description:** Statistical distribution graph showing bit count versus color byte value for red, green, and blue channels. Blue channel peaks around value 50 (3500 count), green peaks near 100 (2500 count), and red shows peaks at 150 and 225 (2800 and 2500 counts respectively). This color histogram analysis is used for optical ROM extraction, revealing data patterns through statistical analysis of die photography.

:::

Figure 22.3: Color Distributions from the MYK82 ROM

[]{#ch22.xhtml_page_211 .pagebreak}When you try this yourself, you will
find that a naive sampling strategy is surprisingly effective. Most bits
can be correctly decoded by a threshold in one color channel, usually
red or green. It helps to improve those odds by drawing a histogram of
samples in each color channel, to ensure that there is a clean bimodal
separation between the ones and zeroes and that your threshold is set
between the two groups.

For a concrete example, [Figure 22.2](#ch22.xhtml_ch22fig2) shows a
closeup of bits from the NSA's MYK82 that we'll discuss in detail and
whose ROM we will dump in [Chapter 24](#ch24.xhtml_ch24). You'll see
bits between the central squares and the horizontal wires as a
rectangular box that's darker than its surroundings. [Figure
22.3](#ch22.xhtml_ch22fig3) shows just how much darker the ones are than
the zeroes in the red channel, a total separation with no bits on the
threshold and very few near it. Green has a separation that is nearly as
good, but the blue channel shows no real separation.

In cases where a clean bimodal separation does not exist in any color
channel, it can help to create one by image preprocessing or by sampling
more than a single pixel. In my tool, I have sampling techniques that
return the darkest of each color channel in a thin horizontal or
vertical strip. This is particularly effective for over-etched diffusion
ROMs, where bits have a bordering color but any color difference in the
center of the bit has already been etched away.

While the available bit-marking tools have many differences, they have
all standardized on ASCII art as an export format. Generally, the wider
axis is arbitrarily defined as X to fit with computer monitor
dimensions, and you can expect some rotations to be necessary before
decoding the bits.

### []{#ch22.xhtml_page_212 .pagebreak}**From Bits to Bytes** {#ch22.xhtml_ch00lev1sec68 .h3}

After extracting the bits in the physical order, you'll need to
rearrange them into bytes in the logical order. Before we jump into the
tools that make this less painful, let's discuss a little about why the
bits are in such a confusing order to begin with.

In natural languages, we have considerable variety in our writing. Some
languages are written from left to right, while others are written from
right to left. Some represent words by groups of letters, some use
ideograms, and a few mix these concepts, building one larger symbol out
of smaller ones to represent a word.

ROMs also have some common rules and infinite variety in the
arrangement, but there is one concept that they almost never implement.
They almost never group the bits of a byte together, instead preferring
to scatter them into eight columns, separated from one another for
physical convenience.

To figure out the ordering of bits, one method is to very carefully
study the bits of a ROM and to try out different patterns until they
make sense. If you see 16 columns in a 16-bit microcontroller, for
example, you might guess that one bit is taken from each column to make
a word. Checking all of the words in both the top row and the bottom row
might reveal an entry point of the program, making the entirety of the
layout make sense.

Gerlinsky (2019) introduces BitViewer, a tool in [Figure
22.4](#ch22.xhtml_ch22fig4) that graphically displays bits, adjusting
their organization so that a human operator can explore their meaning.
After loading a bitstream, you can choose how tall and wide bit pixels
are, how much spacing to put between them, and how many to group into a
major column. Bits are selected individually or grouped into columns and
rows, allowing an operator to spot patterns that reveal the ROM
contents. This is much less painful than doing the same on graph paper.

::: image
[]{#ch22.xhtml_page_213
.pagebreak}![Image](images/f0213-01.jpg){#ch22fig4}

> **Description:** Memory visualization showing five vertical columns of binary data displayed as black and white pixels. The second column appears uniformly dark, third and fourth columns show regular patterns with gaps, while first and fifth columns display random noise-like patterns. This bitmap representation aids in identifying data structures, padding, and encrypted versus unencrypted regions in extracted memory dumps.

:::

Figure 22.4: BitViewer from Gerlinsky (2019)

::: image
![Image](images/f0213-02.jpg){#ch22fig5}

> **Description:** Close-up die photograph showing dense logic circuitry with regular array structure in the center-right region and random logic patterns on the left. Visible pads and bond wire attachment points along the edges. The mixed regular-random structure suggests a combination of memory arrays and control logic, with the regular section being a prime target for visual extraction attacks.

:::

Figure 22.5: MaskRomTool from Goodspeed (2024)

+---------------------------+------------------------------------------+
| []{#ch22.xhtml_page_214   | First bit is top left,\                  |
| .pagebreak}               | then move down,\                         |
|                           | then move right.                         |
| cols-downl                |                                          |
+---------------------------+------------------------------------------+
| cols-downr                | First bit is top right,\                 |
|                           | then move down,\                         |
|                           | then move left.                          |
+---------------------------+------------------------------------------+
| cols-left                 | First bit is top right,\                 |
|                           | then move left,\                         |
|                           | then move down.                          |
+---------------------------+------------------------------------------+
| cols-right                | First bit is top left,\                  |
|                           | then move right,\                        |
|                           | then move down.                          |
+---------------------------+------------------------------------------+
| squeeze-lr                | [byte&0xAA]{.literal} use cols-left,\    |
|                           | [byte&0x55]{.literal} use cols-right.    |
+---------------------------+------------------------------------------+

Table 22.2: Zorrom Decoding Strategies

McMaster (2018) takes another approach in a program called Zorrom. It
implements decoding strategies for a number of known chips, along with a
series of transformations such as a flip on the X axis, rotating the bit
matrix and inverting the bits. When you are lucky, which is about half
the time, it can correctly solve the decoding given just the bits
themselves and a guess at a few bits or bytes.

Zorrom's decoding strategies are listed in [Table
22.2](#ch22.xhtml_ch22tab2). To apply a strategy, first divide the bit
columns into eight groups and then sample one bit from each group to
form a byte, with the least significant bit being the one on the left.
So for the cols-downr strategy, your first byte would be formed from the
top right bit of every group. Your second byte would have its bits just
beneath []{#ch22.xhtml_page_215 .pagebreak}those of the first, and after
sampling a bit from every row of the groups, you would move one bit
column to the right and start again from the top.

It doesn't bother to support decoding strategies that start from the
bottom of the group or that place the most significant bit on the left.
These are handled by the existing strategies, after rotations and an
optional flip on the X axis.

My own solution to bit decoding is called GatoROM, which runs both as a
CLI tool and as a C[++]{.literal} library. A GUI extension to my Mask
ROM Tool from Goodspeed (2024) was then written using the library. It is
shamelessly inspired by McMaster's tool, implementing all of the
necessary transformations for compatibility with his solver.

Used as a library, [void\*]{.literal} pointers allow a bidirectional
association between the physically ordered bits and the logically
ordered bytes of the ROM. You can select bytes in the hex viewer and
then ask the software to highlight them in the GUI. This is incredibly
handy when implementing new decoding strategies for chips that don't
quite fit the existing ones.

Whatever tooling you use to decode a ROM, the end result is a flat
binary file containing the bytes. When you first get a meaningful
decoding, be a little suspicious of its ordering, as small ordering
mistakes might not be noticed until the ROM is disassembled and reverse
engineered.^[3](#footnotes.xhtml_ch22fn3){#ch22.xhtml_ch22fn_3}^

[]{#ch23.xhtml}

