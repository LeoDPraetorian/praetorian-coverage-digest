/**
 * Unit Tests for Linear get-initiative Wrapper (GraphQL)
 *
 * Tests validate:
 * - Input validation (security constraints, format validation)
 * - Output schema compliance (required fields, type correctness)
 * - GraphQL HTTP call behavior
 * - Edge cases (null values, missing optional fields, truncation)
 * - Error handling (not found, validation failures)
 */

import { describe, it, expect, beforeAll, afterAll, afterEach } from 'vitest';
import { setupServer } from 'msw/node';
import { graphql, HttpResponse } from 'msw';
import {
  getInitiative,
  getInitiativeParams,
  getInitiativeOutput,
  type GetInitiativeInput,
  type GetInitiativeOutput,
} from './get-initiative';
import {
  CommandInjectionScenarios,
  PathTraversalScenarios,
} from '@claude/testing';

// MSW server setup with Linear GraphQL endpoint
const linearApi = graphql.link('https://api.linear.app/graphql');

const server = setupServer(
  linearApi.query('Initiative', ({ variables }) => {
    return HttpResponse.json({
      data: {
        initiative: {
          id: variables.id || 'init-uuid-123',
          name: 'Q2 2025 Roadmap',
          description: 'Strategic initiative for Q2',
          targetDate: '2025-06-30',
          createdAt: '2025-01-01T10:00:00Z',
          updatedAt: '2025-01-05T15:30:00Z',
        },
      },
    });
  })
);

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('getInitiative (GraphQL)', () => {
  // =========================================================================
  // INPUT VALIDATION
  // =========================================================================

  describe('Input Validation', () => {
    it('should accept valid initiative ID (UUID format)', async () => {
      const uuid = 'abc123-uuid-456';
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: uuid,
                name: 'Q2 2025 Roadmap',
              },
            },
          });
        })
      );

      const input: GetInitiativeInput = { id: uuid };
      const result = await getInitiative.execute(input, { apiKey: 'test-api-key' });

      expect(result).toBeDefined();
      expect(result.id).toBe(uuid);
    });

    it('should accept valid initiative name', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-uuid-1',
                name: 'Q2 2025 Product Roadmap',
              },
            },
          });
        })
      );

      const input: GetInitiativeInput = { id: 'Q2 2025 Product Roadmap' };
      const result = await getInitiative.execute(input, { apiKey: 'test-api-key' });

      expect(result).toBeDefined();
      expect(result.name).toBe('Q2 2025 Product Roadmap');
    });

    it('should reject empty string', () => {
      const input = { id: '' };
      expect(() => getInitiativeParams.parse(input)).toThrow();
    });

    it('should reject null input', () => {
      const input = { id: null };
      expect(() => getInitiativeParams.parse(input)).toThrow();
    });
  });

  // =========================================================================
  // SECURITY VALIDATION
  // =========================================================================

  describe('Security Validation - Path Traversal', () => {
    PathTraversalScenarios.forEach(scenario => {
      it(`should block: ${scenario.description}`, () => {
        const input = { id: scenario.input };
        expect(() => getInitiativeParams.parse(input)).toThrow(/traversal|invalid/i);
      });
    });
  });

  describe('Security Validation - Command Injection', () => {
    CommandInjectionScenarios.forEach(scenario => {
      it(`should block: ${scenario.description}`, () => {
        const input = { id: scenario.input };
        expect(() => getInitiativeParams.parse(input)).toThrow(/invalid|characters/i);
      });
    });
  });

  describe('Security Validation - Control Characters', () => {
    it('should reject null byte injection', () => {
      const input = { id: 'initiative\x00injection' };
      expect(() => getInitiativeParams.parse(input)).toThrow(/control|invalid/i);
    });

    it('should reject control character 0x01', () => {
      const input = { id: 'init\u0001malicious' };
      expect(() => getInitiativeParams.parse(input)).toThrow(/control|invalid/i);
    });
  });

  // =========================================================================
  // OUTPUT SCHEMA - REQUIRED FIELDS
  // =========================================================================

  describe('Output Schema - Required Fields', () => {
    it('should return all required fields (id, name)', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Q2 2025 Product Roadmap',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.id).toBe('init-1');
      expect(result.name).toBe('Q2 2025 Product Roadmap');
    });

    it('should include estimatedTokens in output', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Test Initiative',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.estimatedTokens).toBeDefined();
      expect(typeof result.estimatedTokens).toBe('number');
    });
  });

  // =========================================================================
  // OUTPUT SCHEMA - OPTIONAL FIELDS
  // =========================================================================

  describe('Output Schema - Optional Fields', () => {
    it('should include description when present', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Q2 2025 Roadmap',
                description: 'Strategic initiative for Q2',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.description).toBe('Strategic initiative for Q2');
    });

    it('should truncate description to 500 characters for token efficiency', async () => {
      const longDescription = 'x'.repeat(1000);
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Long Description Initiative',
                description: longDescription,
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.description).toBe('x'.repeat(500));
      expect(result.description?.length).toBe(500);
    });

    it('should omit description when null', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'No Description',
                description: null,
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.description).toBeUndefined();
    });

    it('should include targetDate when present', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Q2 Roadmap',
                targetDate: '2025-06-30',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.targetDate).toBe('2025-06-30');
    });

    it('should include createdAt and updatedAt when present', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Test Initiative',
                createdAt: '2025-01-01T10:00:00Z',
                updatedAt: '2025-01-05T15:30:00Z',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.createdAt).toBe('2025-01-01T10:00:00Z');
      expect(result.updatedAt).toBe('2025-01-05T15:30:00Z');
    });
  });

  // =========================================================================
  // ERROR HANDLING
  // =========================================================================

  describe('Error Handling', () => {
    it('should throw when initiative not found', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: null,
            },
          });
        })
      );

      await expect(
        getInitiative.execute({ id: 'NONEXISTENT' }, { apiKey: 'test-api-key' })
      ).rejects.toThrow(/Initiative not found/);
    });

    it('should throw when GraphQL returns errors', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            errors: [{ message: 'GraphQL server error' }],
          });
        })
      );

      await expect(
        getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' })
      ).rejects.toThrow(/GraphQL/);
    });

    it('should throw on validation failure - missing required field', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                // Missing name
              },
            },
          });
        })
      );

      await expect(
        getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' })
      ).rejects.toThrow();
    });
  });

  // =========================================================================
  // INTEGRATION - FULL WORKFLOW
  // =========================================================================

  describe('Full Workflow - Complete Initiative Response', () => {
    it('should handle comprehensive initiative response with all fields', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'abc123-uuid-456',
                name: '2025 Digital Transformation',
                description: 'Complete platform modernization initiative',
                targetDate: '2025-12-31',
                createdAt: '2025-01-01T10:00:00Z',
                updatedAt: '2025-01-05T15:30:00Z',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'abc123-uuid-456' }, { apiKey: 'test-api-key' });

      expect(result.id).toBe('abc123-uuid-456');
      expect(result.name).toBe('2025 Digital Transformation');
      expect(result.description).toBe('Complete platform modernization initiative');
      expect(result.targetDate).toBe('2025-12-31');
      expect(result.createdAt).toBe('2025-01-01T10:00:00Z');
      expect(result.updatedAt).toBe('2025-01-05T15:30:00Z');
      expect(result.estimatedTokens).toBeDefined();
    });

    it('should handle minimal initiative response with only required fields', async () => {
      server.use(
        linearApi.query('Initiative', () => {
          return HttpResponse.json({
            data: {
              initiative: {
                id: 'init-1',
                name: 'Minimal Initiative',
              },
            },
          });
        })
      );

      const result = await getInitiative.execute({ id: 'init-1' }, { apiKey: 'test-api-key' });

      expect(result.id).toBe('init-1');
      expect(result.name).toBe('Minimal Initiative');
      expect(result.description).toBeUndefined();
      expect(result.targetDate).toBeUndefined();
      expect(result.estimatedTokens).toBeDefined();
    });
  });

  // =========================================================================
  // WRAPPER METADATA
  // =========================================================================

  describe('Wrapper Metadata', () => {
    it('should have correct name', () => {
      expect(getInitiative.name).toBe('linear.get_initiative');
    });

    it('should have descriptive description', () => {
      expect(getInitiative.description).toBe('Get detailed information about a specific Linear initiative');
    });

    it('should have parameters schema', () => {
      expect(getInitiative.parameters).toBeDefined();
    });

    it('should have tokenEstimate metadata', () => {
      expect(getInitiative.tokenEstimate).toBeDefined();
      expect(getInitiative.tokenEstimate.reduction).toBe('99%');
    });
  });
});
