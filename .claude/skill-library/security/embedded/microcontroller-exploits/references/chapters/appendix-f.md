## []{#app06.xhtml_page_361 .pagebreak}**F  More Test Modes** {#app06.xhtml_app06 .h2}

### **F.1 8051 External Memory** {#app06.xhtml_app06_1 .h3}

McCormac (1996) and other Nineties sources describe a vulnerability for
dumping Intel's 8051. This chip has an !EA pin that maps external memory
into the boot region.

The pin is not *latched* by sampling it only at reset; you can flip it
back and forth as the software is running! The chip's memory can be
dumped by booting to an external EEPROM that jumps from the boot region
to the EEPROM region and then re-enables the ROM to be read as data.

Some 8051 derivatives such as the Signetics SCN8051H remain vulnerable.
Others latch the !EA pin at reset to prevent the attack.

Blair (2020) is a standalone dumper for 8051 chips with this unlatched
pin, including both a PCB design and an EEPROM image to perform the
attack. His exploit runs within the target 8051, so the PCB does not
require an additional microcontroller.

### **F.2 TMS320C15, BSMT2000 !MP Pin** {#app06.xhtml_app06_2 .h3}

Like many chips from the Eighties, the TMS320 series can operate either
as a microcontroller executing code from an internal ROM or as a
microprocessor executing code from external memory. Surply (2015) is
primarily concerned with the Sega Whitestar pinball machine and
programmable array logic (PAL) reverse engineering, but it contains a
nifty abuse of the !MP pin that switches between these modes. This is
orchestrated by an FPGA, presenting a small memory filled with shellcode
while switching the victim chip between microprocessor and
microcontroller modes.

::: image
[]{#app06.xhtml_page_362
.pagebreak}![Image](images/f0362-01.jpg){#chFfig1}

> **Description:** Timing diagram showing microcontroller instruction execution phases across 24 clock cycles. Five phases labeled: Fetch TBLR, Select ROM, Read ROM, Fetch OUT, Output ROM. Signal lines include /men, /w, /mp showing control timing. Address (a) and data (d) buses transition through PC, PC+1, ACC values and TBLR dma, OUT dma, port sequences. Demonstrates ROM read operation with precise timing relationships for MaskROM[ACC] access.

:::

Figure F.1: TMS320C15 Dump Waveform from Surply (2015)

::: image
[]{#app06.xhtml_page_363
.pagebreak}![Image](images/f0363-01.jpg){#chFfig2}

> **Description:** Microcode ROM content specification showing instruction encoding. Configuration parameters: WIDTH=16, DEPTH=64, ADDRESS_RADIX=HEX, DATA_RADIX=BIN. Content section defines 12 instructions (addresses 0-B) including LACK 1, SACL 0, LT 0, MPYK 1, ZAC, TBLR 0, SACL 1, OUT 1,1, OUT 0,0, APAC, B 5, and END. Binary encodings and comments detail operations like ACC assignments, DATA[0] operations, and program flow control for embedded processor.

:::

Figure F.2: External Shellcode from Surply (2015)

::: image
![Image](images/f0363-02.jpg){#chFfig3}

> **Description:** Die photograph of simple microcontroller showing clear functional block separation. Large memory array occupies left two-thirds with dense repetitive cell structure characteristic of ROM or RAM. Right side contains logic blocks including address decoders, ALU, and control circuitry. Top edge shows bond pad array for external connections. Horizontal routing channels separate major functional blocks. Multiple test points visible as white squares distributed across the die for probing during security analysis.

:::

Figure F.3: BSMT2000 / TMS320C15

[]{#app06.xhtml_page_364 .pagebreak}The !MP pin is not latched at reset,
so you can freely change it within an instruction to cause the
instruction to be fetched from external memory while the first data
argument is fetched from internal memory.

Once you know that the !MP pin is not latched, it is clear that this can
be exploited by toggling it while having an FPGA emulate an external
memory. Toggling causes the chip to stop executing the internal ROM and
switch over to executing the FPGA's memory. The pin can be low to fetch
most instructions from the external memory, jumping high only for the
brief fetch from the internal ROM.

His shellcode in [Figure F.2](#app06.xhtml_chFfig2) is quite simple.
After initializing variables, an infinite [while()]{.literal} loop at
address 5 keeps dumping the accumulator's value and the program memory
value at the accumulator's address to the first two I/O ports. There's
nothing within the code to switch between internal and external
memories; that logic is handled by an FPGA that presents this memory to
the TMS320.

Surply's timing diagram in [Figure F.1](#app06.xhtml_chFfig1) shows that
the !MP pin should jump high after the [TBLR 0]{.literal} instruction is
fetched from address 5. The pin drops low before the following
instruction is fetched from address 6. He notes that this timing is very
tight, and that violations of it will cause the exploit to fail.

### []{#app06.xhtml_page_365 .pagebreak}**F.3 6500/1 Ten Volts** {#app06.xhtml_app06_3 .h3}

Shortly after Commodore acquired MOS Technology for its 6502 technology,
they released the 6500/1 chip, a mask-programmed variant of the 6502.
The 6500/1 includes two kilobytes of ROM, 64 bytes of RAM, and some
handy peripherals. It also has a test mode, an exploit for which is
available in Brain (2014).

Looking at the datasheet, Commodore (1986) describes the test mode like
so:

::: bq
Special test logic provides a method for thoroughly testing the 6500/1.
Applying a +10V signal to the !RES line places the 6500/1 in the test
mode. While in this mode, all memory fetches are made from Port PC.
External test equipment can use this feature to test internal CPU logic
and I/O. A program can be loaded into RAM, allowing the contents of the
instruction ROM to be dumped to any port for external verification.
:::

Brain's source code contains two exploits for dumping the ROM. His first
method, built upon suggestions by Gerrit Heitsch and Greg King, pulls
data directly from the ROM without forcing it to execute shellcode. He
observes the instruction fetches until he knows which phase of the clock
is the opcode fetch, then instructs the CPU to load a memory location
into the accumulator register. He finally drops out of the test mode
during the cycle when the load from ROM would occur so the fetch occurs
from the real ROM and not from port [PC]{.literal}.

His second exploit is closer to the intent of the datasheet, loading
this shellcode into SRAM at [0x0000]{.literal} and then executing it
outside of test mode to dump the contents of ROM to [PA]{.literal} at
[0x80]{.literal} while strobing [PC]{.literal} at [0x82]{.literal} to
indicate that data is ready.

::: image
[]{#app06.xhtml_page_366
.pagebreak}![Image](images/f0366-01.jpg){#chFfig4}

> **Description:** Circuit schematic showing ATmega32-P microcontroller interfacing with 6500Ω buffer and external components. Left side: 16MHz crystal oscillator circuit with capacitors C1, C2 and crystal Q1 connected to XTAL1/XTAL2 pins. Center: MEGA32-P with full port pinouts (Port A-D) including ADC, SPI, I2C interfaces. Right side: High-voltage generation circuit using Q2 (2N3906), T1 (2N3904), T2 (2N3904) transistors with resistor network producing -10.3V and VCC outputs for programming or glitching attacks.

:::

Figure F.4: 6500/1 Dumper from Brain (2014)

::: image
[]{#app06.xhtml_page_367
.pagebreak}![Image](images/f0367-01.jpg){#chFfig5}

> **Description:** Microscopic view of metal interconnect layers showing two horizontal routing strips with complex logic gate structures. Repeated rectangular cells containing transistor patterns and via connections visible between metal layers. The regular pattern indicates standard cell library usage with multiple rows of gates. White/bright areas show metal traces while darker regions reveal underlying polysilicon and diffusion layers. This routing layer is vulnerable to microprobing attacks targeting specific signal paths.

:::

Figure F.5: Commodore 6500/1

::: image
![Image](images/f0367-02.jpg){#chFfig6}

> **Description:** Die photograph of secure microcontroller with extensive bond pad array. Left side shows large memory block with dense cell structure. Center and right sections contain mixed logic blocks, memory arrays, and control circuits. Four large square pads visible in upper left corner likely for power/ground connections. Vertical memory arrays run through right side with characteristic striped appearance. Scattered logic regions throughout suggest complex security peripherals, potential targets for side-channel or fault injection attacks.

:::

Figure F.6: 6500/1 ROM Bits

::: imagel
[]{#app06.xhtml_page_368 .pagebreak}![Image](images/f0368-01.jpg)

> **Description:** Code snippet showing byte-array initialization from raw ROM file. Variables: rawfile (input), outfile (output), numbytes (length), numbits (bytes*8). Creates rawbits and outrom byte arrays with pgorder sequence {15,14,12,13,11,10,8,9,7,6,4,5,3,2,0,1}. Nested loops convert raw ROM bytes to bit array by extracting individual bits via shift operations. Final triple-nested loop reorganizes bits using pgorder mapping to address format: (127-pc)*128 + (7-b)*16 + pgorder[pa], implementing ROM image transformation for reverse engineering.

:::

In both cases, an AVR reads each sampled byte and forwards it out the
serial port for a waiting desktop to receive. This successfully
extracted the firmware and fonts of the Commodore 1520 plotter.

In addition to the test modes, the ROM of this chip is easily
photographed. The sample bits in [Figure F.6](#app06.xhtml_chFfig6) were
seen after decapsulation with HNO~3~ and delayering with dilute HF.

### **F.4 TMP90 External Memory** {#app06.xhtml_app06_4 .h3}

Galiano (2023) is a fully functional exploit for the TLCS-90 series of
Z80 microcontrollers from Toshiba. Examples include the TMP90C840AN and
TMP90CM40AN, as well as chips such as the TMP91C640N from the related
TLCS-900 series. The exploit depends upon a non-maskable interrupt (NMI)
pin, so it is not compatible with the entire series; the TMP90C844AN,
TMP91-C642AN and TMP90CH44N are not vulnerable.

Galiano begins with the EA pin, which controls whether the chip boots
from internal ROM or from external memory. It's []{#app06.xhtml_page_369
.pagebreak}not quite as easy as booting externally and dumping the ROM,
however. The EA pin is only sampled at reset and it disables internal
ROM at the same time it selects booting from external memory.

His exploit boots from an external EEPROM. He then uses a trick in how
Z80 chips set up the call stack to execute from this EEPROM again while
internal ROM is still enabled and the default boot target.

Z80 chips such as the TLCS-90 series do not reset their stack pointers
in hardware at reset. Rather, the first instruction usually sets the
stack pointer. By triggering an NMI before that instruction begins to
execute, Galiano redirects execution to the NMI interrupt handler
*before* the stack pointer is valid!

When the stack pointer was previously set to EEPROM rather than SRAM,
the target chip will save the [AF]{.literal} and [PC]{.literal}
registers to the poorly located stack. [AF]{.literal}'s value doesn't
matter and [PC]{.literal} will probably be [0x9000]{.literal} at this
moment. Neither value is written to the EEPROM, because EEPROMs don't
accept random writes, so on return from the interrupt handler the
program counter is forced to the value in the read-only stack.

That code can then initialize the stack pointer to an address in SRAM
and proceed to freely read all internal ROM or PROM, dumping it out a
serial port or copying it to a new memory chip.

### **F.5 Mostek 3870 (Fairchild F8)** {#app06.xhtml_app06_5 .h3}

Boris Diplomat, Chess Traveler, and a number of other chess computers
from the late Seventies use a variant of Fairchild's F8 architecture
called the Mostek MK3870. Riddle (2013) and Rock (2013) describe
electrical dumps using a test mode of this chip.

::: image
[]{#app06.xhtml_page_370
.pagebreak}![Image](images/f0370-01.jpg){#chFfig7}

> **Description:** Full die photograph of large microcontroller with extensive bond pad perimeter and multiple mounting holes. Center region dominated by massive memory array showing characteristic striped pattern suggesting DRAM or large SRAM. Left side contains control logic and peripheral circuits. Right edge shows smaller memory blocks and interface logic. Lower section displays additional horizontal memory structures. Bond pads completely surround die for power, ground, and I/O connections. Large die size indicates feature-rich device with substantial storage capacity.

:::

Figure F.7: Mostek MK3870

[Page 16](#ch02.xhtml_ch2fig1) of Mostek (1978) describes the behavior
of the TEST pin, which activates different testing modes depending upon
the voltage:

::: bq
[]{#app06.xhtml_page_371 .pagebreak}In normal operation the TEST pin is
unconnected or is connected to GND. When TEST is placed at TTL level
(2.0V to 2.6V) port 4 becomes an output of the internal data bus and
port 5 becomes a wired-OR input to the internal data bus. The data
appearing on the port 4 pins is logically true whereas input data forced
on port 5 must be logically false.

When TEST is placed at a high level (6.0V to 7.OV), the ports act as
above and additionally the 2K *×* 8 program ROM is prevented from
driving the data bus. In this mode operands and instructions may be
forced externally through port 5 instead of being accessed from the
program ROM. When TEST is in either the TTL state or the high state,
STROBE ceases its normal function and becomes a machine cycle clock
(identical to the F8 multi-chip system WRITE clock except inverted).
:::

In shorter terms, the TEST pin can put the chip into three possible
states: 1) normal execution when the TEST pin floats, 2) ROM enabled
when the TEST pin is at 3.5V (TTL voltage) and 3) ROM disabled when the
TEST pin is at 7V (high voltage). These latter two modes are both for
testing, and the difference is in whether the internal ROM is or is not
allowed to drive the data bus.

To dump the ROM, Riddle first moved the pin to high voltage, disabling
the ROM so he can inject a load instruction. As the instruction
executes, he then drops the pin to TTL voltage, re-enabling the ROM so
the load instruction receives its data.

While Riddle's original exploit used a PIC 18F4620 for voltage
compatibility, Rock preferred a Raspberry Pi Pico and level
[]{#app06.xhtml_page_372 .pagebreak}translators.

A direct port of Riddle's exploit from PIC BASIC Pro was not functional,
so significant structural changes were made to more generically inject
code and read back the results. Between that and a little error
correction, it successfully dumped the firmware from an HP82143 printer
with no damage.

### **F.6 MC6801 Test Mode** {#app06.xhtml_app06_6 .h3}

The MC6801 microcontroller is capable of running from either internal or
external ROM. Lind (2019) is an open source project for electrically
dumping ROMs from Motorola MC6801.

Motorola (1984) describes Test Mode Zero, whose memory map is shown in
[Figure F.8](#app06.xhtml_chFfig8). From Section 2.3, the mode selection
is a little tricky but taken care of by pins at reset:

::: bq
The MC6801 operating mode is controlled by the levels present at pins 8,
9, and 10 during the rising edge of RESET. These same three pins,
however, also function as the least three significant bits of Port 2.
The operating mode is latched into the MCU Program Control Register on
the rising edge of RESET after which time the levels can be removed and
the·pins used for other purposes. The operating mode can be read from
the Port 2 data register where the values PCO (Pin 8), PC1 (Pin 9), and
PC2 (Pin 10) appear as data bits D5 through D7, respectively.
:::

By selecting Test Mode 0, Lind's exploit forces the reset vector to be
read from the external EEPROM rather than from the internal ROM. At this
point, code is executing from external memory and capable of freely
reading internal memory.

::: image
[]{#app06.xhtml_page_373
.pagebreak}![Image](images/f0373-01.jpg){#chFfig8}

> **Description:** Memory map diagram for MC6801/MC6801 MODE 0 (multiplexed test mode) showing address space organization. Internal segments (hatched): $0000-$001F Internal Registers, $0020-$007F Internal RAM, $F800-$FFFF Internal ROM including interrupt vectors at $FFFF. External Memory Space (white) occupies $0080-$F7FF range. Notes indicate specific addresses ($04-$09) excluded externally, external RESET initialization within 2 cycles after positive edge, no overlapping internal/external spaces after 2 MPU cycles, and MODE 0 as only option for examining interrupt vectors using external RESET with RAME (RAM Enable bit) set.

:::

Figure F.8: Test Mode Memory Map from Motorola (1984)

[]{#app06.xhtml_page_374 .pagebreak}Lind's shellcode is a fork of Daniel
Tufvesson's MC3 monitor in a normal EEPROM, with a GAL16V8 PLD to manage
the reset sequencing and memory bus. After the victim chip boots the
monitor, standard monitor commands can be sent to dump the contents of
internal ROM over the chip's serial port.

### **F.7 NEC uCOM4 Test Mode** {#app06.xhtml_app06_7 .h3}

NEC's uCOM4 series consists of 4-bit microcontrollers with mask ROM,
such as the D552 and D553. Kevin Horton and Sean Riddle investigated
these as a way to recover ROMs from antique checkers and chess games.

Riddle's extraction technique involves mask ROM photography, which is
very portable but can be labor intensive in the decoding. His decoder is
shown in [Figure F.9](#app06.xhtml_chFfig9), revealing that sixteen
pages exist in each of the 128 rows, with each pair of pages being in
the opposite order. Riddle (2023) shows the ROM after delayering.

A non-destructive method in Horton (2023) is electrical rather than
photographic. The chip has a test pin that causes it to stop the CPU and
dump bits to the GPIO pins, but it only does this within a 256-byte page
of memory. It does this in a loop, so you do get all the bytes, but you
don't necessarily know how they are aligned.

To electrically extract other pages, you must single-step the CPU until
it performs a jump into another memory page, then use the test pin to
dump that page. Within that page it will begin dumping at the program
counter value, so the bytes of the page will have some offset that must
be corrected. By identifying jump points within known pages and
arranging for jumps to be taken, any page with reachable code can be
dumped.

::: image
[]{#app06.xhtml_page_375
.pagebreak}![Image](images/f0375-01.jpg){#chFfig9}

> **Description:** Code snippet demonstrating raw ROM file to binary conversion with bit reordering. Reads ffredraw.bin, creates bit array (numbits = numbytes*8), and applies bit extraction via shift-and-mask operations. Uses pgorder array {15,14,12,13,11,10,8,9,7,6,4,5,3,2,0,1} to scramble bit positions. Triple-nested loop iterates through 16 pages, 128 rows, and 8 bits per byte, calculating output index as (127-pc)*128 + (7-b)*16 + pgorder[pa]. Writes transformed binary to fffred.bin for ROM image reconstruction or security analysis.

:::

Figure F.9: Fabulous Fred Decoder by Sean Riddle

::: image
[]{#app06.xhtml_page_376
.pagebreak}![Image](images/f0376-01.jpg){#chFfig10}

> **Description:** Die photograph showing memory array with horizontal striping across upper and middle sections. Dense regular cell structure indicates large memory blocks with word-line organization. Lower section features repetitive decoder or sense amplifier circuitry arranged in vertical columns. Peripheral regions along edges contain analog circuits or voltage regulators. The uniform striping pattern makes this memory vulnerable to optical probing or laser fault injection attacks targeting specific address ranges or data cells.

:::

Figure F.10: Fabulous Fred uCOM4 ROM

::: image
[]{#app06.xhtml_page_377
.pagebreak}![Image](images/f0377-01.jpg){#chFfig11}

> **Description:** High-magnification die photograph of memory array section showing extremely regular cell structure. Vertical columns represent bit-lines while horizontal rows are word-lines in dense memory matrix. Darker horizontal bands indicate metal routing layers connecting memory cells. Lighter regions show polysilicon gate structures forming transistor arrays. The repetitive pattern suggests SRAM or register file with several hundred visible cells. This regularity enables precise fault injection targeting individual bits for security bypass or data corruption attacks.

:::

Figure F.11: EMZ1001E Diffusion ROM

### []{#app06.xhtml_page_378 .pagebreak}**F.8 AMI S2000 and Iskra EMZ1001** {#app06.xhtml_app06_8 .h3}

Yugoslavia's only microcontroller, the Iskra EMZ1001, is a variant of
AMI's S2000 series, right down to an AMI logo on the die. Unlike the
Soviet clones, this one seems to have been licensed by AMI as a
cooperative venture. Zoltan Pekic implemented an EMZ1001 clone in VHDL
as Pekic (2022), and he graciously pointed me to a test mode in the
documentation.

The trick, found on page 4.9 of AMI (1979), is in the interaction of the
ROMS and SYNC pins. The explanation is short, and easy to skip over if
you aren't looking so closely as to clone the chip. The ROMS pin is
described like so:

::: bq
ROM source control. Tied to a logic 1 or 0 to indicate internal ROM
only, or internal plus external. Tied to SYNC to override Bank 0 with an
external program, and to inverted SYNC to verify internal ROM contents.
:::

So by inverting the SYNC signal into ROMS, we can force the chip into
verification mode. The instruction decoder will be fed dummy
instructions while the program counter counts forward and the data pins
output the internal ROM contents.

If you are impatient, the ROM bits are also visible. [Figure
F.11](#app06.xhtml_chFfig11) shows the bits of an EMZ1001E
microcontroller after delayering with HF.

### []{#app06.xhtml_page_379 .pagebreak}**F.9 TMS1000 Test Mode** {#app06.xhtml_app06_9 .h3}

It's often hard to know for sure that a given patent matches a given
chip, and this isn't made any easier when multiple patents likely refer
to the same chip. Caudel and Raymond (1974) is the patent for Texas
Instruments' TMS1000 chip, describing many of its internal signals and a
test mode for dumping the internal ROM contents. This test mode does not
appear in the datasheet, programmer's reference manual, or other
official documentation.

Another filing, Boone and Cochran (1977) is frequently cited as the
TMS1000 patent. Both chips have 28 pins. Both chips are intended for
ROM-programmed calculators. The TMS1000 clearly has a ROM width of eight
bits. Boone and Cochran's chip, however, has 11-bit instructions like
the TMS0801. See Ilmer (2024) for an excellent tutorial on dumping that
chip's ROM, including detailed notes on determining the ROM bit
ordering.

Caudel and Raymond's patent also has a black and white die photograph
that is quite close to the TMS1000, along with a set of opcodes that
match. Column 28 of their patent describes four test mode operations.

Operation 1: The ROM word address is loaded into the program counter
serially from keyboard pin K1 under the control keyboard pin KC. Setting
KC to Vss causes the bit to be sampled on *ϕ*1 time, when the program
counter is not otherwise in use. (The chip's clock is divided into five
signals, of which *ϕ*1 is the first. See Figure 24 in the patent for
details.)

Now, if you are following along with the patent and datasheet, you might
note that there is no KC pin on the datasheet. This can be explained by
documentation change between the patent and the datasheet. The patent
groups KC along with four keyboard input pins as signal 75 on the die
photograph in [Figure F.12](#app06.xhtml_chFfig12), while the datasheet
places an INIT pin at that same location.

::: image
[]{#app06.xhtml_page_380
.pagebreak}![Image](images/f0380-01.jpg){#chFfig12}

> **Description:** Labeled die photograph (Fig.26) showing numbered component locations across integrated circuit. Large memory blocks labeled #4 (left center, dense array) and #7 (upper right, smaller array). Logic regions marked #1, #2, #3 (upper left), #5 (center), #6 (right edge). Test points or bond pads numbered #8-#23, #24-#33, #34-#42, #43-#46 arranged around perimeter. Labels #47-#52 mark bottom edge pads. Reference numbers #53-#55 indicate specific circuit blocks. Essential reference for identifying attack surfaces and probe points during hardware security analysis.

:::

Figure F.12: Prototype from Caudel and Raymond (1974)

::: image
![Image](images/f0380-02.jpg){#chFfig13}

> **Description:** Die photograph of compact microcontroller with clear functional segregation. Large memory array left side shows dense cell matrix. Upper center contains multiple smaller memory blocks arranged horizontally. Right side features logic circuits, peripheral interfaces, and I/O buffers. Bond pads arranged around full perimeter with several mounting holes visible as black circles at corners and edges. Lower section displays additional memory and control logic. White regions indicate metal layers while darker areas show underlying transistor structures, offering multiple probe points for hardware analysis.

:::

Figure F.13: TMS1000

::: image
[]{#app06.xhtml_page_381
.pagebreak}![Image](images/f0381-01.jpg){#chFfig14}

> **Description:** Pin-out diagrams for three TMS microcontroller variants. TMS 1000/TMS 1100 (28-pin DIP): pins include R0-R8 outputs, K1-K4/K8 inputs, VDD power, INIT control, and OSC1-OSC3 oscillator pins. TMS 1200 (40-pin DIP): expanded with R0-R10, O1-O7 outputs, K1-K8 inputs, similar power/oscillator configuration. TMS 1300 (40-pin DIP): modified pinout with R11-R13 replacing some K inputs, maintaining OSC2/OSC3 and NC (no connect) positions. These diagrams identify critical power glitching targets and debug interface access points for hardware attacks.

:::

Figure F.14: TMS1000 Pinouts

Input and output pins also have different labels, so expect a little
confusion as you go along.

Operation 2: The ROM page address is loaded in parallel on the K1, K2,
K4, and K8 keyboard pins. If the KC pin is at -Vdd on clock phase *ϕ*2,
four bits will be sampled. Note that this parallel load of the page
address happens at a different clock phase than the word address; the
patent suggests a speed hack here of quickly iterating the page address
while rarely adjusting the word address.

Operation 3: The eight-bit word at the chosen ROM address can be loaded
into the program counter by the internal !BRNCAL signal, which is
produced by a combination of the KC and K2 pins.

Operation 4: The result of the fetch from the third operation can be
read serially out of an output pin under the control of the
[]{#app06.xhtml_page_382 .pagebreak}KC pin. Helpfully, this serial
transfer can happen at the same time but one phase ahead of loading a
new address with the first operation.

My description sadly lacks a few details, and I doubt I'll ever really
understand this test mode before using it to dump a chip. If you
implement it before I do, kindly send along an email with a copy of your
paper and a list of any errata that I ought to correct in this appendix
entry.

### **F.10 Z8 Test ROM** {#app06.xhtml_app06_10 .h3}

I can't cite any modern use of this test mode, but many of the Zilog Z8
chips such as the Z8601 and Z8611 hold a test ROM in addition to the
main program ROM. This is explained in Zilog (1982), where the purpose
of the test ROM is to test those few features which cannot be directly
exercised from the external EEPROM code that performs the majority of
testing.

The first clue comes from die photography, where the ROM is larger than
expected. The internal ROM of the Z0860008PSC, for example, contains 256
columns by 66 rows, rather than the expected 64 rows. This is 64 bytes
more than the two kilobytes advertised in the datasheet.

From Zilog (1982), we find that these bytes contain something like the
test ROM in [Figure F.16](#app06.xhtml_chFfig16). The test ROM replaces
the application ROM if the !RST pin is held 2.5 volts higher than VCC
for at least eight clock cycles, after which it can be relaxed to the
normal voltage. That's 7.5 volts for a 5-volt chip.

The test ROM is too small to test very much, so it first maps external
memory through the IO ports and calls into that external memory. It then
branches to [0x0812]{.literal} (or [0x1012]{.literal}) in the external
memory, where the EEPROM example disables interrupts and runs a testing
loop, often calling back into the test ROM. Callbacks seem to be used to
test the I/O ports that are used for external memory access; they aren't
used for convenient like a PC BIOS call.

::: image
[]{#app06.xhtml_page_383
.pagebreak}![Image](images/f0383-01.jpg){#chFfig15}

> **Description:** Die photograph of complex processor showing dual large memory arrays in upper left and center-right regions. Dense standard cell logic fills most of die area with interconnected metal routing layers. Lower central region contains control logic and possibly cryptographic accelerators. Right edge shows smaller memory blocks and peripheral interfaces. Bond pads completely surround die perimeter with multiple power/ground connections. Dark rectangular blocks scattered throughout are decoupling capacitors or voltage regulators. High complexity suggests security-focused design with potential tamper-detection circuits requiring careful fault injection targeting.

:::

Figure F.15: Zilog Z8611

::: image
[]{#app06.xhtml_page_384
.pagebreak}![Image](images/f0384-01.jpg){#chFfig16}

> **Description:** Assembly code listing for Z8 Internal Test ROM Program showing interrupt vector initialization and test procedures. Interrupt Vector Array at addresses 0x0800-0x080f defines six vectors. Entry point 000c: Internal Test Procedure loads immediate values to P01M ($96), executes external jump (JP EXT), then defines dw 0x0812. START block at 0x0099 contains test sequences loading values to P01M R9, P3M R10, R4 SR3, and performing port operations (LD @R13 R14 for WRITE PORT, COM @R13 for WRITE PORT, LD R5 %E3, LD R6 @R11 for READ PORT & STUFF DATA, LD R7 @R11 for DITTO, LD R8 %E3 for TEST RDY=1,DAV=1). Configures external test jump (LD P01M R12, JP VERIFY1) and verification routine without high-speed support (START TEST NO H.S.).

:::

Figure F.16: Z8601 Test ROM

::: image
![Image](images/f0384-02.jpg){#chFfig17}

> **Description:** Assembly code listing for Z8 External Test EEPROM Program showing interrupt vector handling and test procedures. Comments indicate vectors aren't used (all just loop with db 0x8d, JP instructions). Entry point at 0x8f disables interrupts (db 0x8f). External test procedure includes 19-line sequence without verification, comprising loads, increments, jumps across addresses 0x98-0xe1. Key operations: save result in R9 (LD R9 %E1), loop configurations (LD R9 0x98, LD R9 %E1), external mode settings (P1&P0=EXT,STK-IN,NORMAL and P1&P0=EXT,STK,IN,NORMAL), verification jumps to VERIFY2. This code enables external EEPROM testing and potential security bypass through test mode exploitation.

:::

Figure F.17: Entry to a Z8601 Test EEPROM

[]{#app06.xhtml_page_385 .pagebreak}When running in the test mode, the
[lde]{.literal} instruction can fetch bytes from the test ROM while the
[ldc]{.literal} instruction fetches words from the application ROM. That
and a simple loop ought to be enough to dump the ROM, without bothering
to call back into the test ROM.

The ROM variants of these chips can also be dumped photographically.
They use a diffusion ROM whose bits become visible after delayering with
HF.[]{#app06.xhtml_page_386 .pagebreak}

[]{#app07.xhtml}

