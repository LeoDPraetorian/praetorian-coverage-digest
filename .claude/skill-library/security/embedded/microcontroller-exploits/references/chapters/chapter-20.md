## []{#ch20.xhtml_page_185 .pagebreak}**20  MSP430 Paparazzi Attack** {#ch20.xhtml_ch20 .h2a}

Early MSP430 families, such as the MSP430F1xx, F2xx, and F4xx, are
vulnerable to a semi-invasive attack, first publicly documented in
Thomas (2014), in which a camera flash is used to fake out the fuse
check while a JTAG debugger attempts to attach in a tight loop.

These chips have two access controls. JTAG is protected by a metal
migration fuse; this is a thin trace of metal on the die that
permanently breaks when too much current flows through it. Entirely
unrelated to the fuse is a 32-byte password that is required to access
the serial bootstrap loader (BSL). This password is the interrupt vector
table (IVT) at the end of memory, and without it, the BSL allows little
more than erasing all of memory. Because the BSL cannot read the
protection fuse, you can exploit the chip by first dumping the last 32
bytes of flash memory and then presenting them to the bootloader.

The first thing to understand is that all of the transistors within the
chip are actually phototransistors. If a sufficiently bright light hits
one of these transistors, it will conduct electricity even if
electrically it should be in a non-conducting state. CMOS technology
gains its power efficiency by balancing each conducting transistor
against a non-conducting transistor, and a bright camera flash throws
all of the design constraints out the window. The Raspberry Pi 2 was
famous for this, crashing violently when photographed because of an
exposed die on the
PCB.^[1](#footnotes.xhtml_ch20fn1){#ch20.xhtml_ch20fn_1}^

::: image
[]{#ch20.xhtml_page_186
.pagebreak}![Image](images/f0186-01.jpg){#ch20fig1}

> **Description:** Die photo of a complex microcontroller showing diverse functional blocks distributed across the chip. The right side contains two large dark rectangular memory arrays, likely flash or SRAM. The center and left portions show various logic blocks with different densities, including control circuitry, peripheral interfaces, and I/O controllers. Bond pads line all edges for external connections. The varied circuit densities and structures indicate a feature-rich microcontroller with multiple integrated subsystems and substantial memory capacity.

:::

Figure 20.1: MSP430F449

[]{#ch20.xhtml_page_187 .pagebreak}The second thing to understand is
that the MSP430's JTAG port is locked by a hardware fuse, at least in
devices prior to the MSP430F5xx family. When you connect a JTAG
debugger, it tests the fuse by running a little current into it from the
TDI pin. If the test is successful, JTAG unlocks and the chip may be
read. If the test is not successful, a "no harm no foul" policy allows
more fuse read attempts in all but the very earliest chips.

To unlock these chips, we'll first remove the opaque packaging by
performing a live decapsulation using the red fuming nitric acid (RFNA)
drip method. After exposing the die, we'll attach the chip to a GoodFET
for JTAG debugging, modifying the GoodFET to repeatedly attempt JTAG
fuse checks until success. By flashing a camera on the exposed die,
we'll then bypass the fuse check and enable debugging on a locked chip,
allowing the firmware to be freely dumped.

### **Live Decapsulation with RFNA** {#ch20.xhtml_ch00lev1sec57 .h3}

The live decapsulation procedure presented here is conceptually similar
to the full decapsulation that we covered in [Chapter
18](#ch18.xhtml_ch18), but with some key differences to keep the bond
wires and some of the packaging intact, so that the chip still functions
despite the die being visible. If you do not have a chemistry lab
available, and are not crazy enough to build your own, you can hire a
failure analysis laboratory to perform the procedure for you.

Instead of the 65% nitric acid that sometimes dissolves bonding wires,
we'll be using red fuming nitric acid (RFNA), which is a minimum of 90%
nitric acid and a maximum of 2% water. This is strong stuff that reacts
violently with nitrile gloves and isopropyl alcohol, so be sure to work
in a fume hood, with full safety gear.

Begin with your target chip soldered to a carrier PCB, with no other
components. Heat it to about 100 °C, well beneath the melting point of
the solder but hot enough for the acid to attack the packaging.

::: image
[]{#ch20.xhtml_page_188
.pagebreak}![Image](images/f0188-01.jpg){#ch20fig2}

> **Description:** Photograph of "THE NEXT HOPE" conference badge, a circular PCB designed as a film reel dated July 2010. The board features two reel designs on the left and right sides with sprocket holes, and a central film strip pattern. Two prominent ICs are mounted in the center - a larger square chip on the left and a smaller rectangular chip on the right. Multiple LEDs or connection points are arranged around the perimeter. The badge includes the conference branding and represents creative hardware design for a hacker conference badge.

:::

Figure 20.2: Live Decapsulated MSP430F2418

[]{#ch20.xhtml_page_189 .pagebreak}Your goal is to expose the die in the
center without spilling acid onto the pins or the PCB. At the beginning,
the chip's packaging has a flat surface, so any significant amount of
acid will spill off. Begin with a little RFNA in a cold beaker and use a
pipette with a very narrow tip to drip just the smallest possible amount
of acid onto the dead center of the chip package.

A quick but important note on acid volume: if a droplet forms at the tip
of the pipette, you're about to use too much acid. You really want as
little acid for your first drop as possible. Imagine that you are using
the pipette as a fountain pen to write on paper.

The acid will first appear to soak into the surface of the chip, and
then it will begin to bubble a little bit. After allowing for a little
bubbling to break apart packaging material, use a squirt of acetone to
clean off the acid and leave the remainder of the packaging. Repeating
this a few times will give you a sort of bowl-shaped cavity within the
package, and you can begin to use a little more acid to speed up the
etching.

After each acetone rinse, carefully inspect the package under bright
light. When you begin to see the bonding wires glinting in the otherwise
black packaging, you are getting close to the bare die. At this stage
you should rinse a little sooner, to ensure that the acid doesn't boil
away and leave ugly plastic markings that obscure the die.

If this procedure is successful, you should have a package whose pins
and their surrounding packaging are intact, while the die and its
bonding wires are exposed. The die will not be quite so clean as one
prepared by the bath methods, but the little bit of dirt that remains on
the surface won't interfere with this attack.

Be sure to carefully rinse the chip and board with first acetone and
then isopropyl alcohol and deionized water to prevent any
[]{#ch20.xhtml_page_190 .pagebreak}leftover acid from dissolving traces
on the board or oxidizing the pins. This final cleaning should be the
only use of isopropyl alcohol in your experiment, because the alcohol
violently reacts with RFNA, and unintentional lab explosions are
generally frowned upon. Similarly, water will remove the metal salts
that protect bond wires and the frame from HNO~3~, so you should avoid
it until the very last cleaning.

### **Fuse Check Sequence** {#ch20.xhtml_ch00lev1sec58 .h3}

Now that we've opened the packaging on our target chip, the next step is
to trigger the fault. To do this yourself, you will need a JTAG
programmer with source code available, such as Good-speed (2009), and
also the JTAG specification of the MSP430 chips, Texas Instruments
(2010).

I suppose we might use a laser with fine pulse control to fire at
exactly the right spot and exactly the right
time.^[2](#footnotes.xhtml_ch20fn2){#ch20.xhtml_ch20fn_2}^ Thankfully,
this is unnecessary if we modify our JTAG programmer a little. For this
example, we'll be using my open source GoodFET programmer, even though
it's a little out of date.

[Figure 20.3](#ch20.xhtml_ch20fig3) shows the hardware fuse check
sequence for the MSP430F1xx, F2xx, and F4xx devices. The check is
performed by toggling the TMS pin at least twice; if the fuse is not
blown, two milliamps of current will flow into the TDI pin. [Figure
20.4](#ch20.xhtml_ch20fig4) is an example implementation of the JTAG
fuse check sequence in C from my GoodFET project.

Devices with the original MSP430 CPU and the CPUX extension have an
erratum in which they might fail the fuse test when powering up,
requiring another power cycle before the fuse may be tested again.
CPUXv2 devices clear the fuse check result as the JTAG TAP is reset, and
this might complicate exploitation when you are faking the fuse check
with a camera flash.

::: image
[]{#ch20.xhtml_page_191
.pagebreak}![Image](images/f0191-01.jpg){#ch20fig3}

> **Description:** Timing diagram showing JTAG signal waveforms for TCK (clock), TMS (mode select), TDI (data in), TDO (data out), and TCLK signals. The diagram illustrates two operations: TAP Reset (showing multiple TCK cycles with TMS high) and Fuse Check (shorter sequence with different TMS patterns). Vertical dotted lines mark timing boundaries between operations. TDI and TDO lines show data transmission periods as gray bars. This demonstrates standard JTAG protocol timing for test access port operations.

:::

Figure 20.3: MSP430 JTAG Fuse Check Sequence

::: image
![Image](images/f0191-02.jpg){#ch20fig4}

> **Description:** C code function jtag430_resettap() for resetting a JTAG Test Access Port. The function declares an integer i and settles output by calling SETTDI (430X2 variant). It then calls SETTMS and classic SETTDI, executes jtag_tcktock(), navigates to reset state with a for loop executing jtag_tcktock() 4 times, performs test-logic-reset (CLRTMS, jtag_tcktock(), SETTMS), and ends with a fuse check sequence (CLRTMS, delay(50), SETTMS, CLRTMS, delay(50), SETTMS). This implements standard JTAG state machine reset protocol.

:::

Figure 20.4: MSP430 Fuse Check in Goodspeed (2009)

[]{#ch20.xhtml_page_192 .pagebreak}MSP430F5xx and F6xx devices have done
away with the hardware fuse check, instead implementing their readout
protection with a software mechanism. This chapter's attack is not
expected to apply to those devices.

Having a functioning target chip with an exposed die, exploitation
consists of repeatedly attempting a fuse check, then looking to see
whether it has been accepted, at the same time that camera flashes are
applied to the die. The sequence from [Figure
20.3](#ch20.xhtml_ch20fig3) can be modified in two ways: either the
sequence can be repeated until the check is successful or the number of
cycles on the TMS pin can be extended to make more attempts at passing
the test.

On the hardware end, the target chip consumes quite a bit of power when
a camera flash appears over the die. We are not attempting voltage
glitching, so the transient power consumption should be handled by
decoupling capacitors and perhaps also a bench power supply.

When the entire arrangement is in place, roughly one camera flash in
four should unlock the target and allow a JTAG connection to be
established. Be very careful in your setup to hold this connection open,
never resetting the chip in a way that would require a fresh fuse check.

You should also expect that after a connection is established, the flash
memory might have read errors from the camera flash for a little while
until it settles down to the permanently stored values. I resolve this
by repeatedly reading all flash memory a few times, saving the early
reads in case I need them but relying on the latter reads for the real
program contents. This effect of the memory being stunned might also be
used to temporarily corrupt the password of the resident serial
bootstrap loader (BSL) that resides in ROM and ignores the JTAG
protection fuse.

[]{#ch21.xhtml}

