## []{#ch09.xhtml_page_99 .pagebreak}**9â€‚nRF51 Gadgets in ROM** {#ch09.xhtml_ch09 .h2}

First documented in Brosch (2015), this chapter describes an exploit for
extracting protected memory from the nRF51822 despite code protection
features. The vulnerability is that while the debugger cannot read
protected memory directly or write shellcode to SRAM, it can single-step
through the protected code in flash memory.

Although this version is described for the nRF51 series, a similar bug
is described in Obermaier, Schink, and Moczek (2020) for the CKS32F103
and GD32VF103, which are clones of the popular STM32F103. Kovrizhnykh
(2023) notes that the SN32F248B from Sonix has been exploited by the
same technique.

### **Learning All the Rules** {#ch09.xhtml_ch00lev1sec34 .h3}

The nRF51's protection mechanism, documented in [Chapter
9](#ch09.xhtml_ch09) of Nordic (2014), is built as an extension of the
memory protection unit (MPU). An MPU is sort of like a memory management
unit (MMU), except that it is coarser-grained and provides no support
for virtual memory.

The most common readout protection for this chip is called Protect All
([PALL]{.literal}), which is configured by writing zero into the I/O
port [UICR.RBPCONF.PAL]{.literal}. This is designed to prevent the SWD
debugger from accessing code region 0, code region 1, RAM, or any
peripherals except for the [NVMC]{.literal} peripheral, the
[RESET]{.literal} register in the [POWER]{.literal} peripheral, and the
[DISABLEINDEBUG]{.literal} register in the [MPU]{.literal} peripheral.
You will often see a bootloader perform this protection at every boot,
but the protection persists. It is only necessary to apply the
protection once.

::: image
[]{#ch09.xhtml_page_100
.pagebreak}![Image](images/f0100-01.jpg){#ch9fig1}

> **Description:** Die photo of an embedded microcontroller with distinct functional blocks. The left side contains large regular memory arrays for SRAM and potentially flash memory. The center and right portions show logic circuitry with varying densities. In the lower right, a dense grid-like structure is visible, likely representing ROM or another memory block. The upper right contains control logic and peripheral interfaces. Bond pads are arranged around the perimeter for external connections.

:::

Figure 9.1: NXP nRF51822

::: image
[]{#ch09.xhtml_page_101
.pagebreak}![Image](images/f0101-01.jpg){#ch9fig2}

> **Description:** Memory map diagram showing ARM Cortex-M address space organization. Starting at address 0x0000 0000, regions include Boot Memory Alias, FICR (Flash Information Configuration Region at 0x1000 0000), UICR (User Information Configuration Region at 0x1000 1000), SRAM (0x2000 0000), APB Peripherals (0x4000 0000), AHB Peripherals (0x5000 0000), and Private Peripheral Bus (0xE000 0000). Each region is separated by ellipses indicating address gaps.

:::

Figure 9.2: nRF51822 Memory Map

::: image
[]{#ch09.xhtml_page_102
.pagebreak}![Image](images/f0102-01.jpg){#ch9fig3}

> **Description:** Ruby script for dumping memory via debug interface over telnet. The code connects to localhost:4444, iterates through addresses from 0x00000000 to 0x00040000 in steps of 4, and for each address executes "reset halt", "step", reads register r3, then steps again. The value is extracted via regex matching 0x[0-9a-fA-F]{8}, packed as unsigned 32-bit value, and written to dump.bin. Progress is printed showing address and value in hex format.

:::

Figure 9.3: Brosch's PoC nRF51822 Exploit

There are also lesser protection modes, which restrict code region 1
from accessing code region 0. The purpose of these modes is to protect
soft devices, binary blob radio drivers that often require commercial
licensing but still allow custom code to sit alongside. These blobs
freely run in the lower region, and while the upper region can call into
the lower, it cannot read that region as data.

The reference manual also mentions that whatever the protection mode,
CPU fetches from code memory will not be denied and that the interrupt
table from [0x00]{.literal} to [0x80]{.literal} is not protected.

### []{#ch09.xhtml_page_103 .pagebreak}**Bypassing the Rules** {#ch09.xhtml_ch00lev1sec35 .h3}

Now that we've covered the documented behavior of the protection, it's
necessary to experiment a bit and learn the unwritten rules. Kris Brosch
discovered that by attaching a debugger to a locked chip, he had quite a
bit of freedom to direct the CPU. He could read and write registers,
including the program counter. He could also read from a few
memory-mapped registers, such as the read-back protection configuration
([RBPCONF]{.literal}) at [0x10001004]{.literal}.

Most importantly, while he did not have the freedom to directly read
from protected regions with the debugger, he was able to single-step
through existing code, controlling registers both before an instruction
(as inputs) and after that same instruction (as outputs).

He reset the chip, which loads the program counter and the stack pointer
from the interrupt vector table, then read the program counter back as
[0x000114cc]{.literal}. So he knew that the value of the reset vector at
[0x00000004]{.literal} ought to be [0x000114cd]{.literal}. (Odd pointers
indicate Thumb2 mode in ARM, but the PC itself does not hold the odd
value. Instead, that status bit is held in a status register.)

Knowing one word in memory, he then repeatedly loaded all of the
registers with [0x00000004]{.literal} and jumped the PC to new addresses
until he saw [r3]{.literal} change to [0x000114cd]{.literal}, indicating
an arbitrary read gadget!

The gadget was [ldr r3, \[r3, #0\]]{.literal} and it appeared as the
second instruction in the reset handler. Repeatedly jumping into this
gadget with different values of [r3]{.literal} will expose all memory.

Brosch's proof-of-concept can be found in [Figure
9.3](#ch09.xhtml_ch9fig3). The telnet connection is to OpenOCD, and it
assumes that the gadget is found in the reset handler. You'll need to
adjust it if the gadget is found elsewhere in your
target.[]{#ch09.xhtml_page_104 .pagebreak}

[]{#ch10.xhtml}

