## []{#app03.xhtml_page_291 .pagebreak}**C  More Privilege Escalation** {#app03.xhtml_app03 .h2}

### **C.1 Game Boy Advance BIOS** {#app03.xhtml_app03_1 .h3}

Like its predecessor, Nintendo's Game Boy Advance contains a mask ROM
that executes at reset to boot a game cartridge after verifying that it
contains a valid Nintendo logo for trademark protection. In the Game
Boy, the ROM would unmap itself just before jumping into the game
cartridge, but the Game Boy Advance keeps the ROM mapped into memory. We
call this a *BIOS* because, like the BIOS ROM in an IBM PC, this ROM
contains convenience functions that are called as interrupts.

Unlike many targets in this book, the attacker has the privilege of
running arbitrary machine code on the device. This is possible with a
simple EEPROM chip wired to the right pins of a game catridge, and it
was very quickly available to hobbyists after Nintendo released the GBA.

A dump of the BIOS ROM is useful for emulating the platform, so access
restrictions are in place. The ROM is disabled whenever an address
outside of its range is fetched as code, then enabled when an address
within its range is fetched as code. This happens in hardware at the
instant of the access.

In this chapter, we'll see three methods of tricking the Game Boy
Advance into allowing a read of the BIOS ROM. One abuses a BIOS call
that has no source address restrictions, one preemptively interrupts a
BIOS call to change the source address after validation, and the third
executes instructions from unmapped memory so that the pipeline will
unlock ROM for a fetch.

::: image
[]{#app03.xhtml_page_292
.pagebreak}![Image](images/f0292-01.jpg){#chCfig1}

> **Description:** Die photograph showing asymmetric architecture with distinct functional blocks. Upper section contains small memory arrays and control circuitry. Large textured regions in center suggest flash or EEPROM with visible programming artifacts. Lower left has two large memory banks with horizontal striping, lower center shows smaller memory blocks. Right side contains peripheral logic and interface circuits. Bottom section displays regular memory structure. The heterogeneous layout with multiple memory types and scattered logic blocks requires targeted approach for each functional area during invasive attacks.

:::

Figure C.1: Nintendo GBA CPU

#### []{#app03.xhtml_page_293 .pagebreak}**MidiKey2Freq Method** {#app03.xhtml_ch00lev2sec1 .h4}

Fader (2001) is the classic exploit for dumping the BIOS ROM, recreated
in [Figure C.3](#app03.xhtml_chCfig3). It's a variant on a classic
technique of kernel memory exposure in Unix, where a system call fails
to validate the source address so the caller can peek at memory with the
kernel's privileges.

[MidiKey2Freq]{.literal} is implemented as ROM interrupt
[0x1f]{.literal}. It takes a pointer to a MIDI sample, reads four bytes
at that address, and performs an audio processing function on those four
bytes. However this audio function has neither range nor alignment
restrictions, and it leaves the top byte unchanged. Fader's exploit
loops through the ROM address space, grabbing the most significant byte
in the return value each time.

#### **Endrift Method** {#app03.xhtml_ch00lev2sec2 .h4}

For a while it was thought that the [MidiKey2Freq]{.literal} method was
the only way to dump the BIOS ROM, but that didn't seem right to Vicki
Pfau. In Pfau (2017), she presents two different black-box techniques
for dumping the BIOS ROM. Both of her techniques rely upon the ARM7's
interrupt priorities, triggering a hardware interrupt while the software
interrupt of the BIOS call is in progress.

The nested interrupt can't directly read the BIOS, but it does have full
privileges to read and write the call stack of the software interrupt in
the BIOS call.

Vicki's black-box example registers a timer interrupt to overlap with a
software interrupt call to [CPUFastSet]{.literal}. The
[CPUFastSet]{.literal} handler performs fast copies within the BIOS
address space, but it validates the source address so the caller cannot
simply export the BIOS with it. While the BIOS software interrupt is
running, it is itself interrupted by her [bbTest]{.literal} handler,
which then scans the software interrupt call stack for the source
pointer in the [CPUFastSet]{.literal} stack frame. Overwriting the
source pointer with a ROM address before returning then causes the BIOS
to proceed with an illegal copy, as the source address is only validated
at the start of the interrupt handler and not repeated for each word.

+--------------------------+-------------------------------------------------+
| []{#app03.xhtml_page_294 | SoftReset                                       |
| .pagebreak}              |                                                 |
|                          |                                                 |
| [0x00]{.literal}         |                                                 |
+--------------------------+-------------------------------------------------+
| [0x01]{.literal}         | RegisterRamReset                                |
+--------------------------+-------------------------------------------------+
| [0x02]{.literal}         | Halt                                            |
+--------------------------+-------------------------------------------------+
| [0x03]{.literal}         | Stop                                            |
+--------------------------+-------------------------------------------------+
| [0x04]{.literal}         | IntrWait                                        |
+--------------------------+-------------------------------------------------+
| [0x05]{.literal}         | VBlankIntrWait                                  |
+--------------------------+-------------------------------------------------+
| [0x06]{.literal}         | Div                                             |
+--------------------------+-------------------------------------------------+
| [0x07]{.literal}         | DivArm                                          |
+--------------------------+-------------------------------------------------+
| [0x08]{.literal}         | Sqrt                                            |
+--------------------------+-------------------------------------------------+
| [0x09]{.literal}         | ArcTan                                          |
+--------------------------+-------------------------------------------------+
| [0x0A]{.literal}         | ArcTan2                                         |
+--------------------------+-------------------------------------------------+
| [0x0B]{.literal}         | CPUSet                                          |
+--------------------------+-------------------------------------------------+
| [0x0C]{.literal}         | **CPUFastSet**                                  |
+--------------------------+-------------------------------------------------+
| [0x0D]{.literal}         | BiosChecksum                                    |
+--------------------------+-------------------------------------------------+
| [0x0E]{.literal}         | BgAffineSet                                     |
+--------------------------+-------------------------------------------------+
| [0x0F]{.literal}         | ObjAffineSet                                    |
+--------------------------+-------------------------------------------------+
| [0x10]{.literal}         | BitUnpack                                       |
+--------------------------+-------------------------------------------------+
| [0x11]{.literal}         | LZ77UnCompWRAM                                  |
+--------------------------+-------------------------------------------------+
| [0x12]{.literal}         | LZ77UnCompVRAM                                  |
+--------------------------+-------------------------------------------------+
| [0x13]{.literal}         | HuffUnComp                                      |
+--------------------------+-------------------------------------------------+
| [0x14]{.literal}         | RLUnCompWRAM                                    |
+--------------------------+-------------------------------------------------+
| [0x15]{.literal}         | RLUnCompVRAM                                    |
+--------------------------+-------------------------------------------------+
| [0x16]{.literal}         | Diff8bitUnFilterWRAM                            |
+--------------------------+-------------------------------------------------+
| [0x17]{.literal}         | Diff8bitUnFilterVRAM                            |
+--------------------------+-------------------------------------------------+
| [0x18]{.literal}         | Diff16bitUnFilter                               |
+--------------------------+-------------------------------------------------+
| [0x19]{.literal}         | SoundBiasChange                                 |
+--------------------------+-------------------------------------------------+
| [0x1A]{.literal}         | SoundDriverInit                                 |
+--------------------------+-------------------------------------------------+
| [0x1B]{.literal}         | SoundDriverMode                                 |
+--------------------------+-------------------------------------------------+
| [0x1C]{.literal}         | SoundDriverMain                                 |
+--------------------------+-------------------------------------------------+
| [0x1D]{.literal}         | SoundDriverVSync                                |
+--------------------------+-------------------------------------------------+
| [0x1E]{.literal}         | SoundChannelClear                               |
+--------------------------+-------------------------------------------------+
| [0x1F]{.literal}         | **MIDIKey2Freq**                                |
+--------------------------+-------------------------------------------------+
| [0x20]{.literal}         | MusicPlayerOpen                                 |
+--------------------------+-------------------------------------------------+
| [0x21]{.literal}         | MusicPlayerStart                                |
+--------------------------+-------------------------------------------------+
| [0x22]{.literal}         | MusicPlayerStop                                 |
+--------------------------+-------------------------------------------------+
| [0x23]{.literal}         | MusicPlayerContinue                             |
+--------------------------+-------------------------------------------------+
| [0x24]{.literal}         | MusicPlayerFadeOut                              |
+--------------------------+-------------------------------------------------+
| [0x25]{.literal}         | MultiBoot                                       |
+--------------------------+-------------------------------------------------+
| [0x26]{.literal}         | HardReset                                       |
+--------------------------+-------------------------------------------------+
| [0x27]{.literal}         | CustomHalt                                      |
+--------------------------+-------------------------------------------------+
| [0x28]{.literal}         | SoundDriverVSyncOff                             |
+--------------------------+-------------------------------------------------+
| [0x29]{.literal}         | SoundDriverVSyncOn                              |
+--------------------------+-------------------------------------------------+
| [0x2A]{.literal}         | SoundGetJumpList                                |
+--------------------------+-------------------------------------------------+

Table C.1: Game Boy Advance BIOS Interrupts

::: image
[]{#app03.xhtml_page_295
.pagebreak}![Image](images/f0295-01.jpg){#chCfig2}

> **Description:** Memory map diagram for Game Pak showing address ranges from 0000 to 0fff ffff. Regions include BIOS-System ROM (0000 0000 to 0000 3fff marked "We want this!"), On-Board WRAM (0200 0000 to 0203 ffff), On-Chip WRAM (0300 0000 to 0300 7fff), I/O Registers (0400 0000 to 0400 03fe), Display Memory (0500 0000 to 07ff ffff), and Game Pak Memory (0800 0000 to 0fff ffff). The annotation emphasizes BIOS ROM as primary extraction target containing boot code and security routines vulnerable to dumping attacks.

:::

Figure C.2: Game Boy Advance Memory Map

::: image
![Image](images/f0295-02.jpg){#chCfig3}

> **Description:** C function AgbMain implementing MIDI frequency analysis for ROM dumping. Loop iterates 0x4000 times in steps of 4, calling MidiKey2Freq with WaveData array elements at offsets (i-4) through (i-1), parameters 180-12 and 0, multiplying results by 2. Extracts upper 24 bits from each result and prints as hexadecimal sequence. Calls SoftResetRom(0) after loop. This code exploits audio synthesis routines to extract ROM contents by correlating input/output patterns, demonstrating covert channel data exfiltration through legitimate API abuse.

:::

Figure C.3: MidiKey2Freq ROM Dumper from Fader (2001)

::: image
[]{#app03.xhtml_page_296
.pagebreak}![Image](images/f0296-01.jpg){#chCfig4}

> **Description:** C function dump using inline assembly to perform memory dump operation. Code loads r0 with 0, sets r11 as output pointer, performs logical OR with 0x4000, moves value to r1, loads r12 with address 0xC14 (CpuFastSet core), adds offset to lr, pushes registers r4-r10 and lr to stack, then branches to r12 with register move. Final instruction loads r0 with 0xE000000. This assembly sequence invokes CpuFastSet BIOS function to dump protected memory regions, bypassing read restrictions through DMA-based copying.

:::

Figure C.4: Optimized GBA BIOS Dumper from Pfau (2017)

::: image
![Image](images/f0296-02.jpg){#chCfig5}

> **Description:** Assembly function read_bios implementing BIOS ROM extraction through thumb mode exploitation. Code loads r1 with 0xFFFFFFD (end of memory, thumb mode), r2 with 0x47706800 containing two thumb instructions (0068: ldr r0, [r0, 0] and 7047: bx lr). Stores r2 to [r1], then performs three bx (branch exchange) operations through r1 and lr registers. This gadget chain manipulates return addresses and mode switching to read arbitrary BIOS memory locations, defeating read protection through carefully crafted return-oriented programming.

:::

Figure C.5: BIOS Peek Function from Hearn (2017)

[]{#app03.xhtml_page_297 .pagebreak}The black box method is particularly
nice because it doesn't require the author to already have a copy of the
BIOS and the timing calibration does not need to be particularly
accurate. Vicki also presents an optimized implementation that simply
makes a [bx]{.literal} call directly into the middle of the
[CPUFastSet]{.literal}, as BIOS entry points are unenforced and that
code may always read from the BIOS. See [Figure
C.4](#app03.xhtml_chCfig4).

#### **Executing Missing Memory** {#app03.xhtml_ch00lev2sec3 .h4}

While Fader rather directly uses a BIOS call to leak memory and Pfau
reuses pieces of BIOS code by either faking a stack or modifying the
real one in a nested interrupt, Hearn (2017) goes to the absolute
extreme of sophistication. She manages to execute code from unmapped
memory at the far end of the address space, so a prefetched instruction
from the beginning of memory unlocks the BIOS before being flushed out
of the pipeline. I shit you not!

Thinking back to your undergrad computer science days, a Nineties RISC
chip like the ARM7TDMI uses a pipelined architecture. This particular
example has three pipeline stages: fetch, decode, and execute. At the
same time that the CPU is executing an instruction, it is decoding the
next instruction and fetching the instruction after that. When the
fetched and decoded instructions aren't worthwhile, they are simply
flushed away.

[]{#app03.xhtml_page_298 .pagebreak}The CPU communicates with its
peripherals, such as memories and I/O, over a bus. On ARM7TDMI, there is
a curious effect that the data lines of this bus hold their last value,
returning it whenever an unmapped address is
fetched.^[1](#footnotes.xhtml_app3fn1){#app03.xhtml_app3fn_1}^ If you
read [0xdead-beef]{.literal} from anywhere, or if you write it anywhere,
and then read from an unused address like [0x10000000]{.literal} or
[0x4bidb10c]{.literal} without any other bus access in between, you will
read back [0xdeadbeef]{.literal}. This is a quirk of the architecture,
and many others will trigger a fault or return a different
value.^[2](#footnotes.xhtml_app3fn2){#app03.xhtml_app3fn_2}^

Combining these observations, Hearn realized that if she could write two
Thumb instructions as single 32-bit word to anywhere, then jump to them
at [0xfffffffd]{.literal}, the first instruction might execute just
after the BIOS ROM's first instruction at [0x0000-0000]{.literal} is
fetched, unlocking the ROM. The few lines of Thumb assembly in [Figure
C.5](#app03.xhtml_chCfig5) accomplish this, and they are an absolute
work of art.

In reading the code, don't forget how Thumb addressing works.
[0xfffffffd]{.literal} is odd to imply Thumb mode, but the 16-bit
instruction is fetched from [0xfffffffc]{.literal}. 32 bits are fetched
at a time, and there will be no separate fetch for the second
instruction.

Line 7 writes her instruction pair to the end of memory and Line 8 jumps
to execute it at the end of memory. The [ldr]{.literal} instruction
reads whatever BIOS address is given as a parameter right back into the
return value, and the [bx lr]{.literal} instruction returns back to the
caller. "But wait," you might ask, "how is the first instruction able to
read from the BIOS ROM if we haven't yet executed anything from the
ROM?"

[]{#app03.xhtml_page_299 .pagebreak}The CPU pipeline is the answer.
Before the [ldr]{.literal} instruction loads a word from the ROM, the
pipeline will have already fetched a 32-bit word from
[0x00000000]{.literal} for decoding and eventually execution. This
unlocks the ROM for a data fetch, and it doesn't matter that these
pipelined instructions will be flushed away with the [bx]{.literal}
instruction that comes next.

### **C.2 MSP432 IP Encapsulation** {#app03.xhtml_app03_2 .h3}

IP Encapsulation (IPE) is a feature of some MSP430 and MSP432 devices
from Texas Instruments that serves roughly the same purpose as
TrustZone-M or other trusted execution environments (TEE). The idea is
that you might purchase a microcontroller with a radio library, and you
would be able to *use* the library but not *read* the library for
reverse engineering or cloning.

Like other privilege escalation exploits in this chapter, the defender
is at a distinct disadvantage. The attacker is able to run native code,
to attach a debugger, and to apply fault injection. The defender merely
hopes that TI's restrictions are sufficient to prevent extraction of
protected libraries.

Sah and Hicks (2023) describe this feature in depth, along with some
design mistakes that expose the encapsulated firmware. Two facts in
particular are important for exploitation: first, the IPE feature does
nothing to enforce specific entry points into the protected code,
allowing gadgets to be reused when called from user program memory.
Second, the IPE feature does nothing to disable the majority of
interrupt sources, and timer interrupts are particularly useful for
getting execution in the middle of the encapsulation library so that the
attacker code can learn things about the library.

[]{#app03.xhtml_page_300 .pagebreak}Exploitation details vary between
the 16-bit MSP430 architecture and the 32-bit ARM architecture used by
the MSP432. In either case, a timer with a very small count is used to
trigger an exception inside the protected library, then the exception
handler in the unprotected application observes the register states to
make informed guesses about the state of the code.

For example, if the handler observes that some extra return pointers
have been pushed to the stack, those pointers will reveal the locations
of [call]{.literal} instructions on MSP430 or
[bl]{.literal}/[blx]{.literal} instructions on MSP432. Similarly, the
attacker can locate [ret]{.literal} instructions by calling them after
setting the link register on ARM or loading a return pointer to the
stack in MSP430.

Eventually, the attacker will discover a gadget that will read an
arbitrary address into a register. Maybe the gadget returns afterward,
in which case no timer is necessary. Maybe it does not return, in which
case the timer's countdown can be used to repeatedly call into this
gadget and then bounce out again. Either way, repeated usage of the
gadget can extract all protected memory.

### **C.3 BCM11123 U-Boot and TrustZone** {#app03.xhtml_app03_3 .h3}

Cisco's model 8861 IP Phone uses a Broadcom BCM11123 CPU with TrustZone.
A TrustZone chip has two modes, with *secure* code having privileges
that the *non-secure* code lacks. It's not that the non-secure code is
exploitable, so much as that it is not trusted. Communication between
the two modes takes the form of interrupt handlers, much like system
calls from userland to a kernel.

In the case of this phone, U-Boot runs in non-secure memory, making API
calls to a TrustZone monitor in order to validate and launch a Linux
kernel. Cui and Housley (2017) is largely about EMFI attacks, but that
paper's appendix describes a nifty attack against this arrangement.

::: image
[]{#app03.xhtml_page_301
.pagebreak}![Image](images/f0301-01.jpg){#chCfig6}

> **Description:** Terminal session showing U-Boot bootloader output with memory write commands and boot attempt. User executes "mw.l 0x8e007fb0 0x8fe81c2c", "mw.l 0x8e007fb4 0x00010001", "mw.l 0x8e007fb8 0x0e000013" then "go 0x8e007eb0". Boot sequence displays U-Boot version 2011.06 (Dec 01 2014), initialization messages showing memory addresses and "Running in secure mode" status. Boot fails with "Card did not respond to voltage select!" and "MMC init failed". Memory dump reveals values at addresses 0x35004020-0x35004100. This demonstrates bootloader exploitation attempt through memory manipulation before chain-of-trust verification.

:::

Figure C.6: Cui and Housely's Exploit for the BCM11123

The authors began by faulting the phone's NAND flash during boot, in
order to drop into U-Boot's command line, much like the ROM bootloader
of the Freescale MC13224 in [Chapter 14](#ch14.xhtml_ch14). This
bootloader has handy commands for reading, writing, and executing
memory, but because it's in the non-secure world, that's not enough to
dump or control the secure side of the chip in Trust-Zone. The game is
then to find a vulnerability in the TrustZone monitor and to exploit it
from U-Boot.

The bug in question is in the [\_ssapi_public_decrypt]{.literal}
function, which lacks a necessary length check and fails to ensure that
the source and destination addresses are on the appropriate sides of the
TrustZone barrier. By carefully choosing the right parameters, Cui and
Housley were able to copy small chunks out of the secure world into
non-secured memory accessible by U-Boot, for []{#app03.xhtml_page_302
.pagebreak}reverse engineering and dumping.

They then used the same bug in the opposite direction, clobbering a
return pointer in the secure world and promote U-Boot itself to run
within the TrustZone.

### **C.4 LPC55S69 Hardware and Software** {#app03.xhtml_app03_4 .h3}

The LPC55 series of microcontrollers use the ARM Cortex-M architecture,
with TrustZone-M as a means to protect key material such as a secret key
unique to each device from the user programmed application. Ideally,
this would let a board designer install software on the chip that uses
this key material, but even a serious bug in that application software
would not allow an attacker to control the trusted zone, its software,
or its keys.

Some Cortex-M devices include a Flash Patch and Breakpoint (FPB) unit,
which allows a few words of memory to be patched, overriding their real
value with a chosen one. In devices like the LPC55 that support
TrustZone-M, that IP block is explicitly prohibited by ARM for fear that
in remapping the address space, the TrustZone-M protections might be
invalidated.

While reverse engineering an application for the LPC55S69, Laura Abbott
discovered that there is a custom module much like the forbidden FPB
unit, allowing for small patches to a few 32-bit words at any address in
memory, including words of the ROM. She documents that module in Abbott
(2021), along with a way to use it to fake the signature verification of
ROM patches, allowing malicious ones to be installed that will persist
to the next boot.

The module exists as an APB peripheral at [0x4003e000]{.literal} in
non-secure memory and [0x5003e000]{.literal} in secure memory, a region
missing from the memory map in the LPC55S6x user manual. Because it
exists in both privileged and unprivileged modes, unprivileged code can
use it to patch the privileged ROM code's behavior as a form of
privilege escalation!

::: image
[]{#app03.xhtml_page_303
.pagebreak}![Image](images/f0303-01.jpg){#chCfig7}

> **Description:** Die photograph of small-scale microcontroller showing compact integrated architecture. Upper left section contains regular memory array with fine-grained structure. Center and right regions display mixed logic and memory blocks with varying cell densities. Lower sections show additional memory arrays and peripheral circuits. Regular bond pad array around perimeter provides external connections. The compact layout with tightly integrated memory and logic suggests low-power embedded controller, with small die size making complete optical scanning practical for full ROM extraction.

:::

Figure C.7: LPC55S69

[]{#app03.xhtml_page_304 .pagebreak}This patch module's configuration is
wiped at reset, but what if an attacker wanted a patch to be persistent,
such as to disable secure boot authentication? Abbot describes a table
of patch entries in a protected flash memory region with the following
structure. The three supported commands include single-word changes, an
[svc]{.literal} entry point change, and a patch to SRAM.

::: imagel
![Image](images/f0304-01.jpg)

> **Description:** C structure definition rom_patch_entry describing ROM patch format with six fields: u8 word_count (number of words), u8 relative_address (offset), u8 command (patch type: word, svc, or sram), u8 magic_marker (always 'U'), u32 offset_to_be_patched (target address), u8 instructions[] (variable-length patch data). This structure enables runtime ROM patching by specifying patch location, size, type, and content. Understanding patch format allows attackers to inject malicious patches or bypass security checks by modifying ROM behavior without physical access.

:::

In addition to the undocumented patching module, there is a second
software vulnerability for escalation into the secure world. A software
vulnerability in the parsing of firmware update headers, described in
Abbott (2022), allows for privilege escalation from the non-secure world
and persistent control past the next reset.

The bug is in the header structure, shown in [Figure
C.8](#app03.xhtml_chCfig8). By design, [m_keyBlobBlock]{.literal} ought
to be the block number that is just after the header. Each block is 16
bytes, so block 8 would be just after the 128-byte header.

Instead of the secure boot parser copying just the header, it continues
copying blocks until it counts up to [m_keyBlobBlock]{.literal}. When
the number is larger than 8, this copying becomes a classic buffer
overflow.

See also [Chapter A.3](#app01.xhtml_app01_3) for a buffer over-read in
the bootloader's USB stack and [Chapter E.2](#app05.xhtml_app05_2) for a
set of glitching attacks against the chip.

::: image
[]{#app03.xhtml_page_305
.pagebreak}![Image](images/f0305-01.jpg){#chCfig8}

> **Description:** C structure definition sb2_header_t describing Secure Boot 2 header format with 28 fields spanning authentication and boot configuration. Key fields include nonce[4], reserved, m_signature[4], version numbers, flags, block counts, section IDs, certificate block offset, header blocks, m_keyBlobBlock with "Unchecked!" comment indicating vulnerability, m_keyBlobBlockCount, m_maxSectionMacCount, timestamp, product/component versions, build number, and padding. The unchecked key blob block field represents critical security flaw allowing arbitrary key material injection for signature forgery attacks.

:::

Figure C.8: LPC55 SB2 Update Header

### []{#app03.xhtml_page_306 .pagebreak}**C.5 FM3 Flash Patching** {#app03.xhtml_app03_5 .h3}

Infineon's FM3 series of Cortex M3 microcontrollers is used in at least
some models of Sony's Dualshock4 controller for the Playstation 4.
Enthusiast (2018) describes a flash patch and breakpoint (FPB) trick,
somewhat similar to those in [Chapters 17](#ch17.xhtml_ch17) and
[C.4](#app03.xhtml_app03_4), that allows flash memory to be extracted by
persisting patches across a reset.

The chip has boot mode pins, labeled as [MD]{.literal}, that are sensed
at reset to execute either an application from flash memory or a serial
bootloader from ROM. USBDirect is the manufacturer's programming tool,
and it operates by loading a blob of native code into SRAM. An open
source replacement for this blob is available, and by patching it, you
can freely play around with the programming environment.

That's a nice and easy start, but the code runs in a restricted
environment with access to flash memory disabled until a mass erase is
performed. Any attempt to read from flash memory simply returns garbage
data, and this also applies to tricky read methods like a DMA transfer.

With more experimentation, the author found that SRAM persists across
resets. As we saw in [Chapter 2](#ch02.xhtml_ch02), this is a great way
to leave shellcode around for a subsequent attack.

Knowing that SRAM was not reset, the author looked into other peripheral
devices, eventually finding the FPB unit. The FPB holds six pairs of
addresses, remapping a code fetch from the first address into a fetch
for the second address. This module's configuration is also not cleared
at reset!

The final exploit consists of an SRAM blob for the serial boot-loader
that enables the FPB, using it to patch the user application in flash
memory to re-enter the serial bootloader. At that point, the normal SRAM
blob can be presented. Because the []{#app03.xhtml_page_307
.pagebreak}device booted from flash memory, read restrictions are not
enabled and this blob can dump all flash memory. Mass erasing and
rewriting that firmware then unlocks the target, much as we saw in
[Chapter 17](#ch17.xhtml_ch17) except with no requirement for a voltage
glitch at reset.[]{#app03.xhtml_page_308 .pagebreak}

[]{#app04.xhtml}

