## []{#app01.xhtml_page_249 .pagebreak}**A  More Bootloader Vulns** {#app01.xhtml_app01 .h2}

### **A.1 PN553 Signature Bypass** {#app01.xhtml_app01_1 .h3}

Wade (2021a) and Wade (2021b) document a memory corruption vulnerability
in the bootloader of the PN553, PN547, PN548, PN551, and PN5180 series
of NFC chips found in consumer smart-phones such as the Pixel 3 and
Xiaomi MI Note 3. These implement NFC communications so that the
operating system can call high-level abstractions. Raw control of the
chip would be useful to perform raw NFC transactions, and that is the
value of exploits for this vulnerability.

Within a phone, Wade found that Linux presents the device as
[/dev/nq-nci]{.literal}. This character device allows both standard NCI
commands and custom commands unique to the series. Boot-loader commands
were as follows, which he extracted from an ELF library.

+----------------+------------------------------------------------------------+
| [c0]{.literal} | Write Memory                                               |
+----------------+------------------------------------------------------------+
| [a2]{.literal} | Read Memory                                                |
+----------------+------------------------------------------------------------+
| [a7]{.literal} | Write 64 bytes to Configuration                            |
+----------------+------------------------------------------------------------+
| [e0]{.literal} | Checksum and Configuration                                 |
+----------------+------------------------------------------------------------+

The [c0]{.literal} commands perform firmware writes, but with an odd
signing structure. The very first of these contains a version number, a
SHA256 hash, and a signature of that hash. The hash itself is the hash
of the *next* block, which in turn will include a hash of the block
after itself. In this way, the update can proceed linearly from the
beginning, verifying and writing blocks one at a time without ever
having to hold the entire image in RAM.

::: image
[]{#app01.xhtml_page_250
.pagebreak}![Image](images/f0250-01.jpg){#chAfig1}

> **Description:** Die photograph of large-scale integrated circuit showing predominantly memory-focused architecture. Central area contains massive ROM arrays with regular striped patterns extending vertically. Surrounding regions show peripheral circuits including address decoders, sense amplifiers, and I/O drivers. The high ratio of regular memory structure to random logic suggests read-only storage device, making entire die surface vulnerable to systematic optical extraction attacks.

:::

Figure A.1: NXP PN553 NFC Controller

[]{#app01.xhtml_page_251 .pagebreak}The final block is a bit different,
having no hash, as there's no subsequent block to continue the chain.
Noticing that the final block could be sent multiple times without an
error, Wade theorized that the upcoming hash is not replaced by this
command. If it were possible to overwrite the expected value with an
arbitrary hash, then anything might be used for the next block,
regardless of the signature and hash chain.

Now, the [c0]{.literal} commands that write most blocks are just a
little bit longer than the [c0]{.literal} command that writes the very
last block. Wade found that sending an illegally long [e0]{.literal}
command would replace the expected hash *before* returning an error.
This corruption of the expected hash would break the chain, allowing
further blocks to be written as if they were signed.

Having this authority to patch the firmware, he then implemented a read
command without range restrictions and happily dumped all memory for
reverse engineering. He also notes that the SN100 chip, while similar to
other series, encrypts its firmware updates, making exploitation far
more difficult.

### **A.2 Tegra X1, Fusée Gelée** {#app01.xhtml_app01_2 .h3}

The Nintendo Switch uses a Tegra X1 processor from Nvidia that strictly
limits the device to booting content licensed by Nintendo. Temkin (2018)
presents an exploit for the USB stack of the underlying X1 chip.
Reported to Nvidia as CVE-2018-6242, the bug is better known as Fusée
Gelée.

The vulnerability is in a USB Recovery Mode (RCM) boot ROM that the
device will enter when certain pins are strapped to ground and the
external boot memory is unavailable. On a Switch, that's performed by
removing the eMMC board from its socket, holding the volume-down button
and shorting pin 10 of []{#app01.xhtml_page_252 .pagebreak}the right
joystick connector to ground. The Switch then appears as a USB device,
awaiting a signed payload of executable code.

::: image
![Image](images/f0252-01.jpg){#chAfig2}

> **Description:** Memory map diagram showing address layout for Return-Oriented Programming (ROP) attack. Address space from 4000 5000 onwards contains Low DMA Buffer (4000 5000 to 4000 9000), High DMA Buffer (4000 9000 to 4000 CFFF), then destination area with Call Stack and RCM Payload Target at 4001 0000. The Source designation indicates memory regions for payload staging, with DMA buffers representing controllable memory useful for buffer overflow exploitation.

:::

Figure A.2: Fusée Gelée [memcpy]{.literal}

Temkin describes the bug as an unchecked length when reading from the
device. USB control requests include a 16-bit length field for the
maximum amount of data that the device might transfer to the host in a
reply. For example, the host might ask the device for its status, and
the device could reply with just a couple of bytes instead of the
maximum allowed by the host. She identified three exceptions to this
rule, in which the X1's USB stack would send as much data as the host
allows:

- [GET_CONFIGURATION]{.literal} request with a [DEVICE]{.literal}
  recipient.
- [GET_INTERFACE]{.literal} request with an [INTERFACE]{.literal}
  recipient.
- [GET_STATUS]{.literal} request with an [ENDPOINT]{.literal} recipient.

Reads past the end of a buffer are great for dumping memory, but
buffering makes this far more serious. When the host asks for 65,535
bytes of status, those excess bytes are copied from the status
variable's address to one of the DMA buffers for USB transfer. Because
the DMA buffers are small and located just []{#app01.xhtml_page_253
.pagebreak}beneath the call stack, this overflow in the copy can
overwrite the *entire* call stack!

Conveniently, the memory after the status variable is also controlled by
the host. Much of it is used as a buffer to hold up to
[0x30000]{.literal} bytes of an RCM command. The command has a signature
that we can't forge, but it is stored in memory before the signature is
checked.

[Figure A.2](#app01.xhtml_chAfig2) shows the layout of memory as
Temkin's exploit copies the pending RCM command over the call stack.
There are no stack canaries or address space layout randomization (ASLR)
to complicate things, and the call stack itself is executable.
Trust-Zone is also not a problem here, as the RCM ROM runs in the
highest privilege level as the Secure Monitor.

### **A.3 LPC55S69, K82 USB Overread** {#app01.xhtml_app01_3 .h3}

In addition to the TrustZone-M vulnerability in NXP's LPC55S-69 that
we'll see in [Chapter C.4](#app03.xhtml_app03_4), there is a USB
overread bug in both that chip and NXP's Kinetis K82 chip. Kilobytes of
memory can be read past the end of a much smaller buffer. The bug was
fixed in Revision A3 of the LPC55S69, but it is suspected that the same
USB stack and its vulnerability were used in a variety of
microcontrollers.

Alaudeen's exploit for the LPC55S69 from Alaudeen (2021) is shown in
[Figure A.3](#app01.xhtml_chAfig3), which dumps 16kB from the chip
before it resets. The K82 exploit in [Figure A.4](#app01.xhtml_chAfig4)
involves a more complicated transaction, but successfully dumps 64kB
from the chip.

These two exploits are each limited to 4kB due to value of
[MAX_CTRL_BUFFER_LENGTH]{.literal} in libusb. It's apparently possible
to simply patch this [#define]{.literal} to 65,536 in the library's
source code on many Linux platforms.

::: image
[]{#app01.xhtml_page_254
.pagebreak}![Image](images/f0254-01.jpg){#chAfig3}

> **Description:** Python USB exploitation script using usb.core and usb.util libraries. Code finds USB device with vendor ID 0x1fc9 and product ID 0x0021, sends control transfers to address 0x80 with different request values (0x0200, 0x0201), and collects responses. Script appends responses to list then writes them to separate text and binary files. This demonstrates USB enumeration and data extraction attack, likely exploiting bootloader or firmware update interface.

:::

Figure A.3: Alaudeen's USB Exploit for the LPC55S69

::: image
[]{#app01.xhtml_page_255
.pagebreak}![Image](images/f0255-01.jpg){#chAfig4}

> **Description:** Python USB fuzzing script targeting vendor 0x15a2, product 0x0073 with size parameter 200. Triple-nested loop iterates through parameters i (128-132), j (0-1), k (0-65535) attempting control transfers with varying parameters. Successful responses captured to text and binary files numbered by iteration. Exception handling with pass statement continues fuzzing on errors. This brute-force approach discovers valid USB commands by systematically testing parameter space to identify exploitable firmware interfaces.

:::

Figure A.4: Alaudeen's USB Exploit for the K82

[]{#app01.xhtml_page_256 .pagebreak}Alaudeen provides sample dumps from
both chips, but I can't seem to find details on what is found within the
dumps. As this chip has hundreds of kilobytes of SRAM, I expect that you
are likely to find some bytes from the prior boot in the dump, but that
you should not expect the technique to reveal much of the flash memory's
contents.

### **A.4 CH552 Verify Command** {#app01.xhtml_app01_4 .h3}

The CH552 is a cheap 8051 microcontroller with handy USB peripherals in
the W.CH series from Nanjing Qinheng Microelectronics. Christophel and
Thomas (2018) began as a German forum thread exploring this handy chip,
but the conversation quickly took a turn to reverse engineering the
bootloader as a way to write new clients without documentation.

The bootloader comes pre-written to flash memory of these chips, but it
is not in masked ROM, so software patches are possible. Eleven commands
support reading, writing, erasing, and verifying flash memory. In
keeping with the 8051's Harvard architecture, there are separate
commands for accessing the disjoint code and data memories.

The exploitable bug here is in command [0xA6]{.literal}, which verifies
the code flash region. You provide it with a start address and some
XOR-encoded bytes,^[1](#footnotes.xhtml_app1fn1){#app01.xhtml_app1fn_1}^
and it returns zero if they match or non-zero if there's an error.
Thomas rewrites the vulnerable function as the C in [Figure
A.6](#app01.xhtml_chAfig6).

The intent of the code seems to be that by requiring a multiple of eight
bytes, an attacker should not be able to use the Verify function to
brute-force the contents of memory. While it is true that guessing eight
bytes at once would take forever, the bootloader's author has forgotten
to enforce alignment of the address!

::: image
[]{#app01.xhtml_page_257
.pagebreak}![Image](images/f0257-01.jpg){#chAfig5}

> **Description:** Die photograph of asymmetric chip architecture showing mixed memory and logic regions. Left side contains large irregular memory array with random-access patterns, right side displays regular ROM structure with vertical striping. Central vertical band separates regions with routing and control logic. Bottom right shows additional structured memory blocks. Top edge has multiple I/O pads with bond wire connections. Mixed architecture suggests system-on-chip with both volatile and non-volatile storage vulnerable to multi-vector attacks.

:::

Figure A.5: W.CH CH552

::: image
[]{#app01.xhtml_page_258
.pagebreak}![Image](images/f0258-01.jpg){#chAfig6}

> **Description:** C code snippet showing case 0xA6 verification routine processing bootkey validation. Code extracts length from command buffer, validates it's multiple of 8 bytes, reconstructs address from bytes, then loops comparing bootkey bits with GBYTE array at calculated address. Uses XOR comparison with bit masking (0x07) to verify each byte. Result set to 0xF1 on mismatch. This cryptographic verification routine is vulnerable to timing attacks revealing correct key bits through execution time analysis.

:::

Figure A.6: Decompiled CH552 Verification

So to exploit this vulnerability, an attacker can set the address to
seven known bytes followed by an eighth unknown byte, then brute-force
the eighth byte. Once it is known, the window can slide forward by one
byte to crack the next.

One direct way to exploit this is to begin at the known boot-loader,
then slide forward into the application one byte at a time. A more
generic technique, used in Cheron (2019), is to assume that the firmware
ends with eight bytes of [0xff]{.literal} and work backward to the start
of the application image.

::: image
[]{#app01.xhtml_page_259
.pagebreak}![Image](images/f0259-01.jpg){#chAfig7}

> **Description:** C function probably_load_header showing bootloader header manipulation. Code sets DAT_bf400888 to 0xa0500000, performs multiple memcpy operations copying 76 bytes of header data including percello_sig and fm_sig to address 0xa0500000. Final assignments store signature values to DAT_bf400880 and DAT_bf400884. This header loading routine processes cryptographic signatures, representing critical security check vulnerable to modification attacks targeting signature verification logic.

:::

Figure A.7: Stack Buffer Overflow in BCM61650

### **A.5 BCM61650/PRC6000 Headers** {#app01.xhtml_app01_5 .h3}

Broadcom's BCM61650, previously known as the PRC6000 before their
acquisition of Percello, is a MIPS CPU used in 3G femtocells as a plugin
to a popular French brand of DSL and fiber modems.

Xilokar (2022) describes an exploit against the header format of the
chip's TFTP boot image. He begins by patching the module hardware to
expose Ethernet pins, then popping a root shell by exposed passwords in
a TFTP network boot image. After gaining this foothold, he wrote the
quick kernel module in [Figure A.8](#app01.xhtml_chAfig8) to dump the
ROM into the kernel log.

Having the ROM dump, he identified a parsing bug in the bootloader's
header parsing routine, shown in [Figure A.7](#app01.xhtml_chAfig7). The
bug here is that [fm_sig_len]{.literal} is directly read from the
attacker-controlled bootloader header, and its destination buffer at
[0xbf40-090c]{.literal} is not far from the initial stack position of
[0xbf403ff0]{.literal}. A very long header will overwrite stack
variables and the return pointer during the copy.

::: image
[]{#app01.xhtml_page_260
.pagebreak}![Image](images/f0260-01.jpg){#chAfig8}

> **Description:** C code showing bootloader location and header verification routines. Comments indicate Percello bootloader at 0x83fe0000, FM bootloader at 0x83f80000, and header verification routines in ROM at 0x9fc00xxx. Code includes Linux kernel headers and implements dump_mem function for memory dumping with printk output. Module initialization dumps ROM regions and includes MODULE_AUTHOR, MODULE_DESCRIPTION, and MODULE_LICENSE declarations. This debug module reveals critical bootloader addresses and security check locations for exploit development.

:::

Figure A.8: Linux ROM Dumper for the BCM61650

[]{#app01.xhtml_page_261 .pagebreak}By crafting an obscenely long
signature length, the Percello bootloader can be exploited to skip the
signature validation. The FM loader can then be freely patched to allow
an arbitrary kernel and initial ramdisk.

### **A.6 PSoC4 Flash Doubler** {#app01.xhtml_app01_6 .h3}

The PSoC4 series of ARM Cortex M0 microcontrollers from Cypress has a
protected ROM, called SROM, that implements many boot features. It in
turn uses a hidden and protected flash memory, called SFLASH, to store
settings such as the protection level of the chip and the capacity of
flash memory.

In Grinberg (2017a), Dmitry Grinberg published details for dumping the
SROM by a ROP chain triggered from user flash memory, patching the
SFLASH by re-implementing the SROM's flash library, and doubling the
capacity of a CY8C4013SXI-400 from 8kB to 16kB by patching two bytes of
SFLASH.

As a follow-up, Grinberg (2017b) attempts to thoroughly document the
extra registers and their meanings to aid in porting these attacks to
other chips.

### **A.7 i.MX53 Overflow in Bootloader** {#app01.xhtml_app01_7 .h3}

The i.MX53 chip used in the first-generation USB Armory device has a
stack buffer overflow vulnerability in its boot ROM, described in
Delugré and Szkudlapski (2017), that allows for a bypass of the code
signing and secure boot restrictions. A few more details are in Barisani
(2017).

The first vuln, CVE-2017-7932, is a stack buffer overflow in the X.509
parser. The certificate is parsed before it is verified, so the exploit
can trigger without proper signing, and a proof of concept
[]{#app01.xhtml_page_262 .pagebreak}is available in the
[hab_poc]{.literal} function of [usbarmory_csftool]{.literal} in the USB
Armory git repository.

The second, CVE-2017-7936, allows for remote code execution in ROM's
implementation of the Serial Download Protocol (SDP) by abusing
incorrect memory checks.

### **A.8 M16C Bootloader Timing Attack** {#app01.xhtml_app01_8 .h3}

Renesas M16C chips have a ROM bootloader that's vulnerable to a
straightforward timing attack, at least until the fourth revision of the
bootloader. In Bazanski and Kowalczyk (2018), this was used as a way to
dump the Mitsubishi M306K9FCLRP chip that functions as the embedded
controller in a Toshiba Portégé R100 laptop.

The firmware extraction bug itself is a simple timing attack against a
password check. As you enumerate every possible first byte, one of them
will be 3 µs faster than the other 255. Repeating this for each byte
gives the expected password in an average of 900 guesses, after which
all seven bytes are known. With those seven bytes, you can freely read
and write flash memory.

An exploit for this bug is available as Bazanski (2017). It runs as a
Python host application, matched to an ICEStick FPGA devboard,
programmed with the open source Icestorm toolchain.

### **A.9 IC204 Bypass by Magic Number** {#app01.xhtml_app01_9 .h3}

Lim (2021) describes the inner workings of a Mercedes-Benz ECU whose
model number is the IC204. Lim's specific example is from a 2011 C300,
but many vehicles between 2007 and 2013 ought to be vulnerable to the
same bug.

::: image
[]{#app01.xhtml_page_263
.pagebreak}![Image](images/f0263-01.jpg){#chAfig9}

> **Description:** Photograph of vehicle dashboard display showing critical system error message. Screen displays "ABS and ESC Inoperative See Operator's Manual" with check engine icon, time 4:13, gear indicator showing P R N D positions, and "UNSIGNED FIRMWARE" warning at bottom. This production system accepts unsigned firmware, indicating catastrophic security failure allowing arbitrary code execution on safety-critical automotive control systems without authentication.

:::

Figure A.9: Nyan Cat on a 2011 Mercedes Dashboard

[]{#app01.xhtml_page_264 .pagebreak}The trick here is that the Renesas
uPD70F3426 is programmed with a ROM bootloader chain that verifies
signatures on each section as the boot progresses. Lim reverse
engineered that ROM to find that the signature check is performed just
once per firmware update, and each block's successful verification is
cached as a 32-bit magic word.

The magic word in this case is [0x5a5a5a5a]{.literal}. By writing that
word to [0x0f1f80]{.literal}, [0x16ef80]{.literal},
[0x1b3f80]{.literal}, [0x1f4f80]{.literal}, [0x1f5f80]{.literal},
[0x0fff80]{.literal} and [0x1fff80]{.literal}, all of which are allowed
by the ROM, the signature check can be bypassed and arbitrary code can
be freely run.

After gaining control of the ECU firmware, he added Nyan Cat to the ABS
and SYS malfunction messages in [Figure A.9](#app01.xhtml_chAfig9).

### **A.10 Zynq 7000 Bootloader Dumping** {#app01.xhtml_app01_10 .h3}

Quite often a chip is exploited first by awkward and labor intensive
means, and then the dump from that first exploit is reverse engineered
to find a simpler method. Such was the case with the Xilinx Zynq
bootloader, after being dumped by the glitching attack in [Chapter
E.16](#app05.xhtml_app05_16).

Schretlen (2021a) describes such a UART bootloader, which you can enable
by pulling both boot mode pins high. It takes just the Python code from
[Figure A.10](#app01.xhtml_chAfig10) to upload and execute a valid
image. When implementing this yourself, be careful to delay as that code
does; it's necessary to avoid reliability bugs in the ROM.

By this stage, it's clear that we can upload an image, but what image is
worth uploading to extract the ROM? A good first target would be
something that copies the ROM into RAM for later extraction. Schretlen
(2021c) presents an exploit in the form of a Zynq 7000 application
header header, taking advantage []{#app01.xhtml_page_265 .pagebreak}of
the fact that the bootloader never bothers to verify the source address
of the image.

Shown in [Figure A.10](#app01.xhtml_chAfig10), the exploit payload is
just an image header that copies the ROM out of its native address and
into RAM at [0x00000000]{.literal}. After booting the exploit, the
attacker recovers the image by attaching a JTAG debugger and dumping
that range of memory to disk. The JTAG debugger can't read the original,
but it can freely read the copy that the ROM refuses to boot.

### **A.11 Zynq 7000 NAND/ONFI** {#app01.xhtml_app01_11 .h3}

Schretlen (2022a) describes a memory corruption exploit for the
NAND/ONFI interface of the Zynq ROM and the [embeddedsw]{.literal}
hardware abstraction library (HAL) prior to [xilinx_v2021.1]{.literal}.

The ONFI specification (Open NAND Flash Interface) is a standard for
NAND chips that defines their package, their pinout, and various other
modes, so chips from one vendor can be a drop-in, compatible replacement
for those from another vendor.

Beyond standardizing the pinout ([Figure A.12](#app01.xhtml_chAfig12))
and signaling, ONFI also provides a standardized "parameter page" and
matching data structure. The parameter page is a page of the NAND chip
that can be read by device code, as a way for the NAND to report back
some of its characteristics. The parameter page structure begins with
[4f]{.literal}, [4e]{.literal}, [46]{.literal}, [49]{.literal}
("[ONFI]{.literal}") and includes fields for protocol revision numbers,
a baker's dozen of optional features and commands, JEDEC manufacturer
information, and memory
organization.^[2](#footnotes.xhtml_app1fn2){#app01.xhtml_app1fn_2}^

::: image
[]{#app01.xhtml_page_266
.pagebreak}![Image](images/f0266-01.jpg){#chAfig10}

> **Description:** Python serial communication script for firmware flashing over UART. Script opens binary file, configures serial port at 115200 baud on /dev/ttyUSB0, waits for "LNX-ZYNQ" handshake, sends "BAUD" command followed by baud rate, register value, size, and checksum as 4-byte little-endian values. Includes sleep delays for reset timing and error propagation. Comment notes "Sleep here 'cause this is where they hit resets for the ta/rx logic". This bootloader protocol is vulnerable to unauthorized firmware installation through accessible UART interface.

:::

Figure A.10: Zynq Bootloader Client from Schretlen (2021a)

::: image
[]{#app01.xhtml_page_267
.pagebreak}![Image](images/f0267-01.jpg){#chAfig11}

> **Description:** Python function gen_hdr generating bootloader header structure. Code builds header using pack operations with little-endian format specifiers. Includes XIP IVT sections (eight 0xeafffffе values), width detect value (0xaa995566), XNLX magic marker, encryption/miscellaneous fields, source offset, length fields, load address, entrypoint address (0x0FCB4), total image length, QSPI settings, checksum calculation, unused padding, and initialization lists. The commented sections reveal header format for bootable images, useful for creating malicious bootloaders or bypassing signature verification.

:::

Figure A.11: Zynq 7000 Exploit Header from Schretlen (2021c)

::: image
[]{#app01.xhtml_page_268
.pagebreak}![Image](images/f0268-01.jpg){#chAfig12}

> **Description:** Pinout diagram for 48-pin TSOP and WSOP package showing dual inline configuration. Left side pins 1-24 include R, Vpp, VDDi, reset and chip enable signals with active-low notation (_n suffix), clock signals (CLE, ALE, WE_n, WP_n), VSP3, ENi, ENo, and power pins. Right side pins 25-48 contain VssQ, multiple I/O pins (IO15-IO0), VccQ, VSP1, VSP2, Vcc, and Vss. The pinout reveals NAND flash memory with separate core and I/O power domains, vulnerable to voltage glitching attacks on power pins.

:::

Figure A.12: Standardized NAND/ONFI Pinout

Bytes 80 through 99 of the ONFI parameter page describe the memory
organization as a number of data bytes per page, spare bytes per page,
pages per block, and blocks per LUN, or logical unit number. These
values are poorly verified, and having too many spare bytes per page
will cause an overflow in the fetching of the Bad Block Table, which is
loaded into a [0x200]{.literal} byte local stack variable. Overflowing
this buffer gives control of several useful stack variables.

Because the parameter page isn't known to be writable on any
commercially available NAND flash chip, triggering this exploit requires
emulating the NAND chip with an FPGA. Galan Schretlen had the advantage
when writing this attack of previously having dumped the ROM by the
techniques in [Chapters E.16](#app05.xhtml_app05_16) and
[A.10](#app01.xhtml_app01_10); writing the exploit blind would be more
of a challenge!

[]{#app01.xhtml_page_269 .pagebreak}The following is his shellcode in
ARM assembly that will unlock JTAG on Xilinx Zynq and dump a few useful
register values to the UART.

::: imagel
![Image](images/f0269-01.jpg)

> **Description:** Assembly code listing showing payload section with global symbols _start and _payload. Code defines multiple .equ constants including memory addresses: sc_len (516), mio_init (0x57a4), uart_init (0x06a0), printf (0x0a9c4), and device configuration registers. The trampoline configurables section sets relocation_base (0x60000) and shellcode_sp (0x68000). Payload begins with NOP instructions, "bad block table 0" ASCII string, and initialization code using movw/movt/mov/eor/blx instructions. This bootloader exploit payload establishes execution environment for arbitrary code injection.

:::

::: imagel
[]{#app01.xhtml_page_270 .pagebreak}![Image](images/f0270-01.jpg)

> **Description:** Assembly code continuation showing device configuration and control register operations. Code reads devcfg register at 0x0910, loads values into registers, performs MRC p15 coprocessor instructions to grab sctlr and shadow control registers. Includes operations to get actlr and sctlr values, PC-relative addressing with banner offset calculation, printf call, and loop structure with wfe (wait for event) instructions. Comments indicate considerations for editing IVT and memory remapping requirements. This low-level initialization code represents bootrom exploit gaining control before secure boot verification.

:::

::: imagel
[]{#app01.xhtml_page_271 .pagebreak}![Image](images/f0271-01.jpg)

> **Description:** Assembly code showing ROP chain construction and register restoration. Code includes exception handler adding offset to banner, loop back mechanism, puts function with stack operations, prompt and banner strings ("Zynq Bootrom unlocked", "sctlr: 0x%x, devcfg: 0x%x, shadow: 0x%x"). Pad out stack frame directive precedes restored registers section defining r4-r11 with specific addresses (0x70000, 0xdead0005-0xdead0011). Comments describe simple ROP chain poking useful primitive into RAM with pop, mul, sub, bx operations. This demonstrates complete bootrom exploit with payload delivery mechanism.

:::

::: imagel
[]{#app01.xhtml_page_272 .pagebreak}![Image](images/f0272-01.jpg)

> **Description:** Assembly code continuation showing additional ROP gadgets and memory manipulation. Instructions include mov/str/pop operations, word values 0xb638 and 0xe52dd004 (push sp), hex values 0xdeadbeef, and memory write primitives. Comments explain starting PC (R0 == 0) and ROP chain gadget at 0x00008a6c performing pop {r1, r2, lr}, mul r3, r2, r0, sub r1, r1, r3, bx lr. Code constructs arbitrary memory write capability by chaining gadgets to achieve write-what-where primitive essential for code execution exploits.

:::

### **A.12 Zynq 7000 BOOT.BIN Parsing** {#app01.xhtml_app01_12 .h3}

The Xilinx Zynq 7000 exploit in [Chapter A.11](#app01.xhtml_app01_11) is
great when physical access is available, the NAND pins are broken out,
and an FPGA emulator of the NAND chip is readily available, but these
restrictions can be tiresome, and many high-end boards don't use NAND
chips, so they don't break out the necessary pins. In this chapter we'll
discuss Schretlen (2022b), a memory []{#app01.xhtml_page_273
.pagebreak}corruption vulnerability in the parser of the
[BOOT.BIN]{.literal} file that might be found on an SD Card.

This exploit requires no fancy emulator hardware, and it triggers before
signatures are checked, so it does not require a separate break of the
cryptography. It's perfect for jailbreaking a device.

Schretlen began by using Unicorn's Python bindings to emulate the ROM
that had previously been extracted. Once functional, the emulator could
be used to explore the allowed address ranges in the Register Init Lists
(RILs) of [BOOT.BIN]{.literal}.

As [BOOT.BIN]{.literal} is being parsed, the ROM loads sections into RAM
according to the RILs. Only *after* the image has been completely loaded
is the signature checked. This defends against time-of-check to
time-of-use (TOCTOU) attacks, but this also means that a parser bug
might be exploited before the signature check is complete.

Schretlen found that while the base register of the SDIO DMA controller
is not writable, it has already been set by the boot ROM because the
machine is booting from an SD Card. You'll see this same trick in many
embedded exploits, in that they won't bother to configure an I/O port or
register that the exploited software has already configured.

The following is a Python script that generates a payload header for
triggering the bug. It requires a rather fast SD Card for race condition
reasons that are best explained in the original paper, and the header
must be followed by blocks with shellcode that fit into the overwritten
bootloader.

::: imagel
![Image](images/f0273-01.jpg)

> **Description:** Python script header and initialization for bootloader exploit generation. Code imports struct pack/unpack functions, time, and sys modules. Initializes empty list called "inits" with comment about speeding up sdio operations. Following sections define initialization values as tuples containing addresses and bit-packed data for Block_Size_Block_Count, Address (size), and Transfer_Mode_Command (DMA) settings. Multiple dummy writes to address 0xE000D00C prepare SDIO interface. This script generates malicious boot image exploiting SDIO DMA for memory corruption attacks.

:::

::: imagel
[]{#app01.xhtml_page_274 .pagebreak}![Image](images/f0274-01.jpg)

> **Description:** Python code continuation showing gen_hdr function implementation building bootloader header. Code initializes empty bytes object, constructs XIP IVT section with eight packed little-endian values (0xeaffffe), adds width detect value (0xaa995566), XNLX magic marker, encryption and source offset fields, length and load address parameters, entrypoint value, total image length, QSPI settings with probable vestigial comment, and checksum calculation. The function builds complete bootable image header required for processor to execute payload, demonstrating header injection attack vector.

:::

::: imagel
[]{#app01.xhtml_page_275 .pagebreak}![Image](images/f0275-01.jpg)

> **Description:** Table showing command interface with Password and Flag requirements. Commands at addresses 0x60 (Enable Protect Flag - Y/N), 0x40 (Erase - N/N), 0x30 (Get Product ID - N/N), 0x20 (Get CRC - N/N), 0x10 (Run RAM Program - Y/Y). The dual password/flag protection on Enable Protect Flag and Run RAM Program commands indicates security model where both authentication factors required. This reveals attack surface where password extraction enables arbitrary code execution through RAM program feature.

:::

### []{#app01.xhtml_page_276 .pagebreak}**A.13 TMP91 Password** {#app01.xhtml_app01_13 .h3}

Toshiba's TLCS-900 series, better known by its prefix TMP91, is a 16-bit
microcontroller from the early 2000s. Its bootloader features two
protections: a password and a protection flag. The protections are
redundant, so that if the flag is set, the password alone is not very
useful.

In the case of at least the TMP91FW27 and TMP91FW60 devices, O'Flynn
(2023) describes a successful use of power analysis to recover the
bootloader password, as well as a less successful fault injection attack
against the protection flag.

The ROM bootloader contains just five commands, with the password being
required to lock the chip with [0x60]{.literal} and to execute code from
RAM with [0x10]{.literal}. Enabling the protection flag ensures that no
new programs will run from RAM even with the password.

In O'Flynn's case, he wanted to dump the firmware from his kitchen oven
in order to work around a bug with the thermostat. The oven would work
its way up to roughly the right temperature, but the thermometer always
read the target temperature and never the actual temperature. This
ruined a fine batch of cookies and Colin had to have his revenge with a
firmware extraction and patch.

His oven uses a TMP91FW60, but he prototyped his attack against the
TMP91FW27, which is more plentiful on eBay. The idea here is to first
attack a cheap target, then to go back and hit the rare target.

For power analysis, he added a shunt resistor on the VCC pin, and he
also replaced the quartz crystal with an external clock supply to keep
power analysis synced with the target. By sending password guesses to
the chip and measuring the voltage drop during each guess, he was able
to reveal the correctness of the guess, one byte at a time. He also
identified a potential target for a voltage or clock glitch to skip the
flag check in the bootloader, which is necessary to run a RAM program
when the protection flag is enabled.

::: image
[]{#app01.xhtml_page_277
.pagebreak}![Image](images/f0277-01.jpg){#chAfig13}

> **Description:** Photograph showing hardware test setup with two development boards connected via cables. Upper board appears to be power supply or relay module with multiple black components and connectors. Lower board is microcontroller development board with visible chip, programming headers, and edge connectors. Game Boy handheld device lies on left side. Multiple jumper wires connect between boards suggesting hardware debugging or glitching setup. This configuration typical of voltage fault injection or clock manipulation attacks for bypassing security features.

:::

Figure A.13: TMP91 Bootloader Commands

::: image
![Image](images/f0277-02.jpg){#chAfig14}

> **Description:** Photograph showing hardware test environment with development boards and mobile device. Configuration demonstrates physical access attack setup for hardware security research.

:::

Figure A.14: O'Flynn's TMP91 Target Board

::: image
[]{#app01.xhtml_page_278
.pagebreak}![Image](images/f0278-01.jpg){#chAfig15}

> **Description:** Die photograph showing mixed memory and logic architecture with clear functional separation. Upper half contains two large ROM arrays with vertical striping pattern, central section has dense irregular logic circuitry, bottom quarter shows four symmetric memory blocks with horizontal striping. Peripheral bond pads visible around entire perimeter. The three-tier architecture separates program storage (ROM), processing logic, and working memory/buffers, with each region presenting distinct attack surfaces for optical extraction, fault injection, or side-channel analysis.

:::

Figure A.15: TMP91FU62F0

[]{#app01.xhtml_page_279 .pagebreak}At this point, all was well on his
FW27 demo board, so he moved back to the FW60 chip from his oven. Power
analysis revealed the password to be [samsungoven0]{.literal}, but in
adjusting his voltage glitch, he accidentally erased all memory. The
firmware he had worked so hard to extract was gone!

A few phone calls to Samsung support got a replacement shipped his way,
but this board differed from the original oven in one crucial way. While
both used the same password, the replacement did not have the protection
flag enabled! Knowing the password, he could freely run shellcode from
SRAM to dump the program memory. If you aren't so lucky as to get a
target missing the lockout bit, O'Flynn suggests searching your glitch
parameters backward from the end of the search
window.[]{#app01.xhtml_page_280 .pagebreak}

[]{#app02.xhtml}

