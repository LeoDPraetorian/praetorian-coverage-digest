## []{#ch11.xhtml_page_109 .pagebreak}**11  STM32F1 Interrupt Jigsaw** {#ch11.xhtml_ch11 .h2a}

RDP Level 1 of the STM32 series, in which JTAG debugging is allowed but
immediately disconnects flash memory, is an appealing target for memory
extraction exploits. The STM32F1 series does not seem to be vulnerable
to Obermaier's STM32F0 exploit from [Chapter 10](#ch10.xhtml_ch10) or
the DFU bootloader exploit from [Chapter 2](#ch02.xhtml_ch02), but in
this chapter we will cover a different vulnerability, first described in
Schink and Obermaier (2020) for the STM32F1 and shortly after in
Obermaier, Schink, and Moczek (2020) for two of its clones, the
APM32F103 and CKS32F103. As a bonus, the STM32F1 series does not support
RDP Level 2, so it's possible that all parts in the series are
vulnerable.

When protections are enabled, flash memory is disconnected from the main
memory bus when a debugger is attached. You can't fetch it as data, and
you can't even fetch it as code for execution. The trick here is that
while flash memory is disconnected from the main memory bus for code and
data fetches, interrupts can still be fired. The interrupt addresses are
accurately fetched from the interrupt vector table (IVT) despite the
disconnect! This table is also movable, and by stepping the table slowly
across memory, we can move most words of memory into the programmer
counter for the debugger to catch.

::: image
[]{#ch11.xhtml_page_110
.pagebreak}![Image](images/f0110-01.jpg){#ch11fig1}

> **Description:** Die photo of a microcontroller with distinct memory and logic regions. The left side contains a large rectangular array structure, likely flash memory or ROM. Two large dark rectangular blocks dominate the center and lower right, possibly representing SRAM or additional memory. The upper right contains control logic and peripheral circuitry. Bond pads line the perimeter for external connections. The chip layout suggests a balanced design between processing logic and memory storage.

:::

Figure 11.1: STM32F103

### []{#ch11.xhtml_page_111 .pagebreak}**The First Two Words** {#ch11.xhtml_ch00lev1sec38 .h3}

::: imagel
![Image](images/f0111-01.jpg)

> **Description:** Terminal output showing a debug session halted due to a debug-request. The system status displays "target halted due to debug-request, current mode: Thread" with registers showing xPSR: 0x01000000, pc: 0x08000268, and msp: 0x20005000. This output indicates the processor has been successfully halted via the debug interface, showing the program counter at address 0x08000268 in flash memory and the main stack pointer in SRAM.

:::

Schink's paper begins with this gloriously simple example, in which he
first attaches a Segger J-Link adapter through SWD and then calls [reset
halt]{.literal} in OpenOCD's telnet session to reveal that
[0x08000268]{.literal} are the upper 31 bits of the reset vector, the
second word in flash memory. [0x20005000]{.literal} is the initial stack
pointer, the very first word.

The low bit of the program counter is set (1) for all real handler
addresses on this chip, indicating Thumb2 mode, but it might be clear
(0), so we'll need to recover that bit for a real exploit. This is
because unlike the real interrupt table, the fake interrupt tables are
mostly composed of instructions or data that are not interrupt handler
addresses. Schink does this by first reading the program counter (whose
low bit is forced clear) and then grabbing the Thumb2 mode from
[ESPR]{.literal} to restore the missing bit.

::: imagel
![Image](images/f0111-02.jpg)

> **Description:** Python code function recover_pc for extracting the program counter during debug operations. The function reads PC and PSR registers from an OpenOCD connection. It extracts the LSB (least significant bit) of the PC from the EPSR.T bit at position 24 by shifting xpsr right by 24 and ANDing with 0x1. The function returns the combined PC with the T bit, demonstrating Thumb mode instruction alignment recovery.

:::

This gives us the first two words of flash memory, but in reading the
code, you'll see that these are a special case because triggering the
reset also moves the interrupt table back to the beginning of flash
memory.

::: imagel
[]{#ch11.xhtml_page_112 .pagebreak}![Image](images/f0112-01.jpg)

> **Description:** Python code snippet showing debug recovery logic based on memory addresses. If the address equals 0x00000000, it sends "reset halt" command and reads the SP (stack pointer) register. If address equals 0x00000004, it again sends "reset halt" and calls recover_pc function to reconstruct the program counter. This code demonstrates exception vector table recovery by reading reset and initial PC values.

:::

### **The Rest of Memory** {#ch11.xhtml_ch00lev1sec39 .h3}

For all other addresses, the entire interrupt table must be slowly
stepped across flash memory, then individual interrupts must be
triggered artificially to move table entries into the program counter.

The first complication to this is that seven entries in the list are
unusable. We've already discussed that 0 (MSP) and 1 (reset) can't be
relocated, so except at the very beginning, those are forbidden.
Exceptions 7, 8, 9, 10, and 13 are reserved, and we are unable to
trigger them. Exceptions 16 and higher are external interrupts, and we
can trigger them, but the count differs by chip model.

A second complication is that we are relocating the table with the
vector table offset register (VTOR). This register is commonly used by
custom bootloaders, such as the one in [Chapter 3](#ch03.xhtml_ch03), so
that the chip can boot with one interrupt table and later switch over to
the application's table.

If we could slide the interrupt table one word at a time, we could reuse
a single interrupt to dump all words of memory, but as you can see in
[Figure 11.2](#ch11.xhtml_ch11fig2), we have a 128-word alignment
restriction that gets in the way. We'll need to step the table in
chunks, then trigger individual interrupts to extract words from the
table.

This alignment rule means that while we can slide the VTOR, we'll have
gaps for our forbidden exceptions, with seven words missing from every
table! Schink found that while you do need to be aligned to the table
size for proper operation, the table sort of wraps around if the table
is aligned to half of its size and you trigger an interrupt that is
after the end.

::: image
[]{#ch11.xhtml_page_113
.pagebreak}![Image](images/f0113-01.jpg){#ch11fig2}

> **Description:** Register bit field diagram showing TBLOFF register structure (bits 31-0). The diagram highlights bits 29:9 labeled as TBLOFF[29:9] containing the "Vector table base offset field." Bits 31:30 and 8:0 are marked as Reserved. The description explains this field contains bits [29:9] of the offset from memory address 0x00000000, requiring 128-word minimum alignment. Bit 29 determines whether the vector table is in code or SRAM memory region (0: Code, 1: SRAM). Note mentions bit 29 is sometimes called the TBLBASE bit.

:::

Figure 11.2: VTOR from STMicro (2005)

::: image
![Image](images/f0113-02.jpg){#ch11fig3}

> **Description:** Vector table layout diagrams comparing aligned versus half-aligned VTOR configurations. The left "Aligned VTOR" shows sequential exception entries (SP, PC+0x10 entries 4-31) at standard word boundaries. The right "Half-aligned VTOR" shows misalignment with entries at addresses like 32, 33, 40, 41, 42, 45 offset by +0x10, +0x20, +0x30. This demonstrates how incorrect VTOR alignment can corrupt exception vector table access.

:::

Figure 11.3: Relocation of the IVT

[]{#ch11.xhtml_page_114 .pagebreak}So in an STM32F103 with 64 entries in
its IVT, the table begins at [0x08000000]{.literal} and we can
officially use the VTOR to relocate it to aligned addresses:
[0x08000100]{.literal}, [0x08000200]{.literal}, [0x0800-0300]{.literal},
and so on. At these offsets, we are unable to read the seven words at
offsets [0x00]{.literal}, [0x04]{.literal}, [0x1C]{.literal},
[0x20]{.literal}, [0x24]{.literal}, [0x28]{.literal}, and
[0x34]{.literal} because those interrupts are forbidden or impossible to
trigger. But by setting the table to 32-word alignment at
[0x08000080]{.literal}, [0x08000180]{.literal}, [0x08000280]{.literal},
and so on, we can use the table wraparound to fill in the blanks,
triggering interrupt 32 instead of 0 to dump offset [0x00]{.literal}, or
interrupt 39 instead of 7 to dump offset [0x1C]{.literal}. [Figure
11.3](#ch11.xhtml_ch11fig3) demonstrates this.

Using this illegal-offset trick, we still miss seven words from each
even 32-word block, but we collect all words from the odd 32-word
blocks, giving us 89% coverage of the firmware on the STM32F103. Because
we only miss words on the even blocks, our coverage is better in chips
with larger interrupt tables.

### **Triggering Interrupts** {#ch11.xhtml_ch00lev1sec40 .h3}

Now that we've covered the theory of Schink's exploit, let's cover some
of the practical details behind triggering specific interrupts. After
connecting to the OpenOCD server, his script begins by halting the
target and disabling exception masking.

::: imagel
![Image](images/f0114-01.jpg)

> **Description:** Assembly code snippet showing two instructions: "oocd.halt()" and "oocd.send('cortex_m maskisr off')". These commands halt the processor via OpenOCD debug interface and then disable interrupt masking for the Cortex-M processor, allowing interrupts to fire during debug operations. This is useful for debugging interrupt-driven code without blocking interrupt servicing.

:::

[]{#ch11.xhtml_page_115 .pagebreak}It then writes four half-word
instructions to the beginning of SRAM at [0x20000000]{.literal}, for
triggering exceptions when they can't be triggered directly. One is [svc
#0]{.literal} to trigger a supervisor call, the second is a
[nop]{.literal}, the third is a load instruction used to trigger a bus
fault, and the fourth is [0xFFFF]{.literal}, an illegal instruction.
Many of these interrupts are disabled by default, so the code must first
enable the feature and then perform the illegal action.

Each interrupt is triggered by first sending [reset halt]{.literal} to
OpenOCD, writing the VTOR address, and then triggering the individual
interrupt by its own unique method.

First, the standard interrupts: Exception 2 is an NMI, triggered by
setting bit 31 of [ICSR]{.literal}. Exception 3 is a HardFault,
triggered by executing [0xFFFF]{.literal} from SRAM. Exception 4 is a
MemFault, triggered by setting a bit of the [SHCSR]{.literal} register
and branching to unexecutable I/O memory at [0xe0000000]{.literal}.
Exception 5 is a BusFault, triggered by setting a different bit of
[SHCSR]{.literal} and branching to the [ldr]{.literal} instruction in
SRAM. Exception 6 is a UsageFault, triggered by jumping to the illegal
instruction in RAM after setting the appropriate bit of
[SHCSR]{.literal}. Exception 11 is a Supervisor Call, triggered by
executing [svc #0]{.literal} from SRAM. Exception 12 is a DebugMonitor
exception, triggered by setting bit 17 of [DEMCR]{.literal}. Exception
14 is a PendSV interrupt, triggered by setting bit 28 of
[ICSR]{.literal}. Exception 15 is a SysTick interrupt, triggered by
setting bit 26 of [ICSR]{.literal}.

Starting with Exception 16 and continuing to the end of the table, we
have external interrupts. Each of these has an exception number,
beginning with 0 for Exception 16, and each can be triggered by setting
the appropriate bit of both [NVIC_ISER0]{.literal} and
[NVIC_ISPR0]{.literal}.

Except where a specific instruction is specified, you'll probably want
to execute a [nop]{.literal} when triggering these interrupts to avoid
any unpredictable errors in the extraction.

### []{#ch11.xhtml_page_116 .pagebreak}**Counting the External Interrupts** {#ch11.xhtml_ch00lev1sec41 .h3}

Only one thing is left before the exploit is ready to roll. We
desperately need to know the size of the interrupt table, in order to
know both when to slide it to a new position and when we can use the
wraparound trick for half-aligned table positions.

It would work perfectly well for a demo to simply hard-code the values
for a few known model numbers, but for the sake of portability, Schink's
exploit instead counts the external interrupts by triggering them
sequentially until the Program Status Register (PSR) fails to indicate
the exception.

Counting the interrupts also revealed that for some model numbers, the
documentation erroneously listed some of these external interrupts as
reserved, when in fact they functioned just like all the others.

### **Performance** {#ch11.xhtml_ch00lev1sec42 .h3}

Schink's paper concludes with a table of STM32F1 chips, along with their
external interrupt counts, extraction time, and coverage when extracting
128kB of flash memory. ([Figures 11.4](#ch11.xhtml_ch11fig4) and
[11.5](#ch11.xhtml_ch11fig5).)

Extraction coverage is strictly limited by the number of interrupts,
because of those pesky seven that can't be triggered in an aligned
interrupt table.

If it becomes too frustrating to reverse engineer the firmware given
only the majority of the instructions, it might help to dump multiple
versions of your target's firmware. Gaps should appear in different
places, allowing the missing part of one version to be filled in from
another version. (There will of course be errors with this technique
attributed to differences in source code and object size, but quite a
few of the words should be correctly extracted.)

::: image
[]{#ch11.xhtml_page_117
.pagebreak}![Image](images/f0117-01.jpg){#ch11fig4}

> **Description:** Table showing external interrupt statistics for three STM32F1 devices. STM32F100 recorded 55 external interrupts over 45.8 minutes with 91.4% coverage. STM32F103 recorded 43 interrupts over 48.2 minutes with 89.1% coverage. STM32F107 recorded 68 interrupts over 51.0 minutes achieving 94.5% coverage. This data demonstrates interrupt fuzzing results measuring the effectiveness of interrupt-based attack coverage across different microcontroller variants.

:::

Figure 11.4: Code Coverage from Schink and Obermaier (2020)

::: image
![Image](images/f0117-02.jpg){#ch11fig5}

> **Description:** Python code function determine_num_ext_interrupts for discovering available external interrupts on ARMv7-M processors. The function iterates through all 496 possible external interrupts (0-495), executing "reset init" for each. It calculates the memory offset (i // 32 * WORD_SIZE) and bit value (1 << (i % 32)), then enables interrupts by writing to NVIC_ISERO_ADDR and NVIC_ISPRO_ADDR registers. After setting PC, PSR for Thumb mode, and SP, it steps execution and checks if the exception number matches i+16. The function counts and returns the number of working interrupts.

:::

Figure 11.5: Counting Interrupt Handlers

[]{#ch11.xhtml_page_118 .pagebreak}Schink used a Segger J-Link debugger
at 3,500 kHz, and extraction time might be improved by reducing
round-trips or increasing the clock rate. This won't matter much for
dumping a single device, of course, but it could be critical if you need
to dump many different chips in order to fill in the coverage gaps with
bytes from different versions of a product's firmware.

[]{#ch12.xhtml}

