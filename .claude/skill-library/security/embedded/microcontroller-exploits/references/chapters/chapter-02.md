## []{#ch02.xhtml_page_15 .pagebreak}**2â€‚STM32F217 DFU Exit** {#ch02.xhtml_ch02 .h2}

Reported privately in Goodspeed (2012) to ST Microelectronics, this
chapter is the first public description of a remote code execution
exploit for the STM32F217, STM32F407, and other chips in the family with
mask ROM implementations of the USB device firmware update (DFU)
protocol. This bug is nice because it's so straightforward: the DFU
implementation restricts access to reading and writing memory of a
locked chip, but changing the target address and executing the
application are both freely allowed.

To dump a locked chip's memory, we'll first use JTAG to place some
shellcode into unused SRAM, then reset the chip and use DFU over USB to
execute that shellcode, dumping all of memory out of the GPIO pins. The
bootloader's dialect of the DFU protocol is documented in STMicro
(2010); be sure to keep that handy as you read this.

::: image
[]{#ch02.xhtml_page_16
.pagebreak}![Image](images/f0016-01.jpg){#ch2fig1}

> **Description:** Die photograph of a microcontroller showing the physical silicon layout. The image reveals distinct regions including large memory arrays with regular patterns occupying the right side, logic blocks in the lower left quadrant, and peripheral circuitry. Bond pads are visible along the edges for external connections. The regular striped patterns indicate SRAM or flash memory cells, while irregular structures represent control logic and processing units.

:::

Figure 2.1: STM32F217

::: image
[]{#ch02.xhtml_page_17
.pagebreak}![Image](images/f0017-01.jpg){#ch2fig2}

> **Description:** Memory map diagram showing address space allocation for a microcontroller. Key regions include Peripherals (0x5fff ffff - 0x4000 0000), SRAM (0x2001 ffff - 0x2000 0000), Option Bytes (0x1fff c000), ROM + OTP (0x1fff 7a0f - 0x1fff 0000), Flash (0x080f ffff - 0x0800 0000), and Boot Memory Alias (0x000f ffff - 0x0000 0000). This layout reveals critical attack surfaces including writable SRAM regions and flash memory boundaries that could be exploited for code injection or memory corruption attacks.

:::

Figure 2.2: Simplified STM32F217 Memory Map

### []{#ch02.xhtml_page_18 .pagebreak}**JTAG and Bootloaders** {#ch02.xhtml_ch00lev1sec4 .h3}

Like most STM32 chips discussed in this book, the STM32F217 has three
protection levels: 0, 1, and 2. Level 0 is unprotected, and if a device
is in this level, you can simply read out the firmware and close this
book. Level 2 allows no debugging of any kind, and devices in that level
are often attacked by first downgrading protection to Level 1.

Level 1 is a middle ground, and the one you'll most often find in
production devices. In this mode, attaching a JTAG debugger will disable
access to flash memory but preserve access to the CPU, to RAM, and to
ROM. There is also the ability to downgrade from Level 1 to Level 0, at
the cost of mass erasing flash memory and destroying whatever might be
held there. Developers like this mode because failure analysis remains
possible, but they are still told that their firmware will remain safe
against extraction.^[1](#footnotes.xhtml_ch2fn1){#ch02.xhtml_ch2fn_1}^

The STM32F217 also has three bootloaders in ROM, one each for accepting
firmware updates by UART, USB DFU, and CAN bus. These three bootloaders
share very little code with one another, and they implement the Level 1
protections in *software*, rather than relying on the hardware
protections that exist when connecting a JTAG debugger. This is good for
us, because it means that if we can trick any one of these three
bootloaders into reading flash memory, we'll be able to choose that
bootloader and dump the chip's firmware.

### []{#ch02.xhtml_page_19 .pagebreak}**The USB DFU Bootloader** {#ch02.xhtml_ch00lev1sec5 .h3}

This chapter's bug is found in the DFU bootloader, which is accessed
over USB. I began by writing a DFU client compatible with the chip, then
used that to dump the ROM at [0x1fff0000]{.literal} for reverse
engineering in order to learn all the
rules.^[2](#footnotes.xhtml_ch2fn2){#ch02.xhtml_ch2fn_2}^

I'll briefly cover the DFU protocol here, but the original documentation
in Henry et al. (2004) is what you should read to really understand or
implement the protocol.

The first thing to know is that DFU supports the following seven
requests: [Detach]{.literal}, [Download]{.literal}, [Upload]{.literal},
[Get Status]{.literal}, [Clear Status]{.literal}, [Get State]{.literal},
and [Abort]{.literal}. Addressing is handled by a block index, rather
than an address, and this block index is relative to an address pointer.

Most high level commands are implemented by calling [Upload]{.literal}
or [Download]{.literal}, followed by [Get Status]{.literal} to learn the
result of the transaction.

Block indexes begin at 2 for data transactions, rather than 0 or 1 as we
might expect. If you upload 32 bytes to index 2, they will be written to
the address pointer. Uploading 32 bytes to index 3 will write them 32
bytes after the address pointer, and uploading 64 bytes to the same
index will write them 64 bytes after the address pointer.

An index of 1 is never used. Index 0 indicates a special block, where
the first byte is one of a few secret commands. Downloading
[\[0x41\]]{.literal} will mass erase all flash memory. An empty string,
[\[\]]{.literal}, will detach the DFU session and execute the
application at the target address. Downloading [\[0x21, 0x1c, 0x32,
0x00, 0x08\]]{.literal} will set the target address pointer to
[0x0800321c]{.literal}. Downloading [\[0x92\]]{.literal} will first mass
erase all of memory, then also unlock the chip to RDP Level
0.^[3](#footnotes.xhtml_ch2fn3){#ch02.xhtml_ch2fn_3}^

::: image
[]{#ch02.xhtml_page_20
.pagebreak}![Image](images/f0020-01.jpg){#ch2fig3}

> **Description:** Firmware update sequence diagram showing communication between Host and Device through USB reset and DFU mode operations. The flow illustrates preparation for upgrade, USB reset triggering driver unloading, DFU mode activation preventing additional driver loading, firmware download phase, exit preparation, and final USB reset to enumerate new firmware descriptors. This sequence exposes potential attack windows during state transitions and driver loading phases.

:::

Figure 2.3: DFU Session, from Henry et al. (2004).

::: image
![Image](images/f0020-02.jpg){#ch2fig4}

> **Description:** Flash memory command table showing opcodes and operations including: 21 (Set 32-bit address pointer), 41 (Mass erase all flash memory), 41 (Erase block at 32-bit address), and 92 (Mass erase and disable read-protection). These commands represent critical attack vectors for bypassing protection mechanisms and gaining unauthorized access to firmware.

:::

Figure 2.4: Zero Block DNLOAD Extensions from STMicro (2010)

[]{#ch02.xhtml_page_21 .pagebreak}You can lock the chip by downloading
[\[0xFF, 0xFF\]]{.literal} to target address [0x1fffc000]{.literal}. In
this case, the index is 2 and we are writing to the specified address,
not to the special zero block.

Once the chip is locked to RDP Level 1, a connection to the DFU ROM is
restricted in the following ways: You cannot [Upload]{.literal} or
[Download]{.literal} except from certain special addresses. Special
commands at index 0 are individually allowed or denied. Of particular
interest is that you may still set the address pointer, and you may exit
the DFU ROM.

### **The Bug** {#ch02.xhtml_ch00lev1sec6 .h3}

After all that background information, the bug itself isn't complicated.
First, JTAG allows us to write an application into unused SRAM, where it
will persist after a reset of the chip re-connects flash memory and
begins to execute the DFU bootloader from ROM. Second, the DFU
bootloader allows us to set the address pointer despite the lock, and
when we exit the bootloader, execution continues to the application at
the target of the pointer!

In practical terms, this means that if the address pointer is set to
[0x20003000]{.literal}, the bootloader will jump at exit to the value
stored in [0x20003004]{.literal}. This address was chosen because it
happens to be in SRAM and unused by the DFU bootloader, so that it won't
be overwritten by the bootloader's stack or global variables.

[]{#ch02.xhtml_page_22 .pagebreak}The shellcode that we execute from
SRAM is rather simple. It transmits all flash memory in a loop using the
SPI protocol, with pin PG6 as MOSI and pin PG8 as CLK. This is nice and
easy to capture with a logic analyzer, as shown in [Figure
2.6](#ch02.xhtml_ch2fig6). If these pins also have LEDs, they will blink
to indicate a successful exploit.

Because our output format is essentially SPI bus traffic, we can use a
logic analyzer's SPI decoder to extract the firmware image from the
recording.

### **Exploitation** {#ch02.xhtml_ch00lev1sec7 .h3}

ST Micro has patched the bug in recent revisions, so a little reverse
engineering of your target's ROM might be a good idea to verify that the
bug is present. A better exploit should be possible by loading 2kB into
the USB frame buffer, then executing the part of them that is not
clobbered by shorter commands.

While this particular exploit only works from RDP Level 1, a glitching
attack such as the one described in [Chapter E.5](#app05.xhtml_app05_5)
can downgrade the protection from Level 2 to Level 1.

::: image
[]{#ch02.xhtml_page_23
.pagebreak}![Image](images/f0023-01.jpg){#ch2fig5}

> **Description:** C code listing for SPI-based firmware flashing. The code includes delay(), spibit(), and spiword() functions for bit-banging SPI communication, followed by a main() function that initializes ports and sends firmware data starting at 0x08000000 (flash memory base). The tight loop sends address and data words through the SPI interface, representing a direct hardware attack implementation.

:::

Figure 2.5: STM32 Shellcode

::: image
[]{#ch02.xhtml_page_24
.pagebreak}![Image](images/f0024-01.jpg){#ch2fig6}

> **Description:** Logic analyzer capture showing SPI communication with Address 0x08000000 and Data 0x20000800. The analyzer settings dialog displays configuration for MSO (8-bit/00), Mosi/Miso protocols, clock polarity, and transfer options including "Check h-ises when inactive" and "Data is valid on Clock trailing Edge." This captures the actual timing and protocol details of a firmware write operation.

:::

Figure 2.6: STM32F217 Firmware Dump

[]{#ch03.xhtml}

