## []{#ch25.xhtml_page_235 .pagebreak}**25  Nintendo CIC and Clones** {#ch25.xhtml_ch25 .h2a}

Back in the late Seventies, there was a manufacturer of home television
videogames known as Atari. Atari's consoles had some great games from
Atari, and from dozens of fly-by-night companies they also had some
shitty ones. By 1983, the latter had saturated the market, resulting in
a market crash and Atari dumping well over half a million cartridges in
a New Mexico landfill. Not only did Atari's reputation suffer for these
bad games, but as they were simply ROM chips on a circuit board, Atari
was often paid no licensing fees for these crummy third-party games.

As Nintendo prepared for their 1985 launch of the Nintendo Entertainment
System (NES) in the North American market, they needed a way to avoid
the same fate. Their solution was the Checking Integrated Circuit (CIC),
a lockout chip required in every NES cartridge, granting Nintendo the
authority to license cartridge manufacturing by constricting CIC supply.
By having separate versions for NTSC and PAL markets, they could also
provide for regional lockout, preventing the poor children of the United
Kingdom from learning that in the outside world, the Teenage Mutant Hero
Turtles were ninjas, and that the one called Michelangelo used illegal
nunchucks.

The scheme worked by having one CIC chip in the NES console, and another
CIC chip in the game cartridge. Starting at reset, each of these would
generate a stream of pseudo-random bits, and any disagreement of those
bits would cause the console to reboot and try again.

Given Nintendo's strict control of game content, there were tempting
profits for anyone who could manufacture games without the CIC chip. In
this chapter, we'll first discuss the analog circuitry that was designed
to glitch out the console's CIC chip, stunning it into not resetting
when the expected sequence failed to arrive. We'll then discuss Tengen's
reverse engineering of the CIC chip, their clone of it, and the open
source clones that appeared in the 21st century.

::: image
[]{#ch25.xhtml_page_236
.pagebreak}![Image](images/f0236-01.jpg){#ch25fig1}

> **Description:** Complete die photograph of complex microcontroller showing heterogeneous architecture. Large dark square region in upper-left likely represents dense SRAM or register file. Central area contains extensive regular ROM arrays with striped patterns. Right side shows memory blocks and logic circuits. Lower section has additional logic and peripheral circuits. The mixed architecture presents multiple attack surfaces including memory interfaces and bus structures.

:::

Figure 25.1: Nintendo's NES CIC Chip

[]{#ch25.xhtml_page_237 .pagebreak}An additional bypass, albeit one a
little less sophisticated, is to simply reuse the CIC from a legitimate
but cheap cartridge. One might also build a "man in the middle"
cartridge that accepts any legitimately licensed cartridge, as a way to
temporarily borrow its CIC.

### **Glitching the Console's CIC** {#ch25.xhtml_ch00lev1sec73 .h3}

Before compatible counterfeits of the CIC chip were made, an intriguing
alternative existed: rather than send the proper pseudo-random sequence,
a cartridge might send a crazy pulse on the cartridge edge connector to
stun the console's CIC chip, with the aim of preventing that chip's
firmware from resetting the console and ending the game.

This works because the console's chip runs entirely independent of the
CPU, and the game continues to run until that CIC resets the console. If
the CIC crashes, its firmware never runs and the console never resets!

The best, and perhaps only, documentation for this glitching technique
is Horton (2004). Horton describes seven different variants of the
gitching circuit, manufactured by Camerica, Color-dreams and AVE. Each
of these variants sends a negative voltage glitch on pin 35 or 70, which
are directly wired to the CIC chip. This crashes the chip so that its
ROM code won't reset the CPU. [Figure 25.2](#ch25.xhtml_ch25fig2) shows
one of these cartridges, easily identified by a glitch configuration
switch on the rear and the absence of any Nintendo seal of quality.

::: image
[]{#ch25.xhtml_page_238
.pagebreak}![Image](images/f0238-01.jpg){#ch25fig2}

> **Description:** Photograph of "Big Nose the Caveman" Game Boy cartridge showing label with character artwork. The cartridge shell is dark with visible ridge notches on sides for secure insertion. Top edge shows gold-plated contacts for electrical connection. This physical cartridge format uses security through obscurity and proprietary connector, but remains vulnerable to ROM dumping through cart readers or direct chip access.

:::

Figure 25.2: Unlicensed Cartridge without a CIC

[]{#ch25.xhtml_page_239 .pagebreak}Nintendo eventually ended the era of
the glitching cartridges by introducing resistors and protection diodes
on pins 35 and 70, so that the cartridge couldn't crash the console's
CIC chip.

### **Tengen's Rabbit: A CIC Clone** {#ch25.xhtml_ch00lev1sec74 .h3}

With the glitching vulnerability closed, manufacturers of unlicensed
games were forced to either include instructions for cutting a pin of
the lockout chip in the console or come up with something that could
convincingly generate the pseudo-random sequence of a real CIC chip.
Tengen, a subsidiary of Atari, managed to do the latter.

The story here is mostly folklore, so please bear with me if at times I
don't let the truth get in the way of a good story. As I understand it,
there was a team of three or four engineers who were reverse engineering
Nintendo's CIC chip by photographing its mask ROM and digging through
Sharp's documentation of the chip family. This team worked many late
nights, and eventually came out with a functioning clone of the CIC
chip, which Tengen packaged as their Rabbit chip, shown in [Figure
25.3](#ch25.xhtml_ch25fig3), then later combined into a mapper chip
known as the Rambo.^[1](#footnotes.xhtml_ch25fn1){#ch25.xhtml_ch25fn_1}^

Nintendo, of course, was furious at Tengen for breaking their subsidy
lock, producing games without authorization and manufacturing even their
licensed games in unlicensed quantities. They sued for damages in the
famous case, *Atari Games Corp. v. Nintendo of America Inc*.

::: image
[]{#ch25.xhtml_page_240
.pagebreak}![Image](images/f0240-01.jpg){#ch25fig3}

> **Description:** Die photograph of mask ROM chip showing clear separation between memory arrays and control logic. Large vertical striped regions occupy center and left sections representing bit cell arrays with regular structure. Upper right contains decoder circuitry with horizontal routing layers. Left side shows additional logic blocks. The C40C marking visible in top left corner. Regular array structure facilitates optical extraction while control logic reveals addressing scheme.

:::

Figure 25.3: Tengen's Rabbit

::: image
[]{#ch25.xhtml_page_241
.pagebreak}![Image](images/f0241-01.jpg){#ch25fig4}

> **Description:** Die photograph showing symmetric dual-bank memory architecture with mirror-image layout. Two large memory arrays positioned on left and right sides with regular vertical striping patterns. Central region contains shared control logic and routing with horizontal metal layers connecting both banks. Upper sections show row decoders with tree-like branching structures. Symmetric design suggests parallel access or redundancy, with central bus representing critical attack point.

:::

Figure 25.4: Tengen's Rabbit Diffusion ROM

[]{#ch25.xhtml_page_242 .pagebreak}Atari had a decent defense: they only
copied portions necessary for compatibility, that none of the creative
portions of the work were copied, and that the reverse engineering was
performed by clean-room methods. Unfortunately, Atari's attorneys were a
little too eager to earn their fees. They had requested a copy of
Nintendo's CIC firmware *before* they were sued by Nintendo, by lying to
the copyright office and claiming that they had *already* been sued.
Oops!

Nintendo won as a result of Atari's unclean hands, and what might have
been a commercially successful example of reverse engineering for
compatibility was instead dumped in the scrap bin of history. Well, for
a dozen years, at least.

### **A Modern Rabbit Clone** {#ch25.xhtml_ch00lev1sec75 .h3}

Details are scattered among forum posts, but by 2006 a dump of the
Rabbit chip's ROM had made it to the [#nesdev]{.literal} forums in
Neviksti (2006). Fox (2006) was then published to the forum, as a
translation of the ROM disassembly to C. You can find it reproduced on
[page 245](#ch25.xhtml_page_245).

Reading through the forum thread is fascinating, and not just because
it's from a time before social media engagement metrics trashed any hope
of long-form discussion. By the third page, Zack S has two CICs wired to
one another, reproducing the check and reset circuits without a console
or game.

By the seventh page, Neviksti's ROM photographs are beginning to be
decoded to bits, with explanations of the ROM circuit reverse engineered
from the die photographs.

This is a somewhat unique case for this book, in that a commercial
exploit of firmware protection was then *itself* exploited to provide a
break that was just as good as a fresh hack of the original chip! The
CIC was cloned into the Rabbit, then the Rabbit was cloned by forums
years before the CIC itself had been publicly dumped.

::: image
[]{#ch25.xhtml_page_243
.pagebreak}![Image](images/f0243-01.jpg){#ch25fig5}

> **Description:** Pinout diagram showing 16-pin DIP configuration for CIC (Checking Integrated Circuit) chip. Left side pins: Data Out (1), Data In (2), Seed (3), Lock/Key (4), N/C (5), Clk in (6), Reset (7), Gnd (8). Right side pins: +5V (16), Gnd (15), Gnd (14), Gnd (13), Gnd/Reset Seed B (12), Gnd/Reset Seed A (11), Slave CIC Reset (10), /Host Reset (9). Multiple ground pins and reset controls suggest security-focused design vulnerable to clock glitching and reset attacks.

:::

Figure 25.5: Nintendo CIC (SM590) Pinout

### **Cloning Nintendo's CIC** {#ch25.xhtml_ch00lev1sec76 .h3}

By late 2006, Tengen's Rabbit chip had been reverse engineered and
cloned from die photographs, but Nintendo's original CIC chip had not
been cloned except by Tengen. That gap was filled by Segher (2010), an
excellent article sourcing images and ROM dumps by Neviksti, as well as
a description of the Sharp SM590 architecture that the chip uses.

Speaking of the SM590, it's a 4-bit CPU, and that's the least bonkers
thing about it. The 10-bit program counter is divided into a 1-bit
field, a 2-bit page, and a 7-bit step. The step is counted in polynomial
rather than linear order, as an LFSR uses fewer transistors than a
linear counter! Like a PIC, the hardware call stack is held apart from
RAM.

### []{#ch25.xhtml_page_244 .pagebreak}**Sharp SM590 Backdoor** {#ch25.xhtml_ch00lev1sec77 .h3}

After all this labor to dump the CIC's ROM, perhaps there was an easier
way? Riddle (2019) documents a backdoor test mode, in which the SM590's
ROM can be dumped through the I/O pins.

Given the pinout in [Figure 25.5](#ch25.xhtml_ch25fig5), the backdoor is
activated by lowering pins 7, 14, and 13 in that order. ROM data will
then appear in 508-byte groups, repeating every 2,032 clock cycles on
pins 12--19 and 4--1.

The start position is somewhat unpredictable, but Riddle suggests that
it can be synchronized either by counting clock cycles after pin 7 is
lowered, or by synchronizing on the long string of zeroes at the end of
the dump.

Riddle notes that the SM591 and SM595 might require changing fields to
get all the data, as not all of memory is covered. We'll see how those
were dumped in [Chapter G.4](#app07.xhtml_app07_4).

::: imagel
[]{#ch25.xhtml_page_245 .pagebreak}![Image](images/f0245-01.jpg)

> **Description:** C source code showing Tengen CIC ROM emulation translated from assembly. Includes stdio and stdlib headers, typedef definitions for unsigned char and int, static RAM array declaration, and functions GetDin, SetDout, Panic, and EndOfFile. The code implements timing-critical bit-banging communication with stream buffering and checksum validation. Comment notes fix for "Dout" output timing issue, indicating reverse-engineered protocol implementation vulnerable to timing analysis.

:::

::: imagel
[]{#ch25.xhtml_page_246 .pagebreak}![Image](images/f0246-01.jpg)

> **Description:** C code continuation showing file operations and CIC protocol implementation. Code reads input file, allocates stream buffer, performs initialization sequence setting specific RAM values, then enters timing-critical loop reading Din and outputting to RAM array. Comments indicate "CIC code begins" and "Timing critical code" sections. The GetDin calls with precise timing and RAM manipulation reveal authentication protocol vulnerable to replay attacks and timing manipulation.

:::

::: imagel
[]{#ch25.xhtml_page_247 .pagebreak}![Image](images/f0247-01.jpg)

> **Description:** C code showing main loop implementation with RAM array manipulation. The code includes nested loops performing bit exchanges between lock and key, with comments explaining "Number of iterations for next loop = 16 - N". First GetDin call occurs at T=0xC8, followed by timing-critical sections. Panic() and EndOfFile() functions handle error conditions and stream completion. Code reveals lock-and-key algorithm vulnerable to cryptanalysis through protocol observation.

:::

::: imagel
[]{#ch25.xhtml_page_248 .pagebreak}![Image](images/f0248-01.jpg)

> **Description:** C code continuation showing complex RAM manipulation algorithm with nested conditional statements and bitwise operations. Code updates LOCK and KEY tables through multiple steps involving array lookups, additions, and masking operations. Variables include tmp, P, sum, N, I, B manipulated through specific sequences. The algorithm performs table mangling with values constrained by masks (0xF, 0x07). Mathematical operations reveal authentication state machine vulnerable to differential analysis.

:::

[]{#app01.xhtml}

