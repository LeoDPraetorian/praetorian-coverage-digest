## []{#ch24.xhtml_page_227 .pagebreak}**24  Clipper Chip Diffusion ROM** {#ch24.xhtml_ch24 .h2a}

In the Nineties, the Clinton administration had an obsession with key
escrow cryptography. They wanted to provide American citizens with
cryptography that the US government itself could break, but in a way
that excluded foreign governments from the same privilege. This was
called the Clipper chip in general, and in this chapter we'll focus on
the PCMCIA generation of that chip, known as the MYK82 or Fortezza card.
We'll dump its firmware and extract it into useful bits.

It worked roughly like this: suppose that Monica calls Bill for a
private conversation. As she hits the *encrypt* button, the two
telephones perform a key exchange. After the keys are exchanged, her
phone will send Bill's phone a bundle called the Law Enforcement Access
Field (LEAF) containing (1) their session key encrypted with Monica's
personal key and (2) a checksum of the session key. The LEAF is
encrypted with a "family key" that every Clipper device contains but
which was not given to consumers. Every unit has the family key, but
only spooky agencies with a warrant were able to look up Monica's
personal key and decrypt the session key.

Astute readers will notice that these keys are all symmetric and that
the scheme does not hold up to an attacker with control of firmware. If
you had the family key, things might work differently. Bill could call
Monica, perform the key exchange, and then send along a tampered LEAF
with (1) a random number and (2) the checksum of the real session key.
Her phone would validate the checksum and allow the call to proceed, but
any spooky agencies listening in would not be able to decrypt the random
number into a session key. Monica's phone does not have access to the
key escrow database, so it's unable to know that the authorities are
being tricked.

::: image
[]{#ch24.xhtml_page_228
.pagebreak}![Image](images/f0228-01.jpg){#ch24fig1}

> **Description:** X-ray photograph of Game Boy cartridge PCB showing the central processor die with distinctive quad-flat package outline. Multiple capacitors and passive components visible as white rectangles on the left side. Bond wires connect die to package leads around perimeter. The semi-transparent view reveals internal chip structure and circuit traces, useful for reverse engineering package pinout and identifying security features before destructive analysis.

:::

Figure 24.1: MYK82 Chip in a Fortezza PCMCIA Card

::: image
[]{#ch24.xhtml_page_229
.pagebreak}![Image](images/f0229-01.jpg){#ch24fig2}

> **Description:** Die photograph of complete microcontroller showing distinct functional blocks arranged in floorplan layout. Upper left contains memory array with horizontal striping, center area has dense logic regions, and right side shows multiple RAM blocks with vertical striping patterns. Peripheral circuits and I/O pads visible around edges. The clear separation of memory, logic, and peripherals helps identify attack targets for fault injection and probing.

:::

Figure 24.2: MYK82 Die

[]{#ch24.xhtml_page_230 .pagebreak}It's also worth noting that Bill does
not strictly need to know the family key. Without a tampered device,
Bill might simply call Monica a few tens of thousands of times while
corrupting the LEAF bundle, until the 16-bit checksum collides and her
phone believes that the LEAF was not corrupted. Blaze (1994) describes
such an attack, as well as a detailed explanation of the Escrowed
Encryption Standard.

The MYK82 chip contained in the Fortezza card implements this protocol,
with handy library functions for using the card in Windows and Solaris.
[Figure 24.1](#ch24.xhtml_ch24fig1) shows this chip on the card in a QFP
package. This package is a little weird in that the lead frame is
*above* the die, and the die faces downward into the PCB. Perhaps this
is to frustrate RF emissions, as the die sits between two ground planes.

The die is shown in its entirety in [Figure 24.2](#ch24.xhtml_ch24fig2).
The CPU can be seen in the southwest, including an ARM6 logo that tells
us we can expect 32-bit ARM instructions without the shortened Thumb
instruction set that came later in ARM7. There are three ROMs on this
chip, with the largest holding code in the east. Two smaller ROMs hold
the same Skipjack F-Table in the south of the chip, just a little east
of center; these are exactly 256 bytes and match up to those in the
Skipjack documentation, which has since been declassified.

The MYK82 chip, like its predecessor the MYK78, uses diffusion ROMs.
These shape the diffusion layer beneath the transistors so that a
working transistor will produce a one and a broken transistor will
produce a zero.

[]{#ch24.xhtml_page_231 .pagebreak}Because bits are not surface visible,
a delayering procedure like that in [Chapter 22](#ch22.xhtml_ch22) is
needed to remove the upper layers that cover the diffusion layer. My
usual procedure for this chip is to first burn off the packaging with
63% nitric acid and then to delayer the chip in 5% hydrofluoric acid.
Both of these run on a hot plate in my fume hood, but I do the HF
reaction in a sealed plastic test tube to minimize the fumes.

Before delayering, bits can just barely be seen in aggregate at low
magnification. This has something to do with optics and a little bit of
exposure, as individual bits can hardly be seen at all. After
delayering, bits dramatically jump out, visible at both high and low
magnifications.

[Figure 24.3](#ch24.xhtml_ch24fig3) is the ROM as a whole, and because
that's still a bit hard to see in print, [Figure
24.5](#ch24.xhtml_ch24fig5) shows just the six most significant bits at
the far right of the ROM. [Figure 24.4](#ch24.xhtml_ch24fig4) shows a
close up of bits. To figure out the decoding, I took those two photos on
a flight to Bogota with no local friends and no local responsibilities.
By the time I left, I had decoded the ROM into 32-bit words and made a
few friends.^[1](#footnotes.xhtml_ch24fn1){#ch24.xhtml_ch24fn_1}^

Our first clue was the ARM6 logo elsewhere on the die. ARM6 predates
Thumb, so all instructions are 32 bits wide and aligned to 32-bits. We
can see that the bottom of the ROM is quite sparse, filled in with the
same color in every bit. These happen to be zeroes, and they correctly
imply that the code is built up from rows at the top of the ROM.

ARM reverse engineers will tell you that 32-bit code stands out because
most instructions begin with an [E]{.literal} as the most significant
nybble. If you look at the right six bits in [Figure
24.5](#ch24.xhtml_ch24fig5), you will see that the each major column
holds two bits. (You might also figure that out from [Figure
24.3](#ch24.xhtml_ch24fig3), where 16 major columns represent 32 bits.)
The rightmost major column is mostly filled with ones, while the major
column to its left has ones on the right half and zeroes on the left
half. This is our [E]{.literal} nybble, formed from the right as one,
one, one, zero!

::: image
[]{#ch24.xhtml_page_232
.pagebreak}![Image](images/f0232-01.jpg){#ch24fig3}

> **Description:** Panoramic die photograph showing extensive ROM array organized as long horizontal columns. The regular striped pattern extends across the image with consistent bit cell structure. Right edge shows decoder or peripheral circuitry with more complex random logic patterns. This large memory capacity suggests program storage, making it a high-value target for intellectual property extraction through optical or invasive techniques.

:::

Figure 24.3: MYK82 Code ROM

::: image
![Image](images/f0232-02.jpg){#ch24fig4}

> **Description:** Close-up die photograph showing two different memory array structures with distinct cell geometries. The upper and lower sections show repetitive grid patterns characteristic of ROM or SRAM, while middle section has denser, more irregular structure suggesting logic or control circuits. The boundary regions between different cell types are potential weak points for fault injection attacks targeting specific memory addresses.

:::

Figure 24.4: MYK82 ROM Bits

::: image
[]{#ch24.xhtml_page_233
.pagebreak}![Image](images/f0233-01.jpg){#ch24fig5}

> **Description:** Large-scale die photograph showing multiple memory banks arranged vertically. Three prominent vertical columns display regular ROM array patterns with horizontal word lines and vertical bit lines clearly visible. Top sections show peripheral circuitry including row/column decoders with more complex routing. The right edge contains different circuit structures possibly for I/O or control logic. Memory organization reveals architecture suitable for systematic extraction.

:::

Figure 24.5: Right six bits of the MYK82 Code ROM

[]{#ch24.xhtml_page_234 .pagebreak}Sure enough, we can find 32-bit words
by taking a bit from each of the 32 minor columns---that's two from each
major column---with the most significant bit on the far right and the
least significant bit on the far left. We already know that the program
begins on the first row because of the empty, zeroed rows at the end.
All that is left is to understand the order of the words within a given
row.

Each of the rows has 512 bits to it, so we know that they contain 16
words apiece. To learn the order, I simply wrote a decoder that output
them in order and piped this into a disassembler. The correct ordering
was from right to left, just as the bits are best read from right to
left.

At this point, it's clear how to decode the ROM into 32-bit words, but
to get them into bytes, we would like to understand the endianness. Does
the most significant byte come first or last? This is where things get
weird.

Endianness is not a matter of byte order in words, but a matter of how
words are seen as bytes or vice versa. The internal ROM is only composed
of 32-bit words that are never fetched in smaller sizes, so it has no
endianness. The ARM6 CPU has no instruction to fetch bytes from ROM, but
there is a wiring decision of the external EEPROM memory. That EEPROM
contains code as big-endian bytes, and it is only from that that we can
say the machine as a whole is big-endian.

[]{#ch25.xhtml}

