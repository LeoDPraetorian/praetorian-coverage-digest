/**
 * Unit Tests for Linear list-issue-relations Wrapper (GraphQL)
 *
 * Tests validate:
 * - Input validation (security constraints, format validation)
 * - Output schema compliance (required fields, type correctness)
 * - GraphQL call behavior (MSW interception)
 * - Nested response structure (issue.relations.nodes)
 * - Edge cases (empty list, missing optional fields)
 * - Error handling (validation failures, GraphQL errors)
 */

import { describe, it, expect, beforeAll, afterAll, afterEach } from 'vitest';
import { setupServer } from 'msw/node';
import { graphql, HttpResponse } from 'msw';
import {
  listIssueRelations,
  listIssueRelationsParams,
  listIssueRelationsOutput,
  type ListIssueRelationsInput,
} from './list-issue-relations';

const linearApi = graphql.link('https://api.linear.app/graphql');

const server = setupServer(
  linearApi.query('IssueRelations', ({ variables }) => {
    return HttpResponse.json({
      data: {
        issue: {
          relations: {
            nodes: [
              {
                id: 'rel-1',
                type: 'blocks',
                relatedIssue: { id: 'issue-2', identifier: 'ISSUE-456', title: 'Related Issue 1' },
              },
              {
                id: 'rel-2',
                type: 'related',
                relatedIssue: { id: 'issue-3', identifier: 'ISSUE-789', title: 'Related Issue 2' },
              },
            ],
          },
        },
      },
    });
  })
);

beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('listIssueRelations (GraphQL)', () => {
  // =========================================================================
  // INPUT VALIDATION
  // =========================================================================

  describe('Input Validation', () => {
    it('validates required issueId field', async () => {
      await expect(
        listIssueRelations.execute({} as ListIssueRelationsInput)
      ).rejects.toThrow();
    });

    it('validates issueId against control characters', async () => {
      await expect(
        listIssueRelations.execute({
          issueId: 'ISSUE\x00123',
        })
      ).rejects.toThrow(/Control characters not allowed/i);
    });

    it('validates issueId against path traversal', async () => {
      await expect(
        listIssueRelations.execute({
          issueId: '../../../etc/passwd',
        })
      ).rejects.toThrow(/Path traversal not allowed/i);
    });

    it('validates issueId against command injection', async () => {
      await expect(
        listIssueRelations.execute({
          issueId: 'ISSUE-123; rm -rf /',
        })
      ).rejects.toThrow(/Invalid characters detected/i);
    });
  });

  // =========================================================================
  // SUCCESSFUL LISTING
  // =========================================================================

  describe('Successful Listing', () => {
    it('lists all relations for an issue', async () => {
      const result = await listIssueRelations.execute(
        { issueId: 'ISSUE-123' },
        { apiKey: 'test-api-key' }
      );

      expect(result.relations).toHaveLength(2);
      expect(result.relations[0].id).toBe('rel-1');
      expect(result.relations[0].type).toBe('blocks');
      expect(result.relations[0].relatedIssue.identifier).toBe('ISSUE-456');
      expect(result.relations[1].type).toBe('related');
    });

    it('handles empty relations list', async () => {
      server.use(
        linearApi.query('IssueRelations', () => {
          return HttpResponse.json({
            data: {
              issue: {
                relations: {
                  nodes: [],
                },
              },
            },
          });
        })
      );

      const result = await listIssueRelations.execute(
        { issueId: 'ISSUE-123' },
        { apiKey: 'test-api-key' }
      );

      expect(result.relations).toHaveLength(0);
    });

    it('handles UUID format issue IDs', async () => {
      const result = await listIssueRelations.execute(
        { issueId: '550e8400-e29b-41d4-a716-446655440000' },
        { apiKey: 'test-api-key' }
      );

      expect(result.relations).toHaveLength(2);
    });

    it('includes all relation types', async () => {
      server.use(
        linearApi.query('IssueRelations', () => {
          return HttpResponse.json({
            data: {
              issue: {
                relations: {
                  nodes: [
                    {
                      id: 'rel-1',
                      type: 'blocks',
                      relatedIssue: { id: 'issue-2', identifier: 'ISSUE-456', title: 'Blocked Issue' },
                    },
                    {
                      id: 'rel-2',
                      type: 'blocked_by',
                      relatedIssue: { id: 'issue-3', identifier: 'ISSUE-789', title: 'Blocking Issue' },
                    },
                    {
                      id: 'rel-3',
                      type: 'duplicate',
                      relatedIssue: { id: 'issue-4', identifier: 'ISSUE-101', title: 'Duplicate' },
                    },
                    {
                      id: 'rel-4',
                      type: 'related',
                      relatedIssue: { id: 'issue-5', identifier: 'ISSUE-202', title: 'Related' },
                    },
                  ],
                },
              },
            },
          });
        })
      );

      const result = await listIssueRelations.execute(
        { issueId: 'ISSUE-123' },
        { apiKey: 'test-api-key' }
      );

      expect(result.relations).toHaveLength(4);
      const types = result.relations.map((r) => r.type);
      expect(types).toContain('blocks');
      expect(types).toContain('blocked_by');
      expect(types).toContain('duplicate');
      expect(types).toContain('related');
    });
  });

  // =========================================================================
  // ERROR HANDLING
  // =========================================================================

  describe('Error Handling', () => {
    it('throws error when GraphQL returns errors', async () => {
      server.use(
        linearApi.query('IssueRelations', () => {
          return HttpResponse.json({
            errors: [{ message: 'Issue not found' }],
          });
        })
      );

      await expect(
        listIssueRelations.execute(
          { issueId: 'invalid-id' },
          { apiKey: 'test-api-key' }
        )
      ).rejects.toThrow(/Issue not found/);
    });

    it('throws when GraphQL returns null data', async () => {
      server.use(
        linearApi.query('IssueRelations', () => {
          return HttpResponse.json({
            data: null,
          });
        })
      );

      await expect(
        listIssueRelations.execute(
          { issueId: 'ISSUE-123' },
          { apiKey: 'test-api-key' }
        )
      ).rejects.toThrow(/No data/);
    });

    it('handles missing relations array gracefully', async () => {
      server.use(
        linearApi.query('IssueRelations', () => {
          return HttpResponse.json({
            data: {
              issue: {},
            },
          });
        })
      );

      await expect(
        listIssueRelations.execute(
          { issueId: 'ISSUE-123' },
          { apiKey: 'test-api-key' }
        )
      ).rejects.toThrow(/Invalid response format/);
    });
  });

  // =========================================================================
  // TOKEN ESTIMATION
  // =========================================================================

  describe('Token Estimation', () => {
    it('includes token estimation in output', async () => {
      const result = await listIssueRelations.execute(
        { issueId: 'ISSUE-123' },
        { apiKey: 'test-api-key' }
      );

      expect(result.estimatedTokens).toBeGreaterThan(0);
    });
  });

  // =========================================================================
  // WRAPPER METADATA
  // =========================================================================

  describe('Wrapper Metadata', () => {
    it('should have correct name', () => {
      expect(listIssueRelations.name).toBe('linear.list_issue_relations');
    });

    it('should have descriptive description', () => {
      expect(listIssueRelations.description).toBe('List all relations for an issue in Linear');
    });

    it('should have parameters schema', () => {
      expect(listIssueRelations.parameters).toBeDefined();
    });

    it('should have tokenEstimate metadata', () => {
      expect(listIssueRelations.tokenEstimate).toBeDefined();
      expect(listIssueRelations.tokenEstimate.reduction).toBe('99%');
    });
  });
});
