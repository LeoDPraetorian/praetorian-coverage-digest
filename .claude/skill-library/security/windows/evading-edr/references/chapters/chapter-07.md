## 7 NETWORK FILTER DRIVERS

![Figure](figures/EvadingEDR_page_149_figure_001.png)

Sometimes an EDR must implement its own sensor to capture the telemetry data generated by certain system components.

Filesystem minifilters are one example of this.

In Windows, the network stack is no different.

A host-based security agent might wish to capture network telemetry for many reasons. Network traffic is tied to the most common way for an attacker to gain initial access to a system (for example, when a user visits a malicious website). It's also one of the key artifacts created when they perform lateral movement to jump from one host to another. If an endpoint security product wishes to capture and perform inspection on network packets, it'll most likely implement some type of network filter driver.

This chapter covers one of the most common driver frameworks used to capture network telemetry: Windows Filtering Platform (WFP). The Windows network stack and driver ecosystem can be a little overwhelming for newcomers, so to reduce the likelihood of headaches, we'll briefly introduce core concepts and then focus only on the elements relevant to an EDR's sensor.

---

## Network-Based vs. Endpoint-Based Monitoring

You might assume that the best way to detect malicious traffic is to use a network-based security appliance, but this isn't always the case. The efficacy of these network appliances depends on their position in the network. For example, a network intrusion detection system (NIDS) would need to sit between host A and host B in order to detect lateral movement between the two.

Imagine that the adversary must cross core network boundaries (for example, to move from the VPN subnet into the data center subnet). In those situations, the security engineers can strategically deploy the appliance at a logical choke point through which all that traffic must flow. This boundaryoriented architecture would look similar to the one shown in Figure 7 - 1 .

![Figure](figures/EvadingEDR_page_150_figure_003.png)

Figure 7-1: A NIDS between two networks

But what about intra-subnet lateral movement, such as movement from workstation to workstation? It wouldn't be cost-effective to deploy a networkmonitoring appliance between every node on the local network, but security teams still need that telemetry to detect adversarial activities in their networks.

This is where an endpoint-based traffic-monitoring sensor comes into play. By deploying a monitoring sensor on every client, a security team can solve the problem of where in the network to insert their appliance. After all, if the sensor is monitoring traffic on a client, as shown in Figure 7-2, it effectively has a man-in-the-middle relationship between the client and all other systems the client may communicate with.

![Figure](figures/EvadingEDR_page_150_figure_007.png)

Figure 7-2: Endpoint network monitoring

124 Chapter 7

---

Using endpoint-based monitoring offers another valuable advantage over network-based solutions: context. Because the agent running on the endpoint can collect additional host-based information, it can paint a more complete picture of how and why the network traffic was created. For example, it could determine that a child process of outlook.exe with a certain PID is communicating with a content distribution network endpoint once every 60 seconds; this might be command-and-control beaconing from a process tied to initial access.

The host-based sensor can get data related to the originating process, user context, and activities that occurred before the connection happened. By contrast, an appliance deployed on the network would be able to see only the metrics about the connection, such as its source and destination, packet frequency, and protocol. While this can provide valuable data to responders, it misses key pieces of information that would aid their investigation.

## Legacy Network Driver Interface Specification Drivers

There are many types of network drivers, most of which are backed by the Network Driver Interface Specification (NDIS). NDIS is a library that abstracts a device's network hardware. It also defines a standard interface between layered network drivers (those operating at different network layers and levels of the operating system) and maintains state information. NDIS supports four types of drivers:

Miniport Manages a network interface card, such as by sending and receiving data. This is the lowest level of NDIS drivers.

Protocol Implements a transport protocol stack, such as TCP/IP. This is the highest level of NDIS drivers.

Filter Sit between miniport and protocol drivers to monitor and modify the interactions between the two subtypes.

Intermediate Sits between miniport and protocol drivers to expose both drivers' entry points for communicating requests. These drivers expose a virtual adapter to which the protocol driver sends its packets. The intermediate driver then ships these packets to the appropriate miniport. After the miniport completes its operation, the intermediate driver passes the information back to the protocol driver. These drivers are commonly used for load-balancing traffic across more than one network interface card.

The interactions of these drivers with NDIS can be seen in the (grossly oversimplified) diagram in Figure 7-3.

For the purposes of security monitoring, filter drivers work best, as they can catch network traffic at the lowest levels of the network stack, just before it is passed to the miniport and associated network interface card. However, these drivers pose some challenges, such as significant code complexity, limited support for the network and transport layers, and a difficult installation process.

Network Filter Drivers 125

---

![Figure](figures/EvadingEDR_page_152_figure_000.png)

Figure 7-3: NDIS driver relationships

But perhaps the biggest issue with filter drivers when it comes to security monitoring is their lack of context. While they can capture the traffic being processed, they aren't aware of the caller context (the process that initiated the request) and lack the metadata needed to provide valuable telemetry to the EDR agent. For this reason, EDRs nearly always use another framework: the Windows Filtering Platform (WFP).

## The Windows Filtering Platform

WFP is a set of APIs and services for creating network-filtering applications, and it includes both user-mode and kernel-mode components. It was designed to replace legacy filtering technologies, including the NDIS filters, starting in Windows Vista and Server 2008. While WFP has some downsides when it comes to network performance, it is generally considered the best option for creating filter drivers. Even the Windows firewall itself is built on WFP.

The platform offers numerous benefits. It allows EDRs to filter traffic related to specific applications, users, connections, network interface cards, and ports. It supports both IPv4 and IPv6, provides boot-time security until the base filtering engine has started, and lets drivers filter, modify, and reinject traffic. It can also process pre- and post-deception IPSec packets and integrates hardware offloading, allowing filter drivers to use hardware for packet inspection.

WFP's implementation can be tricky to understand, as it has a complex architecture and uses unique names for its core components, which are distributed across both user mode and kernel mode. The WFP architecture looks something like what is shown in Figure 7-4.

To make sense of all this, let's follow part of a TCP stream coming from a client connected to a server on the internet. The client begins by calling a function such as h52_32!send() or h52_32!h5ASend() to send data over a connected socket. These functions eventually pass the packet down to the network stack provided by tcpfp.sys for IPv4 and tcpfp6.sys for IPv6.

As the packet traverses the network stack, it is passed to a shim associated with the relevant layer of the stack, such as the stream layer. Shims are kernel components that have a few critical jobs. One of their first responsibilities is to extract data and properties from the packet and pass them to the filter engine to start the process of applying filters.

126 Chapter 7

---

![Figure](figures/EvadingEDR_page_153_figure_000.png)

Figure 7-4: The WFP architecture

## The Filter Engine

The filter engine, sometimes called the generic filter engine to avoid confusion with the user-mode base filtering engine , performs filtering at the network and transport layers. It contains layers of its own, which are containers used to organize filters into sets. Each of these layers, defined as GUIDs under the hood, has a schema that says what types of filters may be added to it. Layers may be further divided into sublayers that manage filtering conflicts. (For example, imagine that the rules “ open port 1028 ” and “ block all ports greater than 1024 ” were configured on the same host.) All layers inherit default sublayers, and developers can add their own.

## Filler Arbitration

You might be wondering how the filter engine knows the order in which to evaluate sublayers and filters. If rules were applied to traffic in a random order, this could cause huge problems. For example, say the first rule was a default-deny that dropped all traffic. To address this problem, both sublayers and filters can be assigned a priority value, called a weight, that dictates the order in which they should be processed by the filter manager. This ordering logic is called filter arbitration .

During filter arbitration, filters evaluate the data passed from the packet from highest to lowest priority to determine what to do with the packet. Each filter contains conditions and an action, just like common firewall rules (for example, “if the destination port is 4444, block the packet” or “if the application is edge.exe, allow the packet”). The basic actions a filter can return are Block and Permit , but three other supported actions pass

Network Filter Drivers | 127

---

packet details to callout drivers: FWP_ACTION_CALLOUT_TERMINATING, FWP_ACTION CALLOUT_INSECTION, and FWP_ACTION_CALLOUT_UNKNOWN.

### Callout Drivers

Callout drivers are third-party drivers that extend WFP's filtering functionality beyond that of the base filters. These drivers provide advanced features such as deep-packet inspection, parental controls, and data logging. When an EDR vendor is interested in capturing network traffic, it typically deploys a callout driver to monitor the system.

Like basic filters, callout drivers can select the types of traffic that they're interested in. When the callout drivers associated with a particular operation are invoked, they can suggest action be taken on the packet based on their unique internal processing logic. A callout driver can permit some traffic, block it, continue it (meaning pass it to other callout drivers), defer it, drop it, or do nothing. These actions are only suggestions, and the driver might override them during the filter arbitration process.

When filter arbitration ends, the result is returned to the shim, which acts on the final filtering decision (for example, permitting the packet to leave the host).

## Implementing a WFP Callout Driver

When an EDR product wants to intercept and process network traffic on a host, it most likely uses a WFP callout driver. These drivers must follow a somewhat complex workflow to set up their callout function, but the flow should make sense to you when you consider how packets traverse the network stack and filter manager. These drivers are also substantially easier to work with than their legacy NDIS counterparts, and Microsoft's documentation should be very helpful for EDR developers looking to add this capability to their sensor lineup.

### Opening a Filter Engine Session

Like other types of drivers, WFP callout drivers begin their initialization inside their internal @freenetry() function. One of the first things the callout driver will do, an activity unique to WFP, is open a session with the filter engine. To do this, the driver calls ftrmgr (@freeningopen(), defined in Listing 7-1.

```bash
DWORD FwpmEngineOpen0(
  [in, optional] const wchar_t           *serverName,
  [in]        UINT32                authnService,
  [in, optional] SEC_WINNT_AUTH_IDENTITY_W *authIdentity,
  [in, optional] const FWPM_SESSIONNO       *session,
  [out]        HANDLE                      *engineHandle
);
```

Listing 7-1: The f1twgr!fwpmEngineOpen() function definition

---

The most notable argument passed to this function as input is auth Service, which determines the authentication service to use. This can be either RPC_C_AUTHN_WINNT or RPC_C_AUTHN_DEFAULT , both of which essentially just tell the driver to use NTLM authentication. When this function completes successfully, a handle to the filter engine is returned through the engineHandle parameter and typically preserved in a global variable, as the driver will need it during its unloading process.

## Registering Callouts

Next, the driver registers its callouts. This is done through a call to the fltmgWfwpcallRegister() API. Systems running Windows 8 or later will convert this function to fltmgrFwpsCallOutRegister2(), the definition of which is included in Listing 7-2.

```bash
NTSTATUS FwpsCalloutRegister2(
  [in, out]        void            *deviceObject,
  [in]            const FWPS_CALLOUT2 *callout,
  [out, optional] UINT32             *calloutId
);
```

Listing 7-2: The fltmgr!FwpsCalloutRegister2() function definition

The pointer to the FwPS_CALLOUT structure passed as input to this function (via its callout parameter) contains details about the functions internal to the callout driver that will handle the filtering of packets. It is defined in Listing 7-3.

```bash
typedef struct FWPS_CALLOUT2_ {
  GUID                          calloutKey;
  UINT32                          flags;
  FWPS_CALLOUT_CLASSIFY_FN2         classifyFn;
  FWPS_CALLOUT_NOTIFY_FN2           notifyFn;
  FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FNO  flowDeleteFn;
} FWPS_CALLOUT2;
```

Listing 7-3: The FWPS_CALLOUT2 structure definition

The notifyfn and flowDeleteFn members are callout functions used to notify the driver when there is information to be passed related to the callout itself or when the data that the callout is processing has been terminated, respectively. Because these callout functions aren't particularly relevant to detection efforts, we won't cover them in further detail. The classifyFn member, however, is a pointer to the function invoked whenever there is a packet to be processed, and it contains the bulk of the logic used for inspection. We'll cover these callouts in “Detecting Adversary Tradecraft with Network Filters” on page 135.

---

## Adding the Callout Function to the Filter Engine

After we've defined the callout function, we can add it to the filter engine by freeing!FWmCallOutAdd(), passing the engine handle obtained earlier and a pointer to an FWmCALLOUT structure, shown in Listing 7-4, as input.

```bash
typedef struct FWPM_CALLOUT0 {
    GUID                calloutKey;
    FWPM_DISPLAY_DATA0 displayData;
    UINT32              flags;
    GUID                *providerKey;
    FWPM_BYTE_BLOB      providerData;
    GUID                applicableLayer;
    UINT32             calloutId;
} FWPM_CALLOUT0;
```

Listing 7-4: The FWPM_CALLOUT structure definition

This structure contains data about the callout, such as its optional friendly name and description in its displayData member, as well as the layers to which the callout should be assigned (for example, FWHM_LAYER_STREAM \_v4 for IPv4 streams). Microsoft documents dozens of filter layer identifiers, each of which usually has IPv4 and IPv6 variants. When the function used by the driver to add its callout completes, it returns a runtime identifier for the callout that is preserved for use during unloading.

Unlike filter layers, a developer may add their own sublayers to the system. In those cases, the driver will call fWpuCInt( FWpmSublayerAdd(), which receives the engine handle, a pointer to an FWPM_SUBLAYER structure, and an optional security descriptor. The structure passed as input includes the sublayer key, a GUID to uniquely identify the sublayer, an optional friendly name and description, an optional flag to ensure that the sublayer persists between reboots, the sublayer weight, and other members that contain the state associated with a sublayer.

## Adding a New Filter Object

The last action a callout driver performs is adding a new filter object to the system. This filter object is the rule that the driver will evaluate when processing the connection. To create one, the driver calls fWpcUnit!FWMFilterAdd(), passing in the engine handle, a pointer to an FWPM_FILTER structure shown in Listing 7-5, and an optional pointer to a security descriptor.

```bash
typedef struct FWPM_FILTER0 {
    GUID                filterKey;
    FWPM_DISPLAY_DATA0  displayData;
    UINT32               flags;
    GUID                *providerKey;
    FWPM_BYTE_BLOB      providerData;
    GUID                layerKey;
```

---

```bash
GUID                sublayerKey;
  FWP_VALUEO           weight;
  UINT32              numFilterConditions;
  FWPM_FILTERConditionO *filterCondition;
  FWPM_ACTIONO           action;
  union {
      UINT64 rawContext;
      GUID   providerContextKey;
    };
  GUID                *reserved;
  UINT64               filterId;
  FWP_VALUEO           effectiveWeight;
} FWPM_FILTERO;
```

Listing 7-5: The FWPM_FILTER structure definition

The PWM_FILTER structure contains a few key members worth highlighting. The flags member contains several flags that describe attributes of the filter, such as whether the filter should persist through system resets (WPWM_FILTER_FLAG_PERSISTENT) or if it is a boot-time filter (WPWM_FILTER_FLAG_BOOTTIME). The weight member defines the priority value of the filter in relation to other filters. The numFilterConditions is the number of filtering conditions specified in the filterCondition member, an array of PWM_FILTER CONDITION structures that describe all the filtering conditions. For the callout functions to process the event, all conditions must be true. Lastly, action is an WP_ACTION_TYPE value indicating what action to perform if all filtering conditions return true. These actions include permitting, blocking, or passing the request to a callout function.

Of these members, filterCondition is the most important, as each filter condition in the array represents a discrete "rule" against which the connections will be evaluated. Each rule is itself made up of a condition value and match type. The definition for this structure is shown in Listing 7-6.

```bash
typedef struct FWPM_FILTER_CONDITIONION_ {
    GUID                fieldKey;
    FWPM_MATCH_TYPE       matchType;
    FWPM_CONDITION_VALUEConditionValue;
} FWPM_FILTER_CONDITIONION;
```

Listing 7-6: The FWPM_FILTER_CONDITION structure definition

The first member, fieldKey, indicates the attribute to evaluate. Each filtering layer has its own attributes, identified by GUIDs. For example, a filter inserted in the stream layer can work with local and remote IP addresses and ports, traffic direction (whether inbound or outbound), and flags (for example, if the connection is using a proxy).

The matchType member specifies the type of match to be performed.

These comparison types are defined in the FHP_MATCH_TYPE enumeration

shown in Listing 7-7 and can match strings, integers, ranges, and other data types.

Network Filter Drivers 131

---

```bash
typedef enum FMP_MATCH_TYPE_ {
    FMP_MATCH_EQUAL = 0,
    FMP_MATCH_GREATER,
    FMP_MATCH_LESS,
    FMP_MATCH_GREATER_OR_EQUAL,
    FMP_MATCH_LESS_OR_EQUAL,
    FMP_MATCH_RANGE,
    FMP_MATCH_FLAGS_ALL_SET,
    FMP_MATCH_FLAGS_ANY_SET,
    FMP_MATCH_FLAGS_NONE_SET,
    FMP_MATCH_EQUAL_CASE_INSENSITIVE,
    FMP_MATCH_NOT_EQUAL,
    FMP_MATCH_PREFIX,
    FMP_MATCH_NOT_PREFIX,
    FMP_MATCH_TYPE_MAX
} FMP_MATCH_TYPE;
```

Listing 7-7: The FWP_MATCH_TYPE enumeration

The last member of the structure, conditionValue, is the condition against which the connection should be matched. The filter condition value is composed of two parts, the data type and a condition value, housed together in the FHP_CONDITION_VALUE structure, shown in Listing 7-8.

```bash
typedef struct FWP_CONDITION_VALUE0_ {
  FWP_DATA_TYPE type;
  union {
      UINT8                 uint8;
      UINT16                 uint16;
      UINT32                 uint32;
      UINT64                 *uint64;
      INT8                 int8;
      INT16                 int16;
      INT32                 int32;
      INT64                 *int64;
      float                 float32;
      double                 *double64;
      FWP_BYTE_ARRAY16    *byteArray16;
      FWP_BYTE_BLOB       *byteBlob;
      SID                   *s1d;
      FWP_BYTE_BLOB        *sd;
      FWP_TOKEN_INFORMATION  *tokenInformation;
      FWP_BYTE_BLOB         *tokenAccessInformation;
      LpWSTR                unicodeString;
      FWP_BYTE_ARRAY6       *byteArray6;
      FWP_V4_ADDR_AND_MASK  *v4AddrMask;
      FWP_V6_ADDR_AND_MASK  *v6AddrMask;
      FWP_RANGE0             *rangeValue;
    };
} FWP_CONDITION_VALUE0;
```

Listing 7-8: The FWP_CONDITION_VALUE structure definition

132 Chapter 7

---

The FMP_DATA_TYPE value indicates what union member the driver should use to evaluate the data. For instance, if the type member is FMP_V4ADDR_MASK, which maps to an IPv4 address, then the v4addrMask member would be accessed.

The match type and condition value members form a discrete filtering requirement when combined. For example, this requirement could be “ if the destination IP address is 1.1.1.1 ” or “ if the TCP port is greater than 1024. ” What should happen when the condition evaluates as true? To determine this, we use the action member of the FWH_FILTER structure. In callout drivers that perform firewalling activities, we could choose to permit or block traffic based on certain attributes. In the context of security monitoring, however, most developers forward the request to the callout functions by specifying the FWH_ACTION_CALLOUT_INVISION flag, which passes the request to the callout without expecting the callout to make a permit/deny decision regarding the connection.

If we combine all three components of the filterCondition member, we could represent a filtering condition as a complete sentence, such as the one shown in Figure 7-5.

![Figure](figures/EvadingEDR_page_159_figure_003.png)

Figure 7-5: Filtering conditions

At this point, we have our rule's basic "if this, do that" logic, but we have yet to deal with some other conditions related to filter arbitration.

## Assigning Weights and Sublayers

What if our driver has filters to, say, both permit traffic on TCP port 1080 and block outbound connections on TCP ports greater than 1024? To handle these conflicts, we must assign each filter a weight. The greater the weight, the higher the priority of the condition, and the earlier it should be evaluated. For instance, the filter allowing traffic on port 1080 should be evaluated before the one blocking all traffic using ports higher than 1024 to permit software using port 1080 to function. In code, a weight is just an FWS_VALUE (UINT8 or UINT64) assigned in the weight member of the FWPM_FILTER structure.

In addition to assigning the weight, we need to assign the filter to a sublayer so that it is evaluated at the correct time. We do this by specifying a GUID in the 1ayerKey member of the structure. If we created our own sublayer, we would specify its GUID here. Otherwise, we'd use one of the default sublayer GUIDs listed in Table 7-1.

Network Filter Drivers 133

---

Table 7-1: Default Sublayer GUIDs

<table><tr><td>Filter sublayer identifier</td><td>Filter type</td></tr><tr><td>FWPM_SUBLAYER_EDGE_TRAVERSAL (BA69DC66-5176-4979-9389-26AB746A8327)</td><td>Edge traversal</td></tr><tr><td>FWPM_SUBLAYER_INSPECTION (877519E1-E6A9-41A5-8184-8C4F118EAAG0)</td><td>Inspection</td></tr><tr><td>FWPM_SUBLAYER_IPSEC_DOSP (E076D572-5D30-48EF-8028-90E9EDB0988D)</td><td>IPsec denial-of-service (DoS) protection</td></tr><tr><td>FWPM_SUBLAYER_IPSEC_FORWARD_OUTBOUND_TUNNEL (45082E73-8F71-4559-8A9A-101CEA04EF97)</td><td>IPsec forward outbound tunnel</td></tr><tr><td>FWPM_SUBLAYER_IPSEC_TUNNEL (33F299ED-9FF4-4967-AF7A-305F4DA827)</td><td>IPsec tunnel</td></tr><tr><td>FWPM_SUBLAYER_LIPS (1B75CCFE-FF60-4711-A70F-B4958C3B2D0)</td><td>Legacy IPsec filters</td></tr><tr><td>FWPM_SUBLAYER_RPC_AUDIT (758CB4FA-FB48-4DE9-9AE8-3ED9551A81FD)</td><td>Remote procedure call (RPC) audit</td></tr><tr><td>FWPM_SUBLAYER_SECURE_SOCKET (15A66E17-3F3C-47f7-A86AC-812AA613DDB2)</td><td>Secure socket</td></tr><tr><td>FWPM_SUBLAYER_TCP_CHIMNEY_OFFLOAD (337608B9-B7D5-4D5F-82F9-36186188C058)</td><td>TCP Chimney Offload</td></tr><tr><td>FWPM_SUBLAYER_TCP_TEMPLATES (24421DCF-0AC5-4CAA-9E14-50F6E366AF0)</td><td>TCP template</td></tr><tr><td>FWPM_SUBLAYER_UNIVERSAL (EEEBEC03-CED4-4380-819A-27349762B74)</td><td>Those not assigned to any other sublayers</td></tr></table>

Note that the FWHM_SUBLAYER_IPEC_SECURITY_REAL sublayer identifier is defined in the fwhm_uh header but is undocumented.

## Adding a Security Descriptor

The last parameter we can pass to fwpsulnt!FwppFilterAdd() is a security descriptor. While optional, it allows the developer to explicitly set the access control list for their filter. Otherwise, the function will apply a default value to the filter. This default security descriptor grants GenericAll rights to members of the Local Administrators group, and GenericRead , GenericWrite , and GenericExecute rights to members of the Network Configuration Operators group, as well as the diagnostic service host (WdiHostServiceHost) . IPsec policy agent (PolicyAgent) , network list service (NetProfm) , remote procedure call (RpcSs) , and Windows firewall (MpsSvc) services. Lastly, FWM_ACTRL_OPEN and FWPM_ACTRL_CLASSIFY are granted to the Everyone group.

After the call to fFuncInt!FFuncInt!terAdd() completes, the callout driver has been initialized, and it will process events until the driver is ready to be unloaded. The unloading process is outside the scope of this chapter, as it is largely irrelevant to security monitoring, but it closes all the previously opened handles, deletes created sublayers and filters, and safely removes the driver.

---

## Detecting Adversary Tradecraft with Network Filters

The bulk of the telemetry that a WFP filter driver collects comes from its callouts. These are most often classify callouts, which receive information about the connection as input. From this data, developers can extract telemetry useful for detecting malicious activity. Let's explore these functions further, starting with their definition in Listing 7-9.

```bash
FWPS_CALLOUT_CLASSIFY_FN2 FwpsCalloutClassifyFn2;
void FwpsCalloutClassifyFn{
  [in]           const FWPS_INCOMING_VALUES0 *inFixedValues,
  [in]           const FWPS_INCOMING_METADATA_VALUES0 *inMetaValues,
  [in, out, optional] void *layerData,
  [in, optional]    const void *classifyContext,
  [in]           const FWPS_FILTER2 *filter,
  [in]           UINT64 flowContext,
  [in, out]        FWPS_CLASSIFY_OUT0 *classifyOut
}
{...}
```

Listing 7-9: The FwpsCalloutClassifyFn definition

On invocation, the callout receives pointers to a few structures containing interesting details about the data being processed. These details include the basic network information you'd expect to receive from any packet-capturing application (the remote IP address, for example) and metadata that provides additional context, including the requesting process's PID, image path, and token.

In return, the callout function will set the action for the stream-layer him to take (assuming the packet being processed is in the stream layer), as well as an action for the filter engine to take, such as to block or allow the packet. It might also defer the decision-making to the next registered callout function. We describe this process in greater detail in the following sections.

### The Basic Network Data

The first parameter, a pointer to an FKPS_INCOMING_VALUES structure, is defined in Listing 7-10 and contains information about the connection that has been passed from the filter engine to the callout.

```bash
typedef struct FWPS_INCOMING_VALUES0 {
    UINT16        layerId;
    UINT32        valueCount;
    FWPS_INCOMING_VALUES *incomingValue;
} FWPS_INCOMING_VALUES0;
```

Listing 7-10: The FWPS_INCOMING_VALUES structure

The first member of this structure contains the identifier of the filter layer at which the data was obtained. Microsoft defines these values (for example, FWM_layer_INBOUND_IPADDRESS_V4).

Network Filter Drivers 135

---

The second member contains the number of entries in the array pointed to by the third parameter, incomingValue . This is an array of FWPS \_INCOMING_VALUE structures containing the data that the filter engine passes to the callout. Each structure in the array has only an FWPS_VALUE structure, shown in Listing 7-11, that describes the type and value of the data.

```bash
typedef struct FWP_VALUE0_ {
    FWP_DATA_TYPE type;
    union {
        UINT8                 uint8;
        UINT16                 uint16;
        UINT32                 uint32;
        UINT64                 *uint64;
        INT8                 int8;
        INT16                 int16;
        INT32                 int32;
        INT64                 *int64;
        float                 float32;
        double                 *double64;
        FWP_BYTE_ARRAY16      *byteArray16;
        FWP_BYTE_BLOB         *byteBlob;
        SID                   *s1d;
        FWP_BYTE_BLOB         *sd;
        FWP_TOKEN_INFORMATION  *tokenInformation;
        FWP_BYTE_BLOB         *tokenAccessInformation;
        LNXSTR                 unicodeString;
        FWP_BYTE_ARRAY6       *byteArray6;
    };
} FWP_VALUE0;
```

Listing 7-11: The FWP_VALUE structure definition

To access the data inside the array, the driver needs to know the index at which the data resides. This index varies based on the layer identifier being processed. For instance, if the layer is FWPS_LAYER_OUTBOUND_IPACKET_V4, the driver would access fields based on their index in the FWPS_FIELDS \_OUTBOUND_IPACKET_V4 enumeration, defined in Listing 7-12.

```bash
typedef enum FWPS_FIELDS_OUTBOUND_IPACKET_V4 {
  FWPS_FIELD_OUTBOUND_IPACKET_V4_IP_LOCAL_ADDRESS,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_IP_LOCAL_ADDRESS_TYPE,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_IP_REMOTE_ADDRESS,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_IP_LOCAL_INTERFACE,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_INTERFACE_INDEX,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_SUB_INTERFACE_INDEX,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_FLAGS,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_INTERFACE_TYPE,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_TUNNEL_TYPE,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_COMPANY_ID,
  FWPS_FIELD_OUTBOUND_IPACKET_V4_MAX
} FWPS_FIELDS_OUTBOUND_IPACKET_V4;
```

Listing 7-12: The FWPS_FIELDS_OUTBOUND_IPPACKET_V4 enumeration.

136 Chapter 7

---

For example, if an EDR's driver wanted to inspect the remote IP address, it could access this value using the code in Listing 7-13 .

```bash
if (inFixedValues->layerId == FWPS_LAYER_OUTBOUND_IPPACKET_V4)
{
  UINT32 remoteAddr = inFixedValues->
    incomingValues[FWPS_FIELD_OUTBOUND_IPPACKET_V4_IP_REMOTE_ADDRESS].value.uint32;
  --snip--
}
```

Listing 7-13: Accessing the remote IP address in the incoming values

In this example, the EDR driver extracts the IP address by referencing the unsigned 32-bit integer ( uint32) value at the index FAPS_FIELD_OUTBOUND

\_1PPACKET_V4_IP_REMOTE_ADDRESS in the incoming values.

## The Metadata

The next parameter that the callout function receives is a pointer to an FPHP5_INCOMING_METADATA_VALUESO structure, which provides incredibly valuable metadata to an EDR, beyond the information you'd expect to get from a packet-capture application such as Wireshark. You can see this metadata in Listing 7-14.

```bash
typedef struct FWPS_INCOMING_METADATA_VALUES0 {
UINT32             currentMetadataValues;
UINT32             flags;
UINT64             reserved;
FWPS_DISCARD_METADATA0    discardMetadata;
UINT64             flowHandle;
UINT32             iheaderSize;
UINT32             transportHeaderSize;
FWP_BYTE_BLOB        *processPath;
UINT64             token;
UINT64             processId;
UINT32             sourceInterfaceIndex;
UINT32             destinationInterfaceIndex;
ULONG             compartmentId;
FWPS_INBOUND_FRAGMENT_METADATA0 fragmentMetadata;
ULONG             pathMu;
NULL             templateHandle;
UINT64             transportEndpointHandle;
SCOPE_ID             remoteScopeId;
WSACMNSGHDR           *controlData;
ULONG             controlDataLength;
FWP_DIRECTION         packetDirection;
PVOID             headerIncludeHeader;
ULONG             headerIncludeHeaderLength;
  IP_ADDRESS_PREFIX       destinationPrefix;
UINT16             frameLength;
UINT64             parentEndpointHandle;
```

Network Filter Drivers 137

---

```bash
UINT32             icmpidAndSequence;
  DWORD               localRedirectTargetPID;
  SOCKADDR             *originalDestination;
  HANDLE               redirectRecords;
  UINT32             current12MetadataValues;
  UINT32             l2Flags;
  UINT32             ethernetMacHeaderSize;
  UINT32             wifIOperationMode;
  NOIS_SWITCH_PORT_ID      vSwitchSourcePortId;
  NOIS_SWITCH_NIC_INDEX     vSwitchSourceNicIndex;
  NOIS_SWITCH_PORT_ID       vSwitchDestinationPortId;
  UINT32             padding0;
  USHORT             padding1;
  UINT32             padding2;
  HANDLE             vSwitchPacketContext;
  PVOID             subProcessTag;
  UINT64             reserved1;
} FWPS_INCOMING_METADATA_VALUES;
```

Listing 7-14: The FWPS_INCOMING_METADATA_VALUES0 structure definition

We mentioned that one of the main benefits to monitoring network traffic on each endpoint is the context that this approach provides to the EDR. We can see this in the processPath, processId, and token members, which give us information about the endpoint process and the associated principal.

Note that not all values in this structure will be populated. To see which values are present, the callout function checks the currentMetadata Values member, which is a bitwise-OR of a combination of metadata filter identifiers. Microsoft nicely provided us with a macro, FWPS_IS_METADATA_FIELD PRESENT(), that will return true if the value we're interested in is present.

## The Layer Data

After the metadata, the classify function receives information about the layer being filtered and the conditions under which the callout is invoked. For example, if the data originates from the stream layer, the parameter will point to an FPWS_STREAM_CALLOUT_10_PACKAGETO structure. This layer data contains a pointer to an FPWS_STREAM_DATA0 structure, which contains flags that encode the characteristics of the stream (for example, whether it is inbound or outbound, whether it is high priority, and whether the network stack will pass the FIN flag in the final packet). It will also contain the offset to the stream, the size of its data in the stream, and a pointer to a NET_BUFFER_LIST that describes the current portion of the stream.

This buffer list is a linked list of NET_BUFFER structures. Each structure in the list contains a chain of memory descriptor lists used to hold the data sent or received over the network. Note that if the request didn't originate from the stream layer, the layerData parameter will point only to a NET_BUFFER \_LIST, assuming it is not null.

The layer data structure also contains a streamAction member, which is

an FWPS_STREAM_ACTION_TYPE value describing an action that the callout recommends the stream-layer shim take. These include:

138 Chapter 7

---

- • Doing nothing (FWPS_STREAM_ACTION_NONE).
  • Allowing all future data segments in the flow to continue without
  inspection (FWPS_STREAM_ACTION_ALLOW_CONNECTION).
  • Requesting more data. If this is set, the callout must populate the
  countBytesRequired member with the number of bytes of stream data
  required (FWPS_STREAM_ACTION_NEED_MORE_DATA).
  • Dropping the connection (FWPS_STREAM_ACTION_DROP_CONNECTION).
  • Deferring processing until fwpcIncl(FlagsStreamContinue()) is called.
  This is used for flow control, to slow down the rate of incoming data
  (FWPS_STREAM_ACTION_DEFER).
  Don't confuse this streamAction member with the classifyNot parameter passed to the classify function to indicate the result of the filtering operation.

## Evading Network Filters

You're probably interested in evading network filters primarily because you'd like to get your command-and-control traffic to the internet, but other types of traffic are subject to filtering too, such as lateral movement and network reconnaissance.

However, when it comes to evading WFP callout drivers, there aren't many options (at least not compared to those available for other sensor components). In a lot of ways, evading network filters is very similar to performing a standard firewall rule assessment. Some filters may opt to explicitly permit or deny traffic, or they may send the contents off for inspection by a callout.

As with any other type of rule-coverage analysis, the bulk of the work comes down to enumerating the various filters on the system, their configurations, and their rulesets. Thankfully, many available tools can make this process relatively painless. The built-in netsh command allows you to export the currently registered filters as an XML document, an example of which is shown in Listing 7-15.

```bash
PS > netsh
netsh> wfp
netsh wfp> show filters
Data collection successful; output = filters.xml
netsh wfp> exit
PS > Select-Xml -iFilters.xml -iXPath 'wfpdiag/filters/item/displayData/name' |
>> ForEach Object { $_Node.ImageXML" }
Rivet IpPacket V4 IpPacket Outbound Filtering Layer
Rivet IpPacket V6 Network Outbound Filtering Layer
Boot Time Filter
Boot Time Filter
Rivet IPv4 Inbound Transport Filtering Layer
Rivet IPv6 Inbound Transport Filtering Layer
Rivet IPv4 Outbound Transport Filtering Layer
Rivet IPv6 Outbound Filtering Layer
```

Network Filter Drivers 139

---

```bash
Boot Time Filter
Boot Time Filter
--snip--
```

Listing 7-15: Enumerating registered filters with netsh

Because parsing XML can cause some headaches, you might prefer to use an alternative tool, NoObjectManager. It includes cmdlets for collecting information related to WFP components, including sublayer identifiers and filters.

One of the first actions you should perform to get an idea of what drivers are inspecting traffic on the system is to list all the non-default sublayers. You can do this using the commands shown in Listing 7-16.

```bash
PS > Import-Module NtObjectManager
PS > Get-FsSubLayer
> Where-Object {$_Name -notlike 'WFP Built-in*}' |
> select Weight, Name, keyname |
> Sort-Object Weight -Descending | fl
Weight  :   32765
Name    :   1Pxlat Forward IPv4 sub layer
KeyName : {4351e497-5d8b-46bc-86d9-abccdb868d6d}
Weight  :   4096
Name    :   windefend
KeyName : {3c1cd879-1b8c-4ab4-8f83-5ed129176ef3}
Weight  :   256
Name    :   OpenVPN
KeyName : {2f660d7e-6a37-11e6-a181-001e8c6e04a2}
```

Listing 7-16: Enumerating WFP sublayers using NIObjectManager

The weights indicate the order in which the sublayers will be evaluated during filter arbitration. Look for interesting sublayers worth exploring further, such as those associated with applications that provide security monitoring. Then, using the Get-Writer cmdlet, return filters associated with the specified sublayer, as shown in Listing 7-17.

```bash
PS > Get-FwFilter |
>> Where-Object {$_SubLayerKeyName -eq '{31cd879-1b8c-4a4b-8f83-5ed129176ef3}' } |
>> Where-Object {$_IsCallout -eq $true} |
>> select ActionType,Name,LayerKeyName,CalloutKeyName,FilterId |
>> fl
ActionType : CalloutTerminating
Name        : windefend_stream_v4
LayerKeyName : FWPM_LAYER_STREAM_V4
CalloutKeyName : {d67b238d-d80c-4ba7-96df-4a0c83464fa7}
FilterId       : 69085
140      Chapter 7
```

---

```bash
ActionType : CalloutInspection
Name : windefend_resource_assignment_v4
LayerKeyName : FWMP_LAYER_ALE_RESOURCE_ASGMENT_V4
CalloutKeyName : {58d7275b-2fd2-4b6c-093a-30037e577de7}
FilterId : 69087
ActionType : CalloutTerminating
Name : windefend_datagram_v6
LayerKeyName : FWMP_LAYER_DATAGRAM_DATA_V6
CalloutKeyName : {80cce9d-0033-4672-ac43-4524416c053}
FilterId : 69092
ActionType : CalloutInspection
Name : windefend_resource_assignment_v6
LayerKeyName : FWMP_LAYER_ALE_RESOURCE_ASGMENT_V6
CalloutKeyName : {ccd78e5f-1dd1-485a-9d35-7644cc9d784d}
FilterId : 69088
```

Listing 7-17: Enumerating filters associated with a subfilter layer

For our purposes, the most interesting filter in this layer is Callout Inspection, as it sends the contents of the network connection to the driver, which will determine whether to terminate the connection. You can inspect callouts by passing their key names to the Get-FwCallout cmdlet. Listing 7-18 shows the process of investigating one of Windows Defender's filters.

```bash
PS > Get-FwCallout
>> Where-Object {$_.KeyName -eq '{d67b238d-80c-4ba7-96df-4a0c83464fa7}'"
>> select *
Flags        : ConditionalOnFlow, Registered
ProviderKey      : 00000000-0000-0000-0000-0000000000000000
ProviderData    : {}
ApplicableLayer : 3b89653c-c170-49e4-b1cd-e0eeeee19a3e
CallOutId       : 0
Key            : {d67b238d-80c-4ba7-96df-4a0c83464fa7}
Name          : windend_stream_v4
Description      : windend
KeyName        : {d67b238d-80c-4ba7-96df-4a0c83464fa7}
SecurityDescriptor : --snip--
ObjectName       : windend_stream_v4
NtType          : Name = Firewall - Index = -1
IsContainer       : False
```

Listing 7-18: Using NiObjectManager to inspect WFP filters

This information helps us determine the type of traffic being inspected, as it includes the layer for which the callout is registered; a description that could make understanding the purpose of the callout more easily identifiable; and the security descriptor, which can be audited to find any potential misconfigurations that would grant excessive control over it. But it still doesn't tell us exactly what the driver is looking for. No two EDR vendors will

Network Filter Drivers | 141

---

inspect the same attributes in the same way, so the only way to know what a driver is examining is to reverse engineer its callout routines.

We can, however, assess WFP filters by looking for configuration gaps like those found in standard firewalls. After all, why bother reverseengineering a driver when we could just look for rules to abuse? One of my favorite ways of evading detection is to find gaps that allow the traffic to slip through. For example, if a callout only monitors IPv4 traffic, traffic sent using IPv6 won't be inspected.

Because bypasses vary between vendors and environments, try looking for rules that explicitly allow traffic to a certain destination. In my experience, these are usually implemented for the particular environment in which the EDR is deployed rather than being part of the EDRs default configuration. Some might even be outdated. Say you discover an old rule allowing all outbound traffic on TCP port 443 to a certain domain. If the domain has expired, you may be able to purchase it and use it as an HTTPS command-and-control channel.

Also look for specific filter configurations that you can take advantage of. For instance, a filter might clear the FROM_FILTER_FLAG_CLEAR_ACTION_RIGHT. As a result, lower-priority filters won't be able to override this filter's decisions. Now say that an EDR explicitly allows traffic to egress to a domain and clears the aforementioned flag. Even if a lower-priority filter issues a block, the traffic will still be allowed out.

(Of course, as with all things WPF, it's not exactly that simple. There exists a flag, FWS_RIGHT_ACTION_WRITE, that vetoes this decision if reset prior to the evaluation of the filter. This is called a filter conflict, and it causes a few things to happen: the traffic is blocked, an audit event is generated, and applications subscribed to notifications will receive one, allowing them to become aware of the misconfiguration.)

In summary, evading WFP filters is a lot like evading traditional firewalls: we can look for gaps in the rulesets, configurations, and inspection logic implemented by an EDR's network filter driver to find ways of getting our traffic out. Evaluate the viability of each technique in the context of the environment and each EDR's particular filters. In some cases, this can be as simple as reviewing the filtering rules. In others, this may mean a deep dive into the driver's inspection logic to determine what is being filtered and how.

## Conclusion

Network filter drivers have the capability to allow, deny, or inspect network traffic on the host. Most relevant to EDR is the inspection function facilitated by these drivers' callouts. When an attacker activity involves the network stack, such as command-and-control agent beaconing and lateral movement, a network filter driver sitting inline of the traffic can pick out indicators of it. Evading these callouts requires understanding the types of traffic they wish to inspect and then identifying gaps in coverage, not dissimilar to a standard firewall rule audit.

---
