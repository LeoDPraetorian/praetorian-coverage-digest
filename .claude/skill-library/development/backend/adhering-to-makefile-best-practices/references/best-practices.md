# Makefile Best Practices - Comprehensive Guide

**Complete catalog of modern Makefile patterns and techniques.**

## Variables and Configuration

### Use `?=` for Defaults

```makefile
# ✅ CORRECT: Allows environment override
GO ?= go
CC ?= gcc
PYTHON ?= python3
BUILD_DIR ?= ./build

# User can override:
# $ make GO=/usr/local/go/bin/go
# $ CC=clang make
```

### Centralize Common Values

```makefile
# Compiler settings
CFLAGS ?= -Wall -Wextra -O2
GO_FLAGS ?= -v -trimpath
GO_LDFLAGS ?= -s -w

# Directory structure
SRC_DIR := ./cmd
BUILD_DIR := ./build
DIST_DIR := ./dist
TEST_DIR := ./test

# Build metadata
VERSION := $(shell git describe --tags --always --dirty)
COMMIT := $(shell git rev-parse --short HEAD)
BUILD_TIME := $(shell date -u '+%Y-%m-%d_%H:%M:%S')
```

### Namespace Variables

For large projects with multiple components:

```makefile
# Frontend variables
FE_SRC_DIR := ./ui/src
FE_BUILD_DIR := ./ui/build
FE_NODE_MODULES := ./ui/node_modules

# Backend variables
BE_SRC_DIR := ./backend
BE_BUILD_DIR := ./backend/build
BE_PKG := github.com/org/project/backend

# Common variables
PROJECT_ROOT := $(shell git rev-parse --show-toplevel)
```

## Target Management

### Always Declare Phony Targets

```makefile
.PHONY: all clean test build deploy install help

all: build test

clean:
	rm -rf $(BUILD_DIR) $(DIST_DIR)

test:
	$(GO) test ./...

build: $(BUILD_DIR)/app

deploy: build
	./scripts/deploy.sh $(BUILD_DIR)/app
```

### Use Namespace Delimiters

```makefile
# ✅ CORRECT: Clear hierarchy with /
.PHONY: build/docker build/binary test/unit test/integration deploy/staging deploy/prod

build/docker:
	docker build -t myapp:latest .

build/binary:
	$(GO) build -o $(BUILD_DIR)/app ./cmd/app

test/unit:
	$(GO) test -short ./...

test/integration:
	$(GO) test -run Integration ./...

deploy/staging:
	kubectl apply -f k8s/staging/

deploy/prod:
	kubectl apply -f k8s/prod/
```

### Self-Documenting Help Target

```makefile
.DEFAULT_GOAL := help

help: ## Display available targets
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_/-]+:.*?## .*$$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-20s\033[0m %s\n", $$1, $$2}'

build: ## Build the application
	$(GO) build -o $(BUILD_DIR)/app ./cmd/app

test: ## Run all tests
	$(GO) test ./...

clean: ## Remove build artifacts
	rm -rf $(BUILD_DIR)
```

## Dependency Management

### Explicit File Dependencies

```makefile
# Go binary depends on all source files
GO_SOURCES := $(shell find . -type f -name '*.go')

$(BUILD_DIR)/app: $(GO_SOURCES) go.mod go.sum
	mkdir -p $(BUILD_DIR)
	$(GO) build -o $@ ./cmd/app

# Proto files trigger regeneration
proto/gen.pb.go: proto/service.proto
	protoc --go_out=. $<
```

### Order-Only Prerequisites

Use `|` for prerequisites that should be created once but don't trigger rebuilds:

```makefile
# Directory creation shouldn't trigger app rebuild
$(BUILD_DIR)/app: $(GO_SOURCES) | $(BUILD_DIR)
	$(GO) build -o $@ ./cmd/app

$(BUILD_DIR):
	mkdir -p $@

# Multiple outputs from single command
$(BUILD_DIR) $(DIST_DIR):
	mkdir -p $@
```

### Grouped Rules

When multiple outputs are generated by a single command:

```makefile
# ✅ CORRECT: Both files generated together
proto/gen.pb.go proto/gen_grpc.pb.go &: proto/service.proto
	protoc --go_out=. --go-grpc_out=. $<

# ❌ WRONG: Runs protoc twice
proto/gen.pb.go: proto/service.proto
	protoc --go_out=. --go-grpc_out=. $<
proto/gen_grpc.pb.go: proto/service.proto
	protoc --go_out=. --go-grpc_out=. $<
```

## Pattern Rules

### Basic Pattern Rules

```makefile
# Compile any .c file to .o file
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Generate .pb.go from .proto
%.pb.go: %.proto
	protoc --go_out=. $<

# Minify any .js file
%.min.js: %.js
	uglifyjs $< -o $@
```

### Pattern Rules with Multiple Targets

```makefile
# Generate both Python and Go clients from OpenAPI spec
clients/%_client.py clients/%_client.go &: specs/%.yaml
	openapi-generator generate -i $< -g python -o clients/
	openapi-generator generate -i $< -g go -o clients/
```

### Static Pattern Rules

```makefile
OBJECTS := foo.o bar.o baz.o

# Only apply this rule to specific files
$(OBJECTS): %.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
```

## Automatic Variables

### Common Automatic Variables

```makefile
example: dep1.c dep2.c dep3.c
	# $@ = example (target name)
	# $< = dep1.c (first prerequisite)
	# $^ = dep1.c dep2.c dep3.c (all prerequisites)
	# $? = (prerequisites newer than target)
	$(CC) $(CFLAGS) $^ -o $@
```

### Pattern-Specific Variables

```makefile
%.o: %.c
	# $* = stem (filename without extension)
	# For foo.c -> foo.o, $* = foo
	$(CC) $(CFLAGS) -c $< -o $@ -MMD -MF $*.d
```

### Advanced Usage

```makefile
# Get directory and filename
BUILD_FILES := $(addprefix $(BUILD_DIR)/,$(notdir $(SOURCES)))

# Replace extensions
GO_TESTS := $(GO_SOURCES:.go=_test.go)

# Filter patterns
GO_MAINS := $(filter %/main.go,$(GO_SOURCES))
```

## Auto-Discovery

### Using wildcard Function

```makefile
# Find all .c files in src directory
C_SOURCES := $(wildcard src/*.c)
C_SOURCES := $(wildcard src/**/*.c)  # Recursive (with shell support)

# Find all .go files
GO_SOURCES := $(wildcard cmd/*.go internal/**/*.go)
```

### Using shell find Command

```makefile
# Most reliable for recursive discovery
GO_SOURCES := $(shell find . -type f -name '*.go' -not -path './vendor/*')

C_SOURCES := $(shell find src -name '*.c')

# Multiple patterns
ALL_SOURCES := $(shell find . -type f \( -name '*.go' -o -name '*.proto' \))
```

### Excluding Directories

```makefile
# Exclude vendor and test directories
GO_SOURCES := $(shell find . -name '*.go' \
	-not -path './vendor/*' \
	-not -path './test/*' \
	-not -path '*/mocks/*')

# Using grep -v
GO_SOURCES := $(shell find . -name '*.go' | grep -v -E '(vendor|test)')
```

## Safety and Error Handling

### Essential Special Targets

```makefile
# Delete targets on error (prevents partial builds)
.DELETE_ON_ERROR:

# Don't delete intermediate files
.SECONDARY:

# Make recipes execute in one shell (default is separate shell per line)
.ONESHELL:

# Silent mode (don't print commands)
.SILENT:

# Always execute (ignore up-to-date checks)
.PHONY: always
always:
	@true
```

### Error Handling

```makefile
# Stop on first error (default)
.POSIX:

# Continue on error for specific target
.IGNORE: clean
clean:
	rm -rf $(BUILD_DIR)
	rm -rf $(DIST_DIR)

# Prefix with - to ignore errors for specific command
clean:
	-rm -rf $(BUILD_DIR)
	-rm -rf $(DIST_DIR)
```

### Conditional Compilation

```makefile
# Check if command exists
ifeq ($(shell command -v docker 2>/dev/null),)
$(error Docker is required but not installed)
endif

# Platform-specific rules
ifeq ($(shell uname),Darwin)
LDFLAGS += -framework CoreFoundation
else ifeq ($(shell uname),Linux)
LDFLAGS += -ldl
endif

# Debug vs Release
ifdef DEBUG
CFLAGS += -g -O0
else
CFLAGS += -O2 -DNDEBUG
endif
```

## Performance Optimization

### Parallel Builds

```makefile
# Use -j flag: make -j8
# Or specify in Makefile:
MAKEFLAGS += -j8

# Limit parallelism for specific target
.NOTPARALLEL: serialized-target
```

### Dependency Files

```makefile
# Generate dependency files during compilation
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@ -MMD -MF $*.d

# Include dependency files (suppress error if not found)
-include $(OBJECTS:.o=.d)
```

### Minimize Shell Invocations

```makefile
# ❌ SLOW: Multiple shell calls
FILES := $(shell find . -name '*.go')
COUNT := $(shell find . -name '*.go' | wc -l)

# ✅ FAST: Single shell call
FILES_AND_COUNT := $(shell find . -name '*.go' | tee /tmp/files.txt | wc -l)
FILES := $(shell cat /tmp/files.txt)
COUNT := $(FILES_AND_COUNT)
```

## Cross-Platform Compatibility

### Platform Detection

```makefile
# Detect OS
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
    OS := linux
else ifeq ($(UNAME_S),Darwin)
    OS := darwin
else ifeq ($(UNAME_S),Windows_NT)
    OS := windows
endif

# Detect architecture
UNAME_M := $(shell uname -m)
ifeq ($(UNAME_M),x86_64)
    ARCH := amd64
else ifeq ($(UNAME_M),aarch64)
    ARCH := arm64
endif
```

### Path Separators

```makefile
# Use forward slashes (works on all platforms with GNU make)
BUILD_DIR := ./build/bin

# Or use $(subst) to convert
WINDOWS_PATH := $(subst /,\,$(BUILD_DIR))
```

### Shell Compatibility

```makefile
# Specify shell explicitly
SHELL := /bin/bash

# Or use portable commands only
.PHONY: clean
clean:
	rm -rf $(BUILD_DIR)  # Works on Unix and Git Bash on Windows
```

## Testing Integration

### Go Tests

```makefile
.PHONY: test test/unit test/integration test/coverage

test: test/unit test/integration ## Run all tests

test/unit: ## Run unit tests
	$(GO) test -short -race -v ./...

test/integration: ## Run integration tests
	$(GO) test -run Integration -v ./...

test/coverage: ## Generate coverage report
	$(GO) test -coverprofile=coverage.out ./...
	$(GO) tool cover -html=coverage.out -o coverage.html
```

### Python Tests

```makefile
.PHONY: test test/unit test/integration

PYTEST := pytest
PYTEST_FLAGS := -v --tb=short

test: test/unit test/integration ## Run all tests

test/unit:
	$(PYTEST) $(PYTEST_FLAGS) tests/unit/

test/integration:
	$(PYTEST) $(PYTEST_FLAGS) tests/integration/

test/watch:
	$(PYTEST) $(PYTEST_FLAGS) --looponfail tests/
```

## CI/CD Integration

### GitHub Actions Example

```makefile
.PHONY: ci ci/lint ci/test ci/build

ci: ci/lint ci/test ci/build ## Run full CI pipeline

ci/lint:
	golangci-lint run ./...

ci/test:
	go test -race -coverprofile=coverage.txt -covermode=atomic ./...

ci/build:
	go build -v ./...
```

### Docker Integration

```makefile
DOCKER_IMAGE := myapp:$(VERSION)

.PHONY: docker/build docker/push docker/run

docker/build: ## Build Docker image
	docker build -t $(DOCKER_IMAGE) .

docker/push: docker/build ## Push to registry
	docker push $(DOCKER_IMAGE)

docker/run: docker/build ## Run container
	docker run --rm -it -p 8080:8080 $(DOCKER_IMAGE)
```

## Related Resources

- [Variable Patterns](variable-patterns.md) - Detailed variable usage
- [Target Patterns](target-patterns.md) - Target organization
- [Dependency Patterns](dependency-patterns.md) - Dependency management
- [Anti-Patterns](anti-patterns.md) - What to avoid
