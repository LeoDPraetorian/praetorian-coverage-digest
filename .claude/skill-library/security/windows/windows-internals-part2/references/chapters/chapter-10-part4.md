
->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

->5bz1 : 0x0

->Cbrto1 : 0x8004

->Revision: 0x1

---

```bash
->Dac1   : ->Ace[5] : ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dac1   : ->Ace[5]: ->AceFlags: 0x0
->Dac1   : ->Ace[5]: ->AceSize: 0x18
->Dac1   : ->Ace[5]: ->Mask : 0x00000ee5
->Dac1   : ->Ace[5]: ->SID: S-1-5-32-559
->Dac1   : ->Ace[6]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dac1   : ->Ace[6]: ->AceFlags: 0x0
->Dac1   : ->Ace[6]: ->AceSize: 0x18
->Dac1   : ->Ace[6]: ->Mask : 0x00000004
->Dac1   : ->Ace[6]: ->SID: S-1-5-32-558
You can use the Psgetsid tool (available at https://docs.microsoft.com/en-us/sysinternals/
downloads/psgetsid) to translate the SID to human-readable names. From the preceding output,
you can see that all ETW access is granted to the SYSTEM (S-1-5-18), LOCAL SERVICE (S-1-5-19),
NETWORK SERVICE (S-1-5-18), and Administrators (S-1-5-32-544) groups. As explained in the pre-
vious section, the Performance Log Users group (S-1-5-32-559) has almost all ETW access, where-
as the Performance Monitor Users group (S-1-5-32-558) has only the WMIGUID_NOTIFICATION
access right granted by the session's default security descriptor.
C:\Users\andrea>\psgetsid64 S-1-5-32-559
PGetSid v1.45 - Translates SIDs to names and vice versa
Copyright (C) 1999-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
Account for AALL86-LAPTOP\S-1-5-32-559:
Alias: BUILTIN\Performance Log Users
```

## Security Audit logger

The Security Audit logger is an ETW session used by the Windows Event logger service (wetvsd.dll) to

listen for events generated by the Security Loss Provider. The Security Loss provider (which is identi fied by the {54849625-5478-4994-a5ba-3e3b0328c30d} GUID) can be registered only by the NT kernel

at ETW initialization time and is never inserted in the global provider's hash table. Only the Security

audit logger and Autologgers configured with the EnableSecurityProvider registry value set to 1 can re ceive events from the Security Loss Provider. When the EtwStartAutoLogger internal function encoun ters the value set to 1, it enables the SECURITY_TRACE flag on the associated ETW session, adding the

session to the list of loggers that can receive Security audit events.

The flag also has the important effect that user-mode applications can't query, stop, flush, or control

the session anymore, unless they are running as protected process light (at the antimalware, Windows,

or WinTcb level; further details on protected processes are available in Chapter 3 of Part 1).

## Secure loggers

Classic (MOF) and WPP providers have not been designed to support all the security features implemented for manifest-based and tracelogging providers. An Autologger or a generic ETV session can

524      CHAPTER 10  Management, diagnostics, and tracing


---

thus be created with the EVENT_TRACE_SECURE_MODE flag, which marks the session as secure. A

secure session has the goal of ensuring that it receives events only from trusted identities. The flag has

two main effects:

- Prevents classic (MOF) and WPP providers from writing any event to the secure session. If a clas-
sic provider is enabled in a secure section, the provider won't be able to generate any events.
Requires the supplemental TRACELOG_LOG_EVENT access right, which should be granted by
the session's security descriptor to the controller application's access token while enabling a
provider to the secure session.
The TRACE_LOG_EVENT access right allows a more-granular security to be specified in a session's security descriptor. If the security descriptor grants only the TRACELOG_GUID_ENABLE to an untrusted user, and the ETW session is created as secure by another entity (a kernel driver or a more privileged application), the untrusted user can't enable any provider on the secure section. If the section is created as nonsecure, the untrusted user can enable any providers on it.

## Dynamic tracing (DTrace)

As discussed in the previous section, Event Tracing for Windows is a powerful tracing technology integrated into the OS, but it's static, meaning that the end user can only trace and log events that are generated by well-defined components belonging to the operating system or to third-party frameworks/ applications (NET CLR, for example.) To overcome the limitation, the May 2019 Update of Windows 10 (19H1) introduced DTrace, the dynamic tracing facility built into Windows. DTrace can be used by administrators on live systems to examine the behavior of both user programs and of the operating system itself. DTrace is an open-source technology that was developed for the Solaris operating system (and its descendant, illumos, both of which are Unix-based) and ported to several operating systems other than Windows.

DTrace can dynamically trace parts of the operating system and user applications at certain locations of interest, called probes. A probe is a binary code location or activity to which DTrace can bind a request to perform a set of actions, like logging messages, recording a stack trace, a timestamp, and so on. When a probe fires, DTrace gathers the data from the probe and executes the actions associated with the probe. Both the probes and the actions are specified in a script file (or directly in the DTrace application through the command line), using the D programming language. Support for probes are provided by kernel modules, called providers. The original illumos DTrace supported around 20 providers, which were deeply tied to the Unix-based OS. At the time of this writing, Windows supports the following providers:

- ■ SYSCALL Allows the tracing of the OS system calls (both on entry and on exit) invoked from
user-mode applications and kernel-mode drivers (through Zw* APIs).

■ FBT (Function Boundary tracing) Through FBT, a system administrator can trace the execution
of individual functions implemented in all the modules that run in the NT kernel.

■ PID (User-mode process tracing) The provider is similar to FBT and allows tracing of individual
functions of a user-mode process and application.
CHAPTER 10 Management, diagnostics, and tracing 525


---

- ETW (Event Tracing for Windows) DTrace can use this provider to attach to manifest-based and
TraceLogging events fired from the ETW engine. DTrace is able to define new ETW providers and
provide associated ETW events via the etw_trace action (which is not part of any provider).

PROFILE Provides probes associated with a time-based interrupt firing every fixed, specified
time interval.

DTRACE Built-in provider is implicitly enabled in the DTrace engine.
The listed providers allow system administrators to dynamically trace almost every component of the Windows operating system and user-mode applications.

![Figure](figures/Winternals7thPt2_page_557_figure_002.png)

Note There are big differences between the first version of DTrace for Windows, which appeared in the May 2019 Update of Windows 10, and the current stable release (distributed at the time of this writing in the May 2021 edition of Windows 10). One of the most notable differences is that the first release required a kernel debugger to be set up to enable the FBT provider. Furthermore, the ETW provider was not completely available in the first release of DTrace.

## EXPERIMENT: Enabling DTrace and listing the installed providers

In this experiment, you install and enable DTrace and list the providers that are available for dynamically tracing various Windows components. You need a system with Windows 10 May 2020 Update (20H) or later installed. As explained in the Microsoft documentation (https://docs. microsoft.com/en-us/windows-hardware/drivers/devtest/dtrace), you should first enable DTrace by opening an administrative command prompt and typing the following command (remember to disable Bitlocker, if it is enabled):

```bash
bcdedit /set dtrace ON
```

After the command succeeds, you can download the DTrace package from https://www. microsoft.com/download/details.aspx?id=100441 and install it. Restart your computer (or virtual machine) and open an administrative command prompt (by typing CMD in the Cortana search box and selecting Run As Administrator). Type the following commands (replacing providers.txt with another file name if desired):

```bash
cd /C:\Program Files\DCtrace\
dtrace -l > providers.txt
```

Open the generated file (providers.txt in the example). If DTrace has been successfully

installed and enabled, a list of probes and providers (DTrace, syscall, and ETW) should be listed in

the output file. Probes are composed of an ID and a human-readable name. The human-readable

name is composed of four parts. Each part may or may not exist, depending on the provider. In

general, providers try to follow the convention as close as possible, but in some cases the mean ing of each part can be overloaded with something different:

- ■ Provider The name of the DTrace provider that is publishing the probe.
---

- ■ Module If the probe corresponds to a specific program location, the name of the module
in which the probe is located. The module is used only for the PID (which is not shown in the
output produced by the dtrace -l command) and ETW provider.
■ Function If the probe corresponds to a specific program location, the name of the
program function in which the probe is located.
■ Name The final component of the probe name is a name that gives you some idea of the
probe's semantic meaning, such as BEGIN or END.
When writing out the full human-readable name of a probe, all the parts of the name are separated by colors. For example,

```bash
syscall::NtQuerySystemInformation::entry
```

specifies a probe on the NTQueryInformation function entry provided by the syscall provider.


Note that in this case, the module name is empty because the syscall provider does not specify


any name (all the syscalls are implicitly provided by the NT kernel).

The PID and FBT providers instead dynamically generate probes based on the process or

kernel image to which they are applied (and based on the currently available symbols). For ex ample, to correctly list the PID probes of a process, you should first get the process ID (PID) of the

process that you want to analyze (by simply opening the Task Manager and selecting the Details

property sheet; in this example, we are using Notepad, which in the test system has PID equal to

8020). Then execute DTrace with the following command:

```bash
dtrace -ln pid8020:::entry > pid_notepad.txt
```

This lists all the probes on function entries generated by the PID provider for the Notepad

process. The output will contain a lot of entries. Note that if you do not have the symbol store

path set, the output will not contain any probes generated by private functions. To restrict the

output, you can add the name of the module:

```bash
dtrace.exe -ln pid8020:kernelbase::entry >pid_kernelbase_notepad.txt
```

This yields all the PID probes generated for function entries of the kernelbase.dll module

mapped in Notepad. If you repeat the previous two commands after having set the symbol store

path with the following command,

```bash
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
```

you will find that the output is much different (and also probes on private functions).

As explained in the "The Function Boundary Tracing (FBT) and Process (PID) providers" section

later in this chapter, the PID and FBT provider can be applied to any offset in a function's code.

The following command returns all the offsets (always located at instruction boundary) in which

the PID provider can generate probes on the SetComputerNameW function of Kernelbase dll:

```bash
dtrace.exe -ln pid8020:kernelbase:SetComputerNameW:
```

---

## Internal architecture

As explained in the "Enabling DTrace and listing the installed providers" experiment earlier in this chapter, in Windows 10 May 2020 Update (20H), some components of DTrace should be installed through an external package. Future versions of Windows may integrate DTrace completely in the OS image. Even though DTrace is deeply integrated in the operating system, it requires three external components to work properly. These include both the NT-specific implementation and the original DTrace code released under the free Common Development and Distribution License (CDDL), which is downloadable from https://github.com/microsoft/DTrace-on-Windows/tree/windows.

As shown in Figure 10-37, DTrace in Windows is composed of the following components:

- ■ DTrace.sys The DTrace extension driver is the main component that executes the actions as-
sociated with the probes and stores the results in a circular buffer that the user-mode applica-
tion obtains via IOCTLs.

■ DTrace.dll The module encapsulates LibDTrace, which is the DTrace user-mode engine.
It implements the Compiler for the D scripts, sends the IOCTLs to the DTrace driver, and is the
main consumer of the circular DTrace buffer (where the DTrace driver stores the output of
the actions).

■ DTrace.exe The entry point executable that dispatches all the possible commands (specified
through the command line) to the LibDTrace.
![Figure](figures/Winternals7thPt2_page_559_figure_004.png)

FIGURE 10-37 DTrace internal architecture.

To start the dynamic trace of the Windows kernel, a driver, or a user-mode application, the user

just invokes the DTrace.exe main executable specifying a command or an external D script. In both

cases, the command or the file contain one or more probes and additional actions expressed in the D

programming language. DTrace.exe parses the input command line and forwards the proper request

528     CHAPTER 10  Management, diagnostics, and tracing


---

to the LibDTrace (which is implemented in DTrace.dll). For example, when started for enabling one or

more probes, the DTrace executable calls the internal dtrace_program_fcompile function implemented

in LibDTrace, which compiles the D script and produces the DTrace Intermediate Format (DIF) bytecode

in an output buffer.

![Figure](figures/Winternals7thPt2_page_560_figure_001.png)

Note Describing the details of the DIF bytecode and how a D script (or D commands) is

compiled is outside the scope of this book. Interested readers can find detailed documenta tion in the OpenTrace Specification book (released by the University of Cambridge), which

is available at https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-924.pdf.

While the D compiler is entirely implemented in user-mode in LibDTrace, to execute the compiled DIF bytecode, the LibTrace module just sends the DTRACEIO_ENABLEIOCTL to the DTrace driver, which implements the DIF virtual machine. The DIF virtual machine is able to evaluate each D clause expressed in the bytecode and to execute optional actions associated with them. A limited set of actions are available, which are executed through native code and not interpreted via the D virtual machine.

As shown earlier in Figure 10-37, the DTrace extension driver implements all the providers. Before discussing how the main providers work, it is necessary to present an introduction of the DTrace initialization in the Windows OS.

## DTrace initialization

The DTRACE initialization starts in early boot stages, when the Windows loader is loading all the mod ules needed for the kernel to correctly start. One important part to load and validate is the API set file (apisetschema.dll), which is a key component of the Windows system. (API Sets are described in Chapter 3 of part 1). If the DTRACE_ENABLED BCD element is set in the boot entry (value 0x26000145, which can be set through the dtrace readable name; see Chapter 12 for more details about BCD objects), the Windows loader checks whether the dtrace.sys driver is present in the %SystemRoot%\System32\ Drivers path. If so, it builds a new API Set schema extension named ext-ms-win-ntos-trace-ll-1-0. The schema targets the DTRACE.sys driver and is merged into the system API set schema (QslApiSetSchema).

Later in the boot process, when the NT kernel is starting its phase 1 of initialization, the TraceInilSystem function is called to initialize the Dynamic Tracing subsystem. The API is imported in the NT kernel through the ext-ms-win-rtos-trace-It-1-0.dll API set schema. This implies that if DTrace is not enabled by the Windows loader, the name resolution would fail, and the function will be basically a no op.

The TraceInitSystem has the important duty of calculating the content of the trace callouts array, which contains the functions that will be called by the NT kernel when a trace probe fires. The array is stored in the KIDynamicTraceCalloutS global symbol, which will be later protected by Patchguard to prevent malicious drivers from illegally redirecting the flow of execution of system routines. Finally, through the TraceInitSystem function, the NT kernel sends to the DTrace driver another important array, which contains private system interfaces used by the DTrace driver to apply the probes. (The array is exposed in a trace extension context data structure.) This kind of initialization, where both the DTrace driver and the NT kernel exchange private interfaces, is the main motivation why the DTrace driver is called an extension driver.

CHAPTER 10    Management, diagnostics, and tracing     529


---

The Pnp manager later starts the DTrace driver, which is installed in the system as boot driver, and calls its main entry point (DriverEntry). The routine registers the \DeviceDTrace control device and its symbolic link {\GLOBAL?\DTrace}. It then initializes the internal DTrace state, creating the first DTrace built-in provider. It finally registers all the available providers by calling the initialization function of each of them. The initialization method depends on each provider and usually ends up calling the internal drace_register function, which registers the provider with the DTrace framework. Another common action in the provider initialization is to register a handler for the control device. User-mode applications can communicate with DTrace and with a provider through the DTrace control device, which exposes virtual files (handlers) to providers. For example, the user-mode LibDTrace communicates directly with the PID provider by opening a handle to the \DTrace/Fasttrap virtual file (handler).

## The syscall provider

When the syscall provider gets activated, DTrace ends up calling the KeSetSystemServiceCallback routine, with the goal of activating a callback for the system call specified in the probe. The routine is exposed to the DTrace driver thanks to the NT system interfaces array. The latter is compiled by the NT kernel at DTrace initialization time (see the previous section for more details) and encapsulated in an extension context data structure internally called KiDynamicTraceContext. The first time that the KeSetSystemServiceCallback is called, the routine has the important task of building the global service trace table (KiSystemServiceTraceCallbackTable), which is an RB (red-black) tree containing descriptors of all the available syscalls. Each descriptor includes a hash of the syscall's name, its address, and number of parameters and flags indicating whether the callback is enabled on entry or on exit. The NT kernel includes a static list of syscalls exposed through the KiServicesTab internal array.

After the global service trace table has been filled, the KeSetSystemServiceCallback calculates the hash of the syscall's name specified by the probe and searches the hash in the RB tree. If there are no matches, the probe has specified a wrong syscall name (so the function exits signaling an error). Otherwise, the function modifies the enablement flags located in the found syscall's descriptor and increases the number of the enabled trace callbacks (which is stored in an internal variable).

When the first Trace syscall call is enabled, the NT kernel sets the syscall bit in the global KiDynamicTraceMask bitmask. This is very important because it enables the system call handler (KiSystemCall64) to invoke the global trace handlers. (System calls and system service dispatching have been discussed extensively in Chapter 8.)

This design allows DTrace to coexist with the system call handling mechanism without having any

sort of performance penalty. If no DTrace syscall probe is active, the trace handlers are not invoked. A

trace handler can be called on entry and on exit of a system call. Its functionality is simple. It just scans

the global service trace table looking for the descriptor of the system call. When it finds the descrip tor, it checks whether the enablement flag is set and, if so, invokes the correct callout (contained in the

global dynamic trace callout array, KIDynamicTraceCallouts, as specified in the previous section). The

callout, which is implemented in the DTrace driver, uses the generic internal dtrace_probe function to

fire the syscall probe and execute the actions associated with it.

---

## The Function Boundary Tracing (FBT) and Process (PID) providers

Both the FBT and PID providers are similar because they allow a probe to be enabled on any function entry and exit points (not necessarily a syscall). The target function can reside in the NT kernel or as part of a driver (for these cases, the FBT provider is used), or it can reside in a user-mode module, which should be executed by a process. (The PID provider can trace user-mode applications.) An FBT or PID probe is activated in the system through breakpoint opcodes (INT 3 in x86, BRK in ARM64) that are written directly in the target function's code. This has the following important implications:

- When a PID or FBT probe raises, DTrace should be able to re-execute the replaced instruction
before calling back the target function. To do this, DTrace uses an instruction emulator, which,
at the time of this writing, is compatible with the AMD64 and ARM64 architecture. The emula-
tor is implemented in the NT kernel and is normally invoked by the system exception handler
while dealing with a breakpoint exception.
DTrace needs a way to identify functions by name. The name of a function is never compiled in
the final binary (except for exported functions). DTrace uses multiple techniques to achieve this,
which will be discussed in the "DTrace type library" section later in this chapter.
A single function can exit (return) in multiple ways from different code branches. To identify the
exit points, a function graph analyzer is required to disassemble the function's instructions and
find each exit point. Even though the original function graph analyzer was part of the Solaris
code, the Windows implementation of DTrace uses a new optimized version of it, which still lives
in the LibDTrace library (DTrace.dll). While user-mode functions are analyzed by the function
graph analyzer, DTrace uses the PDATA v2 unwind information to reliably find kernel-mode
function exit points (more information on function unwinds and exception dispatching is avail-
able in Chapter 8). If the kernel-mode module does not make use of PDATA v2 unwind informa-
tion, the FBT provider will not create any probes on function returns for it.
DTrace installs FBT or PID probes by calling the KeSetTracepoint function of the NT kernel exposed through the NT System interfaces array. The function validates the parameters (the callback pointer in particular) and, for kernel targets, verifies that the target function is located in an executable code section of a known kernel-mode module. Similar to the syscall provider, a KI_TRACEPOINT_ENTRY data structure is built and used for keeping track of the activated trace points. The data structure contains the owning process, access mode, and target function address. It is inserted in a global hash table, KItpHashTable, which is allocated at the first time an FBT or PID probe gets activated. Finally, the single instruction located in the target code is parsed (imported in the emulator) and replaced with a breakpoint opcode. The trap bit in the global KidnynamicsTraceMask bitmask is set.

For kernel-mode targets, the breakpoint replacement can happen only when VBS (Virtualization

Based Security) is enabled. The MmWriteSystemImageTracepoint routine locates the loader data table

entry associated with the target function and invokes the SECURESERVICE_SET_TRACEPOINT secure

call. The Secure Kernel is the only entity able to collaborate with HyperGuard and thus to render the

breakpoint application a legit code modification. As explained in Chapter 7 of Part 1, Kernel Patch

protection (also known as Patchguard) prevents any code modification from being performed on the

NT kernel and some essential kernel drivers. If VBS is not enabled on the system, and a debugger is not

attached, an error code is returned, and the probe application fails. If a kernel debugger is attached,

CHAPTER 10    Management, diagnostics, and tracing     531


---

the breakpoint opcode is applied by the NT kernel through the MmDbgCopyMemory function.

(Patchguard is not enabled on debugged systems.)

When called for debugger exceptions, which may be caused by a DTrace's FTB or PID probe firing, the system exception handler (KiDispatchException) checks whether the "trap" bit is set in the global KiDynamicTraceMask bitmask. If it is, the exception handler calls the KiTpHandleTrap function, which searches into the KiTpHashTable to determine whether the exception occurred thanks to a registered FTB or PID probe firing. For user-mode probes, the function checks whether the process context is the expected one. If it is, or if the probe is a kernel-mode one, the function directly invokes the DTrace callback, FbtpCallback, which executes the actions associated with the probe. When the callback completes, the handler invokes the emulator, which emulates the original first instruction of the target function before transferring the execution context to it.

