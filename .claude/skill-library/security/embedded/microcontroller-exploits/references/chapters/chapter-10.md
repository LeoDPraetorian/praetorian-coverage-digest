## []{#ch10.xhtml_page_105 .pagebreak}**10  STM32F0 SWD Word Leak** {#ch10.xhtml_ch10 .h2a}

Many microcontrollers allow for some sort of partial locking mode, in
which a debugger may be attached but code is still protected. On the
STM32 family, this corresponds to RDP Level 1, where flash memory is
disconnected after the debugger connects. This chapter describes a
vulnerability in the STM32F0 series, in which flash memory is
disconnected two clock cycles too late. A carefully orchestrated
debugger can dump one word per connection.

This vulnerability was first described at Usenix WOOT, near the end of
Obermaier and Tatschner (2017).

### **The Bug** {#ch10.xhtml_ch00lev1sec36 .h3}

As we discussed in [Chapter 2](#ch02.xhtml_ch02), STM32's readout device
protection (RDP) feature has three levels. Level 0 is unprotected, while
Level 2 is a total JTAG lockout, rejecting all connection attempts.
Level 1 is the in-between setting that most commercial devices are
locked with; it works by disconnecting flash memory from the bus when
JTAG is connected. The intent was to allow for failure analysis or
reprogramming, while still preventing extraction of flash memory for
cloning or reverse engineering.

You can verify this with OpenOCD or another JTAG debugger. The
description holds: connecting to a locked chip works, but nothing useful
can be read from flash memory. You can read out RAM, or write something
into RAM, but code there cannot read or execute code from flash memory.

::: image
[]{#ch10.xhtml_page_106
.pagebreak}![Image](images/f0106-01.jpg){#ch10fig1}

> **Description:** Die photo of a microcontroller showing a large dense memory array occupying the left half of the chip. The right side contains control logic, peripheral circuits, and I/O interfaces with varying circuit densities. The top portion includes additional logic blocks and interface circuitry. Bond pads are visible along all edges for external connections. The die layout indicates a memory-centric design typical of microcontrollers with embedded flash or EEPROM storage.

:::

Figure 10.1: STM32F042

[]{#ch10.xhtml_page_107 .pagebreak}Obermaier's unique observation is
that most JTAG debuggers perform multiple transactions when connecting,
and that the *very first* memory access is responsible for locking out
flash memory, but that the read often completes before the lock is
applied!

Why *often* and not always? The details don't matter much for
exploitation, but the original paper makes a convincing argument that
it's some sort of a bus contention issue. As a workaround, it seems
sufficient to retry after failed accesses, and it might help in stubborn
situations to add a random delay.

### **The Exploit** {#ch10.xhtml_ch00lev1sec37 .h3}

Obermaier's exploit runs as standalone firmware in one STM32, which
implements the SWD protocol to dump the contents of the target chip.
Full source code is available, and the following is his function in C to
dump one 32-bit word from protected memory. SWD is simpler to implement
than JTAG, and in this exploit you'll see that the SWD implementation is
less than six hundred lines.

Note that the code must reconnect in a new debugging session for every
attempt, as flash memory becomes disconnected after the read. Because
individual attempts often fail, it must retry until the transaction
succeeds.

::: imagel
![Image](images/f0107-01.jpg)

> **Description:** C code function for reading 32-bit words from read-protected flash memory using a timing attack. The function extractFlashData takes a 32-bit aligned address and data pointer. It adds delay jitter at the moment of attack (DELAY_JITTER_MS_MIN), then enters a retry loop attempting to read via swdReadAHBAddr. The attack exploits timing variations to extract protected data, with statistics tracking attempts, successes, and failures.

:::

::: imagel
[]{#ch10.xhtml_page_108 .pagebreak}![Image](images/f0108-01.jpg)

> **Description:** C code continuation showing the retry logic for flash extraction attack. The code tries up to MAX_READ_TRIES times, calling targetSysOn() and waiting 5 microseconds between attempts. After enabling debug interface and setting AP to 32-bit mode, the "magic" happens at line 31 with swdReadAHBAddr reading the target address. If successful, data is extracted and statistics updated; on failure, delay jitter is incremented. The loop exits when data is successfully read or maximum attempts reached.

:::

[]{#ch11.xhtml}

